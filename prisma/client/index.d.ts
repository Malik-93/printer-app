
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model WsBillboards
 * 
 */
export type WsBillboards = $Result.DefaultSelection<Prisma.$WsBillboardsPayload>
/**
 * Model WsCategories
 * 
 */
export type WsCategories = $Result.DefaultSelection<Prisma.$WsCategoriesPayload>
/**
 * Model WsDepartments
 * 
 */
export type WsDepartments = $Result.DefaultSelection<Prisma.$WsDepartmentsPayload>
/**
 * Model WsHomeBanners
 * 
 */
export type WsHomeBanners = $Result.DefaultSelection<Prisma.$WsHomeBannersPayload>
/**
 * Model WsImages
 * 
 */
export type WsImages = $Result.DefaultSelection<Prisma.$WsImagesPayload>
/**
 * Model WSJob
 * 
 */
export type WSJob = $Result.DefaultSelection<Prisma.$WSJobPayload>
/**
 * Model WSJobApplication
 * 
 */
export type WSJobApplication = $Result.DefaultSelection<Prisma.$WSJobApplicationPayload>
/**
 * Model WSJobApplicationEducation
 * 
 */
export type WSJobApplicationEducation = $Result.DefaultSelection<Prisma.$WSJobApplicationEducationPayload>
/**
 * Model WSJobApplicationFeedback
 * 
 */
export type WSJobApplicationFeedback = $Result.DefaultSelection<Prisma.$WSJobApplicationFeedbackPayload>
/**
 * Model WSJobApplicationPreviousEmployment
 * 
 */
export type WSJobApplicationPreviousEmployment = $Result.DefaultSelection<Prisma.$WSJobApplicationPreviousEmploymentPayload>
/**
 * Model WSJobApplicationReference
 * 
 */
export type WSJobApplicationReference = $Result.DefaultSelection<Prisma.$WSJobApplicationReferencePayload>
/**
 * Model WsJobApplicationReply
 * 
 */
export type WsJobApplicationReply = $Result.DefaultSelection<Prisma.$WsJobApplicationReplyPayload>
/**
 * Model WsProducts
 * 
 */
export type WsProducts = $Result.DefaultSelection<Prisma.$WsProductsPayload>
/**
 * Model WsProfile
 * 
 */
export type WsProfile = $Result.DefaultSelection<Prisma.$WsProfilePayload>
/**
 * Model WSState
 * 
 */
export type WSState = $Result.DefaultSelection<Prisma.$WSStatePayload>
/**
 * Model WsStore
 * 
 */
export type WsStore = $Result.DefaultSelection<Prisma.$WsStorePayload>
/**
 * Model WSTaxExempt
 * 
 */
export type WSTaxExempt = $Result.DefaultSelection<Prisma.$WSTaxExemptPayload>
/**
 * Model WsUser
 * 
 */
export type WsUser = $Result.DefaultSelection<Prisma.$WsUserPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more WsBillboards
 * const wsBillboards = await prisma.wsBillboards.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more WsBillboards
   * const wsBillboards = await prisma.wsBillboards.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.wsBillboards`: Exposes CRUD operations for the **WsBillboards** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WsBillboards
    * const wsBillboards = await prisma.wsBillboards.findMany()
    * ```
    */
  get wsBillboards(): Prisma.WsBillboardsDelegate<ExtArgs>;

  /**
   * `prisma.wsCategories`: Exposes CRUD operations for the **WsCategories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WsCategories
    * const wsCategories = await prisma.wsCategories.findMany()
    * ```
    */
  get wsCategories(): Prisma.WsCategoriesDelegate<ExtArgs>;

  /**
   * `prisma.wsDepartments`: Exposes CRUD operations for the **WsDepartments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WsDepartments
    * const wsDepartments = await prisma.wsDepartments.findMany()
    * ```
    */
  get wsDepartments(): Prisma.WsDepartmentsDelegate<ExtArgs>;

  /**
   * `prisma.wsHomeBanners`: Exposes CRUD operations for the **WsHomeBanners** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WsHomeBanners
    * const wsHomeBanners = await prisma.wsHomeBanners.findMany()
    * ```
    */
  get wsHomeBanners(): Prisma.WsHomeBannersDelegate<ExtArgs>;

  /**
   * `prisma.wsImages`: Exposes CRUD operations for the **WsImages** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WsImages
    * const wsImages = await prisma.wsImages.findMany()
    * ```
    */
  get wsImages(): Prisma.WsImagesDelegate<ExtArgs>;

  /**
   * `prisma.wSJob`: Exposes CRUD operations for the **WSJob** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WSJobs
    * const wSJobs = await prisma.wSJob.findMany()
    * ```
    */
  get wSJob(): Prisma.WSJobDelegate<ExtArgs>;

  /**
   * `prisma.wSJobApplication`: Exposes CRUD operations for the **WSJobApplication** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WSJobApplications
    * const wSJobApplications = await prisma.wSJobApplication.findMany()
    * ```
    */
  get wSJobApplication(): Prisma.WSJobApplicationDelegate<ExtArgs>;

  /**
   * `prisma.wSJobApplicationEducation`: Exposes CRUD operations for the **WSJobApplicationEducation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WSJobApplicationEducations
    * const wSJobApplicationEducations = await prisma.wSJobApplicationEducation.findMany()
    * ```
    */
  get wSJobApplicationEducation(): Prisma.WSJobApplicationEducationDelegate<ExtArgs>;

  /**
   * `prisma.wSJobApplicationFeedback`: Exposes CRUD operations for the **WSJobApplicationFeedback** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WSJobApplicationFeedbacks
    * const wSJobApplicationFeedbacks = await prisma.wSJobApplicationFeedback.findMany()
    * ```
    */
  get wSJobApplicationFeedback(): Prisma.WSJobApplicationFeedbackDelegate<ExtArgs>;

  /**
   * `prisma.wSJobApplicationPreviousEmployment`: Exposes CRUD operations for the **WSJobApplicationPreviousEmployment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WSJobApplicationPreviousEmployments
    * const wSJobApplicationPreviousEmployments = await prisma.wSJobApplicationPreviousEmployment.findMany()
    * ```
    */
  get wSJobApplicationPreviousEmployment(): Prisma.WSJobApplicationPreviousEmploymentDelegate<ExtArgs>;

  /**
   * `prisma.wSJobApplicationReference`: Exposes CRUD operations for the **WSJobApplicationReference** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WSJobApplicationReferences
    * const wSJobApplicationReferences = await prisma.wSJobApplicationReference.findMany()
    * ```
    */
  get wSJobApplicationReference(): Prisma.WSJobApplicationReferenceDelegate<ExtArgs>;

  /**
   * `prisma.wsJobApplicationReply`: Exposes CRUD operations for the **WsJobApplicationReply** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WsJobApplicationReplies
    * const wsJobApplicationReplies = await prisma.wsJobApplicationReply.findMany()
    * ```
    */
  get wsJobApplicationReply(): Prisma.WsJobApplicationReplyDelegate<ExtArgs>;

  /**
   * `prisma.wsProducts`: Exposes CRUD operations for the **WsProducts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WsProducts
    * const wsProducts = await prisma.wsProducts.findMany()
    * ```
    */
  get wsProducts(): Prisma.WsProductsDelegate<ExtArgs>;

  /**
   * `prisma.wsProfile`: Exposes CRUD operations for the **WsProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WsProfiles
    * const wsProfiles = await prisma.wsProfile.findMany()
    * ```
    */
  get wsProfile(): Prisma.WsProfileDelegate<ExtArgs>;

  /**
   * `prisma.wSState`: Exposes CRUD operations for the **WSState** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WSStates
    * const wSStates = await prisma.wSState.findMany()
    * ```
    */
  get wSState(): Prisma.WSStateDelegate<ExtArgs>;

  /**
   * `prisma.wsStore`: Exposes CRUD operations for the **WsStore** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WsStores
    * const wsStores = await prisma.wsStore.findMany()
    * ```
    */
  get wsStore(): Prisma.WsStoreDelegate<ExtArgs>;

  /**
   * `prisma.wSTaxExempt`: Exposes CRUD operations for the **WSTaxExempt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WSTaxExempts
    * const wSTaxExempts = await prisma.wSTaxExempt.findMany()
    * ```
    */
  get wSTaxExempt(): Prisma.WSTaxExemptDelegate<ExtArgs>;

  /**
   * `prisma.wsUser`: Exposes CRUD operations for the **WsUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WsUsers
    * const wsUsers = await prisma.wsUser.findMany()
    * ```
    */
  get wsUser(): Prisma.WsUserDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    WsBillboards: 'WsBillboards',
    WsCategories: 'WsCategories',
    WsDepartments: 'WsDepartments',
    WsHomeBanners: 'WsHomeBanners',
    WsImages: 'WsImages',
    WSJob: 'WSJob',
    WSJobApplication: 'WSJobApplication',
    WSJobApplicationEducation: 'WSJobApplicationEducation',
    WSJobApplicationFeedback: 'WSJobApplicationFeedback',
    WSJobApplicationPreviousEmployment: 'WSJobApplicationPreviousEmployment',
    WSJobApplicationReference: 'WSJobApplicationReference',
    WsJobApplicationReply: 'WsJobApplicationReply',
    WsProducts: 'WsProducts',
    WsProfile: 'WsProfile',
    WSState: 'WSState',
    WsStore: 'WsStore',
    WSTaxExempt: 'WSTaxExempt',
    WsUser: 'WsUser'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "wsBillboards" | "wsCategories" | "wsDepartments" | "wsHomeBanners" | "wsImages" | "wSJob" | "wSJobApplication" | "wSJobApplicationEducation" | "wSJobApplicationFeedback" | "wSJobApplicationPreviousEmployment" | "wSJobApplicationReference" | "wsJobApplicationReply" | "wsProducts" | "wsProfile" | "wSState" | "wsStore" | "wSTaxExempt" | "wsUser"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      WsBillboards: {
        payload: Prisma.$WsBillboardsPayload<ExtArgs>
        fields: Prisma.WsBillboardsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WsBillboardsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsBillboardsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WsBillboardsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsBillboardsPayload>
          }
          findFirst: {
            args: Prisma.WsBillboardsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsBillboardsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WsBillboardsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsBillboardsPayload>
          }
          findMany: {
            args: Prisma.WsBillboardsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsBillboardsPayload>[]
          }
          create: {
            args: Prisma.WsBillboardsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsBillboardsPayload>
          }
          createMany: {
            args: Prisma.WsBillboardsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.WsBillboardsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsBillboardsPayload>
          }
          update: {
            args: Prisma.WsBillboardsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsBillboardsPayload>
          }
          deleteMany: {
            args: Prisma.WsBillboardsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WsBillboardsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WsBillboardsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsBillboardsPayload>
          }
          aggregate: {
            args: Prisma.WsBillboardsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWsBillboards>
          }
          groupBy: {
            args: Prisma.WsBillboardsGroupByArgs<ExtArgs>
            result: $Utils.Optional<WsBillboardsGroupByOutputType>[]
          }
          count: {
            args: Prisma.WsBillboardsCountArgs<ExtArgs>
            result: $Utils.Optional<WsBillboardsCountAggregateOutputType> | number
          }
        }
      }
      WsCategories: {
        payload: Prisma.$WsCategoriesPayload<ExtArgs>
        fields: Prisma.WsCategoriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WsCategoriesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsCategoriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WsCategoriesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsCategoriesPayload>
          }
          findFirst: {
            args: Prisma.WsCategoriesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsCategoriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WsCategoriesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsCategoriesPayload>
          }
          findMany: {
            args: Prisma.WsCategoriesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsCategoriesPayload>[]
          }
          create: {
            args: Prisma.WsCategoriesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsCategoriesPayload>
          }
          createMany: {
            args: Prisma.WsCategoriesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.WsCategoriesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsCategoriesPayload>
          }
          update: {
            args: Prisma.WsCategoriesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsCategoriesPayload>
          }
          deleteMany: {
            args: Prisma.WsCategoriesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WsCategoriesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WsCategoriesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsCategoriesPayload>
          }
          aggregate: {
            args: Prisma.WsCategoriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWsCategories>
          }
          groupBy: {
            args: Prisma.WsCategoriesGroupByArgs<ExtArgs>
            result: $Utils.Optional<WsCategoriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.WsCategoriesCountArgs<ExtArgs>
            result: $Utils.Optional<WsCategoriesCountAggregateOutputType> | number
          }
        }
      }
      WsDepartments: {
        payload: Prisma.$WsDepartmentsPayload<ExtArgs>
        fields: Prisma.WsDepartmentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WsDepartmentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsDepartmentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WsDepartmentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsDepartmentsPayload>
          }
          findFirst: {
            args: Prisma.WsDepartmentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsDepartmentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WsDepartmentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsDepartmentsPayload>
          }
          findMany: {
            args: Prisma.WsDepartmentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsDepartmentsPayload>[]
          }
          create: {
            args: Prisma.WsDepartmentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsDepartmentsPayload>
          }
          createMany: {
            args: Prisma.WsDepartmentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.WsDepartmentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsDepartmentsPayload>
          }
          update: {
            args: Prisma.WsDepartmentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsDepartmentsPayload>
          }
          deleteMany: {
            args: Prisma.WsDepartmentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WsDepartmentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WsDepartmentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsDepartmentsPayload>
          }
          aggregate: {
            args: Prisma.WsDepartmentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWsDepartments>
          }
          groupBy: {
            args: Prisma.WsDepartmentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<WsDepartmentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.WsDepartmentsCountArgs<ExtArgs>
            result: $Utils.Optional<WsDepartmentsCountAggregateOutputType> | number
          }
        }
      }
      WsHomeBanners: {
        payload: Prisma.$WsHomeBannersPayload<ExtArgs>
        fields: Prisma.WsHomeBannersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WsHomeBannersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsHomeBannersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WsHomeBannersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsHomeBannersPayload>
          }
          findFirst: {
            args: Prisma.WsHomeBannersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsHomeBannersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WsHomeBannersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsHomeBannersPayload>
          }
          findMany: {
            args: Prisma.WsHomeBannersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsHomeBannersPayload>[]
          }
          create: {
            args: Prisma.WsHomeBannersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsHomeBannersPayload>
          }
          createMany: {
            args: Prisma.WsHomeBannersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.WsHomeBannersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsHomeBannersPayload>
          }
          update: {
            args: Prisma.WsHomeBannersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsHomeBannersPayload>
          }
          deleteMany: {
            args: Prisma.WsHomeBannersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WsHomeBannersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WsHomeBannersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsHomeBannersPayload>
          }
          aggregate: {
            args: Prisma.WsHomeBannersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWsHomeBanners>
          }
          groupBy: {
            args: Prisma.WsHomeBannersGroupByArgs<ExtArgs>
            result: $Utils.Optional<WsHomeBannersGroupByOutputType>[]
          }
          count: {
            args: Prisma.WsHomeBannersCountArgs<ExtArgs>
            result: $Utils.Optional<WsHomeBannersCountAggregateOutputType> | number
          }
        }
      }
      WsImages: {
        payload: Prisma.$WsImagesPayload<ExtArgs>
        fields: Prisma.WsImagesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WsImagesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsImagesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WsImagesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsImagesPayload>
          }
          findFirst: {
            args: Prisma.WsImagesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsImagesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WsImagesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsImagesPayload>
          }
          findMany: {
            args: Prisma.WsImagesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsImagesPayload>[]
          }
          create: {
            args: Prisma.WsImagesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsImagesPayload>
          }
          createMany: {
            args: Prisma.WsImagesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.WsImagesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsImagesPayload>
          }
          update: {
            args: Prisma.WsImagesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsImagesPayload>
          }
          deleteMany: {
            args: Prisma.WsImagesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WsImagesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WsImagesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsImagesPayload>
          }
          aggregate: {
            args: Prisma.WsImagesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWsImages>
          }
          groupBy: {
            args: Prisma.WsImagesGroupByArgs<ExtArgs>
            result: $Utils.Optional<WsImagesGroupByOutputType>[]
          }
          count: {
            args: Prisma.WsImagesCountArgs<ExtArgs>
            result: $Utils.Optional<WsImagesCountAggregateOutputType> | number
          }
        }
      }
      WSJob: {
        payload: Prisma.$WSJobPayload<ExtArgs>
        fields: Prisma.WSJobFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WSJobFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSJobPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WSJobFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSJobPayload>
          }
          findFirst: {
            args: Prisma.WSJobFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSJobPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WSJobFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSJobPayload>
          }
          findMany: {
            args: Prisma.WSJobFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSJobPayload>[]
          }
          create: {
            args: Prisma.WSJobCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSJobPayload>
          }
          createMany: {
            args: Prisma.WSJobCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.WSJobDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSJobPayload>
          }
          update: {
            args: Prisma.WSJobUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSJobPayload>
          }
          deleteMany: {
            args: Prisma.WSJobDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WSJobUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WSJobUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSJobPayload>
          }
          aggregate: {
            args: Prisma.WSJobAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWSJob>
          }
          groupBy: {
            args: Prisma.WSJobGroupByArgs<ExtArgs>
            result: $Utils.Optional<WSJobGroupByOutputType>[]
          }
          count: {
            args: Prisma.WSJobCountArgs<ExtArgs>
            result: $Utils.Optional<WSJobCountAggregateOutputType> | number
          }
        }
      }
      WSJobApplication: {
        payload: Prisma.$WSJobApplicationPayload<ExtArgs>
        fields: Prisma.WSJobApplicationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WSJobApplicationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSJobApplicationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WSJobApplicationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSJobApplicationPayload>
          }
          findFirst: {
            args: Prisma.WSJobApplicationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSJobApplicationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WSJobApplicationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSJobApplicationPayload>
          }
          findMany: {
            args: Prisma.WSJobApplicationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSJobApplicationPayload>[]
          }
          create: {
            args: Prisma.WSJobApplicationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSJobApplicationPayload>
          }
          createMany: {
            args: Prisma.WSJobApplicationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.WSJobApplicationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSJobApplicationPayload>
          }
          update: {
            args: Prisma.WSJobApplicationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSJobApplicationPayload>
          }
          deleteMany: {
            args: Prisma.WSJobApplicationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WSJobApplicationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WSJobApplicationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSJobApplicationPayload>
          }
          aggregate: {
            args: Prisma.WSJobApplicationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWSJobApplication>
          }
          groupBy: {
            args: Prisma.WSJobApplicationGroupByArgs<ExtArgs>
            result: $Utils.Optional<WSJobApplicationGroupByOutputType>[]
          }
          count: {
            args: Prisma.WSJobApplicationCountArgs<ExtArgs>
            result: $Utils.Optional<WSJobApplicationCountAggregateOutputType> | number
          }
        }
      }
      WSJobApplicationEducation: {
        payload: Prisma.$WSJobApplicationEducationPayload<ExtArgs>
        fields: Prisma.WSJobApplicationEducationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WSJobApplicationEducationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSJobApplicationEducationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WSJobApplicationEducationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSJobApplicationEducationPayload>
          }
          findFirst: {
            args: Prisma.WSJobApplicationEducationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSJobApplicationEducationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WSJobApplicationEducationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSJobApplicationEducationPayload>
          }
          findMany: {
            args: Prisma.WSJobApplicationEducationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSJobApplicationEducationPayload>[]
          }
          create: {
            args: Prisma.WSJobApplicationEducationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSJobApplicationEducationPayload>
          }
          createMany: {
            args: Prisma.WSJobApplicationEducationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.WSJobApplicationEducationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSJobApplicationEducationPayload>
          }
          update: {
            args: Prisma.WSJobApplicationEducationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSJobApplicationEducationPayload>
          }
          deleteMany: {
            args: Prisma.WSJobApplicationEducationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WSJobApplicationEducationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WSJobApplicationEducationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSJobApplicationEducationPayload>
          }
          aggregate: {
            args: Prisma.WSJobApplicationEducationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWSJobApplicationEducation>
          }
          groupBy: {
            args: Prisma.WSJobApplicationEducationGroupByArgs<ExtArgs>
            result: $Utils.Optional<WSJobApplicationEducationGroupByOutputType>[]
          }
          count: {
            args: Prisma.WSJobApplicationEducationCountArgs<ExtArgs>
            result: $Utils.Optional<WSJobApplicationEducationCountAggregateOutputType> | number
          }
        }
      }
      WSJobApplicationFeedback: {
        payload: Prisma.$WSJobApplicationFeedbackPayload<ExtArgs>
        fields: Prisma.WSJobApplicationFeedbackFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WSJobApplicationFeedbackFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSJobApplicationFeedbackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WSJobApplicationFeedbackFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSJobApplicationFeedbackPayload>
          }
          findFirst: {
            args: Prisma.WSJobApplicationFeedbackFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSJobApplicationFeedbackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WSJobApplicationFeedbackFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSJobApplicationFeedbackPayload>
          }
          findMany: {
            args: Prisma.WSJobApplicationFeedbackFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSJobApplicationFeedbackPayload>[]
          }
          create: {
            args: Prisma.WSJobApplicationFeedbackCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSJobApplicationFeedbackPayload>
          }
          createMany: {
            args: Prisma.WSJobApplicationFeedbackCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.WSJobApplicationFeedbackDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSJobApplicationFeedbackPayload>
          }
          update: {
            args: Prisma.WSJobApplicationFeedbackUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSJobApplicationFeedbackPayload>
          }
          deleteMany: {
            args: Prisma.WSJobApplicationFeedbackDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WSJobApplicationFeedbackUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WSJobApplicationFeedbackUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSJobApplicationFeedbackPayload>
          }
          aggregate: {
            args: Prisma.WSJobApplicationFeedbackAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWSJobApplicationFeedback>
          }
          groupBy: {
            args: Prisma.WSJobApplicationFeedbackGroupByArgs<ExtArgs>
            result: $Utils.Optional<WSJobApplicationFeedbackGroupByOutputType>[]
          }
          count: {
            args: Prisma.WSJobApplicationFeedbackCountArgs<ExtArgs>
            result: $Utils.Optional<WSJobApplicationFeedbackCountAggregateOutputType> | number
          }
        }
      }
      WSJobApplicationPreviousEmployment: {
        payload: Prisma.$WSJobApplicationPreviousEmploymentPayload<ExtArgs>
        fields: Prisma.WSJobApplicationPreviousEmploymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WSJobApplicationPreviousEmploymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSJobApplicationPreviousEmploymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WSJobApplicationPreviousEmploymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSJobApplicationPreviousEmploymentPayload>
          }
          findFirst: {
            args: Prisma.WSJobApplicationPreviousEmploymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSJobApplicationPreviousEmploymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WSJobApplicationPreviousEmploymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSJobApplicationPreviousEmploymentPayload>
          }
          findMany: {
            args: Prisma.WSJobApplicationPreviousEmploymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSJobApplicationPreviousEmploymentPayload>[]
          }
          create: {
            args: Prisma.WSJobApplicationPreviousEmploymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSJobApplicationPreviousEmploymentPayload>
          }
          createMany: {
            args: Prisma.WSJobApplicationPreviousEmploymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.WSJobApplicationPreviousEmploymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSJobApplicationPreviousEmploymentPayload>
          }
          update: {
            args: Prisma.WSJobApplicationPreviousEmploymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSJobApplicationPreviousEmploymentPayload>
          }
          deleteMany: {
            args: Prisma.WSJobApplicationPreviousEmploymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WSJobApplicationPreviousEmploymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WSJobApplicationPreviousEmploymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSJobApplicationPreviousEmploymentPayload>
          }
          aggregate: {
            args: Prisma.WSJobApplicationPreviousEmploymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWSJobApplicationPreviousEmployment>
          }
          groupBy: {
            args: Prisma.WSJobApplicationPreviousEmploymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<WSJobApplicationPreviousEmploymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.WSJobApplicationPreviousEmploymentCountArgs<ExtArgs>
            result: $Utils.Optional<WSJobApplicationPreviousEmploymentCountAggregateOutputType> | number
          }
        }
      }
      WSJobApplicationReference: {
        payload: Prisma.$WSJobApplicationReferencePayload<ExtArgs>
        fields: Prisma.WSJobApplicationReferenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WSJobApplicationReferenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSJobApplicationReferencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WSJobApplicationReferenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSJobApplicationReferencePayload>
          }
          findFirst: {
            args: Prisma.WSJobApplicationReferenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSJobApplicationReferencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WSJobApplicationReferenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSJobApplicationReferencePayload>
          }
          findMany: {
            args: Prisma.WSJobApplicationReferenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSJobApplicationReferencePayload>[]
          }
          create: {
            args: Prisma.WSJobApplicationReferenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSJobApplicationReferencePayload>
          }
          createMany: {
            args: Prisma.WSJobApplicationReferenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.WSJobApplicationReferenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSJobApplicationReferencePayload>
          }
          update: {
            args: Prisma.WSJobApplicationReferenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSJobApplicationReferencePayload>
          }
          deleteMany: {
            args: Prisma.WSJobApplicationReferenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WSJobApplicationReferenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WSJobApplicationReferenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSJobApplicationReferencePayload>
          }
          aggregate: {
            args: Prisma.WSJobApplicationReferenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWSJobApplicationReference>
          }
          groupBy: {
            args: Prisma.WSJobApplicationReferenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<WSJobApplicationReferenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.WSJobApplicationReferenceCountArgs<ExtArgs>
            result: $Utils.Optional<WSJobApplicationReferenceCountAggregateOutputType> | number
          }
        }
      }
      WsJobApplicationReply: {
        payload: Prisma.$WsJobApplicationReplyPayload<ExtArgs>
        fields: Prisma.WsJobApplicationReplyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WsJobApplicationReplyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsJobApplicationReplyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WsJobApplicationReplyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsJobApplicationReplyPayload>
          }
          findFirst: {
            args: Prisma.WsJobApplicationReplyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsJobApplicationReplyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WsJobApplicationReplyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsJobApplicationReplyPayload>
          }
          findMany: {
            args: Prisma.WsJobApplicationReplyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsJobApplicationReplyPayload>[]
          }
          create: {
            args: Prisma.WsJobApplicationReplyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsJobApplicationReplyPayload>
          }
          createMany: {
            args: Prisma.WsJobApplicationReplyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.WsJobApplicationReplyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsJobApplicationReplyPayload>
          }
          update: {
            args: Prisma.WsJobApplicationReplyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsJobApplicationReplyPayload>
          }
          deleteMany: {
            args: Prisma.WsJobApplicationReplyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WsJobApplicationReplyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WsJobApplicationReplyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsJobApplicationReplyPayload>
          }
          aggregate: {
            args: Prisma.WsJobApplicationReplyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWsJobApplicationReply>
          }
          groupBy: {
            args: Prisma.WsJobApplicationReplyGroupByArgs<ExtArgs>
            result: $Utils.Optional<WsJobApplicationReplyGroupByOutputType>[]
          }
          count: {
            args: Prisma.WsJobApplicationReplyCountArgs<ExtArgs>
            result: $Utils.Optional<WsJobApplicationReplyCountAggregateOutputType> | number
          }
        }
      }
      WsProducts: {
        payload: Prisma.$WsProductsPayload<ExtArgs>
        fields: Prisma.WsProductsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WsProductsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsProductsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WsProductsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsProductsPayload>
          }
          findFirst: {
            args: Prisma.WsProductsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsProductsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WsProductsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsProductsPayload>
          }
          findMany: {
            args: Prisma.WsProductsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsProductsPayload>[]
          }
          create: {
            args: Prisma.WsProductsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsProductsPayload>
          }
          createMany: {
            args: Prisma.WsProductsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.WsProductsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsProductsPayload>
          }
          update: {
            args: Prisma.WsProductsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsProductsPayload>
          }
          deleteMany: {
            args: Prisma.WsProductsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WsProductsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WsProductsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsProductsPayload>
          }
          aggregate: {
            args: Prisma.WsProductsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWsProducts>
          }
          groupBy: {
            args: Prisma.WsProductsGroupByArgs<ExtArgs>
            result: $Utils.Optional<WsProductsGroupByOutputType>[]
          }
          count: {
            args: Prisma.WsProductsCountArgs<ExtArgs>
            result: $Utils.Optional<WsProductsCountAggregateOutputType> | number
          }
        }
      }
      WsProfile: {
        payload: Prisma.$WsProfilePayload<ExtArgs>
        fields: Prisma.WsProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WsProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WsProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsProfilePayload>
          }
          findFirst: {
            args: Prisma.WsProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WsProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsProfilePayload>
          }
          findMany: {
            args: Prisma.WsProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsProfilePayload>[]
          }
          create: {
            args: Prisma.WsProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsProfilePayload>
          }
          createMany: {
            args: Prisma.WsProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.WsProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsProfilePayload>
          }
          update: {
            args: Prisma.WsProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsProfilePayload>
          }
          deleteMany: {
            args: Prisma.WsProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WsProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WsProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsProfilePayload>
          }
          aggregate: {
            args: Prisma.WsProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWsProfile>
          }
          groupBy: {
            args: Prisma.WsProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<WsProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.WsProfileCountArgs<ExtArgs>
            result: $Utils.Optional<WsProfileCountAggregateOutputType> | number
          }
        }
      }
      WSState: {
        payload: Prisma.$WSStatePayload<ExtArgs>
        fields: Prisma.WSStateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WSStateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSStatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WSStateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSStatePayload>
          }
          findFirst: {
            args: Prisma.WSStateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSStatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WSStateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSStatePayload>
          }
          findMany: {
            args: Prisma.WSStateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSStatePayload>[]
          }
          create: {
            args: Prisma.WSStateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSStatePayload>
          }
          createMany: {
            args: Prisma.WSStateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.WSStateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSStatePayload>
          }
          update: {
            args: Prisma.WSStateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSStatePayload>
          }
          deleteMany: {
            args: Prisma.WSStateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WSStateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WSStateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSStatePayload>
          }
          aggregate: {
            args: Prisma.WSStateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWSState>
          }
          groupBy: {
            args: Prisma.WSStateGroupByArgs<ExtArgs>
            result: $Utils.Optional<WSStateGroupByOutputType>[]
          }
          count: {
            args: Prisma.WSStateCountArgs<ExtArgs>
            result: $Utils.Optional<WSStateCountAggregateOutputType> | number
          }
        }
      }
      WsStore: {
        payload: Prisma.$WsStorePayload<ExtArgs>
        fields: Prisma.WsStoreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WsStoreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsStorePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WsStoreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsStorePayload>
          }
          findFirst: {
            args: Prisma.WsStoreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsStorePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WsStoreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsStorePayload>
          }
          findMany: {
            args: Prisma.WsStoreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsStorePayload>[]
          }
          create: {
            args: Prisma.WsStoreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsStorePayload>
          }
          createMany: {
            args: Prisma.WsStoreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.WsStoreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsStorePayload>
          }
          update: {
            args: Prisma.WsStoreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsStorePayload>
          }
          deleteMany: {
            args: Prisma.WsStoreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WsStoreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WsStoreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsStorePayload>
          }
          aggregate: {
            args: Prisma.WsStoreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWsStore>
          }
          groupBy: {
            args: Prisma.WsStoreGroupByArgs<ExtArgs>
            result: $Utils.Optional<WsStoreGroupByOutputType>[]
          }
          count: {
            args: Prisma.WsStoreCountArgs<ExtArgs>
            result: $Utils.Optional<WsStoreCountAggregateOutputType> | number
          }
        }
      }
      WSTaxExempt: {
        payload: Prisma.$WSTaxExemptPayload<ExtArgs>
        fields: Prisma.WSTaxExemptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WSTaxExemptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSTaxExemptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WSTaxExemptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSTaxExemptPayload>
          }
          findFirst: {
            args: Prisma.WSTaxExemptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSTaxExemptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WSTaxExemptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSTaxExemptPayload>
          }
          findMany: {
            args: Prisma.WSTaxExemptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSTaxExemptPayload>[]
          }
          create: {
            args: Prisma.WSTaxExemptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSTaxExemptPayload>
          }
          createMany: {
            args: Prisma.WSTaxExemptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.WSTaxExemptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSTaxExemptPayload>
          }
          update: {
            args: Prisma.WSTaxExemptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSTaxExemptPayload>
          }
          deleteMany: {
            args: Prisma.WSTaxExemptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WSTaxExemptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WSTaxExemptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WSTaxExemptPayload>
          }
          aggregate: {
            args: Prisma.WSTaxExemptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWSTaxExempt>
          }
          groupBy: {
            args: Prisma.WSTaxExemptGroupByArgs<ExtArgs>
            result: $Utils.Optional<WSTaxExemptGroupByOutputType>[]
          }
          count: {
            args: Prisma.WSTaxExemptCountArgs<ExtArgs>
            result: $Utils.Optional<WSTaxExemptCountAggregateOutputType> | number
          }
        }
      }
      WsUser: {
        payload: Prisma.$WsUserPayload<ExtArgs>
        fields: Prisma.WsUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WsUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WsUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsUserPayload>
          }
          findFirst: {
            args: Prisma.WsUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WsUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsUserPayload>
          }
          findMany: {
            args: Prisma.WsUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsUserPayload>[]
          }
          create: {
            args: Prisma.WsUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsUserPayload>
          }
          createMany: {
            args: Prisma.WsUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.WsUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsUserPayload>
          }
          update: {
            args: Prisma.WsUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsUserPayload>
          }
          deleteMany: {
            args: Prisma.WsUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WsUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WsUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WsUserPayload>
          }
          aggregate: {
            args: Prisma.WsUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWsUser>
          }
          groupBy: {
            args: Prisma.WsUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<WsUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.WsUserCountArgs<ExtArgs>
            result: $Utils.Optional<WsUserCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type WsDepartmentsCountOutputType
   */

  export type WsDepartmentsCountOutputType = {
    WsProducts: number
  }

  export type WsDepartmentsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    WsProducts?: boolean | WsDepartmentsCountOutputTypeCountWsProductsArgs
  }

  // Custom InputTypes
  /**
   * WsDepartmentsCountOutputType without action
   */
  export type WsDepartmentsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsDepartmentsCountOutputType
     */
    select?: WsDepartmentsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WsDepartmentsCountOutputType without action
   */
  export type WsDepartmentsCountOutputTypeCountWsProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WsProductsWhereInput
  }


  /**
   * Count Type WSJobCountOutputType
   */

  export type WSJobCountOutputType = {
    WSJobApplication: number
  }

  export type WSJobCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    WSJobApplication?: boolean | WSJobCountOutputTypeCountWSJobApplicationArgs
  }

  // Custom InputTypes
  /**
   * WSJobCountOutputType without action
   */
  export type WSJobCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJobCountOutputType
     */
    select?: WSJobCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WSJobCountOutputType without action
   */
  export type WSJobCountOutputTypeCountWSJobApplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WSJobApplicationWhereInput
  }


  /**
   * Count Type WSJobApplicationCountOutputType
   */

  export type WSJobApplicationCountOutputType = {
    WSJobApplicationEducation: number
    WSJobApplicationFeedback: number
    WSJobApplicationPreviousEmployment: number
    WSJobApplicationReference: number
  }

  export type WSJobApplicationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    WSJobApplicationEducation?: boolean | WSJobApplicationCountOutputTypeCountWSJobApplicationEducationArgs
    WSJobApplicationFeedback?: boolean | WSJobApplicationCountOutputTypeCountWSJobApplicationFeedbackArgs
    WSJobApplicationPreviousEmployment?: boolean | WSJobApplicationCountOutputTypeCountWSJobApplicationPreviousEmploymentArgs
    WSJobApplicationReference?: boolean | WSJobApplicationCountOutputTypeCountWSJobApplicationReferenceArgs
  }

  // Custom InputTypes
  /**
   * WSJobApplicationCountOutputType without action
   */
  export type WSJobApplicationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJobApplicationCountOutputType
     */
    select?: WSJobApplicationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WSJobApplicationCountOutputType without action
   */
  export type WSJobApplicationCountOutputTypeCountWSJobApplicationEducationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WSJobApplicationEducationWhereInput
  }

  /**
   * WSJobApplicationCountOutputType without action
   */
  export type WSJobApplicationCountOutputTypeCountWSJobApplicationFeedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WSJobApplicationFeedbackWhereInput
  }

  /**
   * WSJobApplicationCountOutputType without action
   */
  export type WSJobApplicationCountOutputTypeCountWSJobApplicationPreviousEmploymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WSJobApplicationPreviousEmploymentWhereInput
  }

  /**
   * WSJobApplicationCountOutputType without action
   */
  export type WSJobApplicationCountOutputTypeCountWSJobApplicationReferenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WSJobApplicationReferenceWhereInput
  }


  /**
   * Count Type WSJobApplicationFeedbackCountOutputType
   */

  export type WSJobApplicationFeedbackCountOutputType = {
    WsJobApplicationReply: number
  }

  export type WSJobApplicationFeedbackCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    WsJobApplicationReply?: boolean | WSJobApplicationFeedbackCountOutputTypeCountWsJobApplicationReplyArgs
  }

  // Custom InputTypes
  /**
   * WSJobApplicationFeedbackCountOutputType without action
   */
  export type WSJobApplicationFeedbackCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJobApplicationFeedbackCountOutputType
     */
    select?: WSJobApplicationFeedbackCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WSJobApplicationFeedbackCountOutputType without action
   */
  export type WSJobApplicationFeedbackCountOutputTypeCountWsJobApplicationReplyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WsJobApplicationReplyWhereInput
  }


  /**
   * Count Type WsStoreCountOutputType
   */

  export type WsStoreCountOutputType = {
    WSJob: number
  }

  export type WsStoreCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    WSJob?: boolean | WsStoreCountOutputTypeCountWSJobArgs
  }

  // Custom InputTypes
  /**
   * WsStoreCountOutputType without action
   */
  export type WsStoreCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsStoreCountOutputType
     */
    select?: WsStoreCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WsStoreCountOutputType without action
   */
  export type WsStoreCountOutputTypeCountWSJobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WSJobWhereInput
  }


  /**
   * Count Type WSTaxExemptCountOutputType
   */

  export type WSTaxExemptCountOutputType = {
    WSState: number
  }

  export type WSTaxExemptCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    WSState?: boolean | WSTaxExemptCountOutputTypeCountWSStateArgs
  }

  // Custom InputTypes
  /**
   * WSTaxExemptCountOutputType without action
   */
  export type WSTaxExemptCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSTaxExemptCountOutputType
     */
    select?: WSTaxExemptCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WSTaxExemptCountOutputType without action
   */
  export type WSTaxExemptCountOutputTypeCountWSStateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WSStateWhereInput
  }


  /**
   * Count Type WsUserCountOutputType
   */

  export type WsUserCountOutputType = {
    WSJobApplication: number
  }

  export type WsUserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    WSJobApplication?: boolean | WsUserCountOutputTypeCountWSJobApplicationArgs
  }

  // Custom InputTypes
  /**
   * WsUserCountOutputType without action
   */
  export type WsUserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsUserCountOutputType
     */
    select?: WsUserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WsUserCountOutputType without action
   */
  export type WsUserCountOutputTypeCountWSJobApplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WSJobApplicationWhereInput
  }


  /**
   * Models
   */

  /**
   * Model WsBillboards
   */

  export type AggregateWsBillboards = {
    _count: WsBillboardsCountAggregateOutputType | null
    _avg: WsBillboardsAvgAggregateOutputType | null
    _sum: WsBillboardsSumAggregateOutputType | null
    _min: WsBillboardsMinAggregateOutputType | null
    _max: WsBillboardsMaxAggregateOutputType | null
  }

  export type WsBillboardsAvgAggregateOutputType = {
    ID: number | null
    order: number | null
  }

  export type WsBillboardsSumAggregateOutputType = {
    ID: number | null
    order: number | null
  }

  export type WsBillboardsMinAggregateOutputType = {
    ID: number | null
    alias: string | null
    description: string | null
    order: number | null
    is_enabled: boolean | null
    banner_url: string | null
    created_on: Date | null
    created_by: string | null
  }

  export type WsBillboardsMaxAggregateOutputType = {
    ID: number | null
    alias: string | null
    description: string | null
    order: number | null
    is_enabled: boolean | null
    banner_url: string | null
    created_on: Date | null
    created_by: string | null
  }

  export type WsBillboardsCountAggregateOutputType = {
    ID: number
    alias: number
    description: number
    order: number
    is_enabled: number
    banner_url: number
    created_on: number
    created_by: number
    _all: number
  }


  export type WsBillboardsAvgAggregateInputType = {
    ID?: true
    order?: true
  }

  export type WsBillboardsSumAggregateInputType = {
    ID?: true
    order?: true
  }

  export type WsBillboardsMinAggregateInputType = {
    ID?: true
    alias?: true
    description?: true
    order?: true
    is_enabled?: true
    banner_url?: true
    created_on?: true
    created_by?: true
  }

  export type WsBillboardsMaxAggregateInputType = {
    ID?: true
    alias?: true
    description?: true
    order?: true
    is_enabled?: true
    banner_url?: true
    created_on?: true
    created_by?: true
  }

  export type WsBillboardsCountAggregateInputType = {
    ID?: true
    alias?: true
    description?: true
    order?: true
    is_enabled?: true
    banner_url?: true
    created_on?: true
    created_by?: true
    _all?: true
  }

  export type WsBillboardsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WsBillboards to aggregate.
     */
    where?: WsBillboardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WsBillboards to fetch.
     */
    orderBy?: WsBillboardsOrderByWithRelationInput | WsBillboardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WsBillboardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WsBillboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WsBillboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WsBillboards
    **/
    _count?: true | WsBillboardsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WsBillboardsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WsBillboardsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WsBillboardsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WsBillboardsMaxAggregateInputType
  }

  export type GetWsBillboardsAggregateType<T extends WsBillboardsAggregateArgs> = {
        [P in keyof T & keyof AggregateWsBillboards]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWsBillboards[P]>
      : GetScalarType<T[P], AggregateWsBillboards[P]>
  }




  export type WsBillboardsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WsBillboardsWhereInput
    orderBy?: WsBillboardsOrderByWithAggregationInput | WsBillboardsOrderByWithAggregationInput[]
    by: WsBillboardsScalarFieldEnum[] | WsBillboardsScalarFieldEnum
    having?: WsBillboardsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WsBillboardsCountAggregateInputType | true
    _avg?: WsBillboardsAvgAggregateInputType
    _sum?: WsBillboardsSumAggregateInputType
    _min?: WsBillboardsMinAggregateInputType
    _max?: WsBillboardsMaxAggregateInputType
  }

  export type WsBillboardsGroupByOutputType = {
    ID: number
    alias: string | null
    description: string | null
    order: number | null
    is_enabled: boolean | null
    banner_url: string | null
    created_on: Date | null
    created_by: string | null
    _count: WsBillboardsCountAggregateOutputType | null
    _avg: WsBillboardsAvgAggregateOutputType | null
    _sum: WsBillboardsSumAggregateOutputType | null
    _min: WsBillboardsMinAggregateOutputType | null
    _max: WsBillboardsMaxAggregateOutputType | null
  }

  type GetWsBillboardsGroupByPayload<T extends WsBillboardsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WsBillboardsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WsBillboardsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WsBillboardsGroupByOutputType[P]>
            : GetScalarType<T[P], WsBillboardsGroupByOutputType[P]>
        }
      >
    >


  export type WsBillboardsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    alias?: boolean
    description?: boolean
    order?: boolean
    is_enabled?: boolean
    banner_url?: boolean
    created_on?: boolean
    created_by?: boolean
  }, ExtArgs["result"]["wsBillboards"]>


  export type WsBillboardsSelectScalar = {
    ID?: boolean
    alias?: boolean
    description?: boolean
    order?: boolean
    is_enabled?: boolean
    banner_url?: boolean
    created_on?: boolean
    created_by?: boolean
  }


  export type $WsBillboardsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WsBillboards"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      alias: string | null
      description: string | null
      order: number | null
      is_enabled: boolean | null
      banner_url: string | null
      created_on: Date | null
      created_by: string | null
    }, ExtArgs["result"]["wsBillboards"]>
    composites: {}
  }

  type WsBillboardsGetPayload<S extends boolean | null | undefined | WsBillboardsDefaultArgs> = $Result.GetResult<Prisma.$WsBillboardsPayload, S>

  type WsBillboardsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WsBillboardsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WsBillboardsCountAggregateInputType | true
    }

  export interface WsBillboardsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WsBillboards'], meta: { name: 'WsBillboards' } }
    /**
     * Find zero or one WsBillboards that matches the filter.
     * @param {WsBillboardsFindUniqueArgs} args - Arguments to find a WsBillboards
     * @example
     * // Get one WsBillboards
     * const wsBillboards = await prisma.wsBillboards.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WsBillboardsFindUniqueArgs>(args: SelectSubset<T, WsBillboardsFindUniqueArgs<ExtArgs>>): Prisma__WsBillboardsClient<$Result.GetResult<Prisma.$WsBillboardsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WsBillboards that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WsBillboardsFindUniqueOrThrowArgs} args - Arguments to find a WsBillboards
     * @example
     * // Get one WsBillboards
     * const wsBillboards = await prisma.wsBillboards.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WsBillboardsFindUniqueOrThrowArgs>(args: SelectSubset<T, WsBillboardsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WsBillboardsClient<$Result.GetResult<Prisma.$WsBillboardsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WsBillboards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsBillboardsFindFirstArgs} args - Arguments to find a WsBillboards
     * @example
     * // Get one WsBillboards
     * const wsBillboards = await prisma.wsBillboards.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WsBillboardsFindFirstArgs>(args?: SelectSubset<T, WsBillboardsFindFirstArgs<ExtArgs>>): Prisma__WsBillboardsClient<$Result.GetResult<Prisma.$WsBillboardsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WsBillboards that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsBillboardsFindFirstOrThrowArgs} args - Arguments to find a WsBillboards
     * @example
     * // Get one WsBillboards
     * const wsBillboards = await prisma.wsBillboards.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WsBillboardsFindFirstOrThrowArgs>(args?: SelectSubset<T, WsBillboardsFindFirstOrThrowArgs<ExtArgs>>): Prisma__WsBillboardsClient<$Result.GetResult<Prisma.$WsBillboardsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WsBillboards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsBillboardsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WsBillboards
     * const wsBillboards = await prisma.wsBillboards.findMany()
     * 
     * // Get first 10 WsBillboards
     * const wsBillboards = await prisma.wsBillboards.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const wsBillboardsWithIDOnly = await prisma.wsBillboards.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends WsBillboardsFindManyArgs>(args?: SelectSubset<T, WsBillboardsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WsBillboardsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WsBillboards.
     * @param {WsBillboardsCreateArgs} args - Arguments to create a WsBillboards.
     * @example
     * // Create one WsBillboards
     * const WsBillboards = await prisma.wsBillboards.create({
     *   data: {
     *     // ... data to create a WsBillboards
     *   }
     * })
     * 
     */
    create<T extends WsBillboardsCreateArgs>(args: SelectSubset<T, WsBillboardsCreateArgs<ExtArgs>>): Prisma__WsBillboardsClient<$Result.GetResult<Prisma.$WsBillboardsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WsBillboards.
     * @param {WsBillboardsCreateManyArgs} args - Arguments to create many WsBillboards.
     * @example
     * // Create many WsBillboards
     * const wsBillboards = await prisma.wsBillboards.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WsBillboardsCreateManyArgs>(args?: SelectSubset<T, WsBillboardsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WsBillboards.
     * @param {WsBillboardsDeleteArgs} args - Arguments to delete one WsBillboards.
     * @example
     * // Delete one WsBillboards
     * const WsBillboards = await prisma.wsBillboards.delete({
     *   where: {
     *     // ... filter to delete one WsBillboards
     *   }
     * })
     * 
     */
    delete<T extends WsBillboardsDeleteArgs>(args: SelectSubset<T, WsBillboardsDeleteArgs<ExtArgs>>): Prisma__WsBillboardsClient<$Result.GetResult<Prisma.$WsBillboardsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WsBillboards.
     * @param {WsBillboardsUpdateArgs} args - Arguments to update one WsBillboards.
     * @example
     * // Update one WsBillboards
     * const wsBillboards = await prisma.wsBillboards.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WsBillboardsUpdateArgs>(args: SelectSubset<T, WsBillboardsUpdateArgs<ExtArgs>>): Prisma__WsBillboardsClient<$Result.GetResult<Prisma.$WsBillboardsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WsBillboards.
     * @param {WsBillboardsDeleteManyArgs} args - Arguments to filter WsBillboards to delete.
     * @example
     * // Delete a few WsBillboards
     * const { count } = await prisma.wsBillboards.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WsBillboardsDeleteManyArgs>(args?: SelectSubset<T, WsBillboardsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WsBillboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsBillboardsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WsBillboards
     * const wsBillboards = await prisma.wsBillboards.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WsBillboardsUpdateManyArgs>(args: SelectSubset<T, WsBillboardsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WsBillboards.
     * @param {WsBillboardsUpsertArgs} args - Arguments to update or create a WsBillboards.
     * @example
     * // Update or create a WsBillboards
     * const wsBillboards = await prisma.wsBillboards.upsert({
     *   create: {
     *     // ... data to create a WsBillboards
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WsBillboards we want to update
     *   }
     * })
     */
    upsert<T extends WsBillboardsUpsertArgs>(args: SelectSubset<T, WsBillboardsUpsertArgs<ExtArgs>>): Prisma__WsBillboardsClient<$Result.GetResult<Prisma.$WsBillboardsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WsBillboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsBillboardsCountArgs} args - Arguments to filter WsBillboards to count.
     * @example
     * // Count the number of WsBillboards
     * const count = await prisma.wsBillboards.count({
     *   where: {
     *     // ... the filter for the WsBillboards we want to count
     *   }
     * })
    **/
    count<T extends WsBillboardsCountArgs>(
      args?: Subset<T, WsBillboardsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WsBillboardsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WsBillboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsBillboardsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WsBillboardsAggregateArgs>(args: Subset<T, WsBillboardsAggregateArgs>): Prisma.PrismaPromise<GetWsBillboardsAggregateType<T>>

    /**
     * Group by WsBillboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsBillboardsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WsBillboardsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WsBillboardsGroupByArgs['orderBy'] }
        : { orderBy?: WsBillboardsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WsBillboardsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWsBillboardsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WsBillboards model
   */
  readonly fields: WsBillboardsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WsBillboards.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WsBillboardsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WsBillboards model
   */ 
  interface WsBillboardsFieldRefs {
    readonly ID: FieldRef<"WsBillboards", 'Int'>
    readonly alias: FieldRef<"WsBillboards", 'String'>
    readonly description: FieldRef<"WsBillboards", 'String'>
    readonly order: FieldRef<"WsBillboards", 'Int'>
    readonly is_enabled: FieldRef<"WsBillboards", 'Boolean'>
    readonly banner_url: FieldRef<"WsBillboards", 'String'>
    readonly created_on: FieldRef<"WsBillboards", 'DateTime'>
    readonly created_by: FieldRef<"WsBillboards", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WsBillboards findUnique
   */
  export type WsBillboardsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsBillboards
     */
    select?: WsBillboardsSelect<ExtArgs> | null
    /**
     * Filter, which WsBillboards to fetch.
     */
    where: WsBillboardsWhereUniqueInput
  }

  /**
   * WsBillboards findUniqueOrThrow
   */
  export type WsBillboardsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsBillboards
     */
    select?: WsBillboardsSelect<ExtArgs> | null
    /**
     * Filter, which WsBillboards to fetch.
     */
    where: WsBillboardsWhereUniqueInput
  }

  /**
   * WsBillboards findFirst
   */
  export type WsBillboardsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsBillboards
     */
    select?: WsBillboardsSelect<ExtArgs> | null
    /**
     * Filter, which WsBillboards to fetch.
     */
    where?: WsBillboardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WsBillboards to fetch.
     */
    orderBy?: WsBillboardsOrderByWithRelationInput | WsBillboardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WsBillboards.
     */
    cursor?: WsBillboardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WsBillboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WsBillboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WsBillboards.
     */
    distinct?: WsBillboardsScalarFieldEnum | WsBillboardsScalarFieldEnum[]
  }

  /**
   * WsBillboards findFirstOrThrow
   */
  export type WsBillboardsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsBillboards
     */
    select?: WsBillboardsSelect<ExtArgs> | null
    /**
     * Filter, which WsBillboards to fetch.
     */
    where?: WsBillboardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WsBillboards to fetch.
     */
    orderBy?: WsBillboardsOrderByWithRelationInput | WsBillboardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WsBillboards.
     */
    cursor?: WsBillboardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WsBillboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WsBillboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WsBillboards.
     */
    distinct?: WsBillboardsScalarFieldEnum | WsBillboardsScalarFieldEnum[]
  }

  /**
   * WsBillboards findMany
   */
  export type WsBillboardsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsBillboards
     */
    select?: WsBillboardsSelect<ExtArgs> | null
    /**
     * Filter, which WsBillboards to fetch.
     */
    where?: WsBillboardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WsBillboards to fetch.
     */
    orderBy?: WsBillboardsOrderByWithRelationInput | WsBillboardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WsBillboards.
     */
    cursor?: WsBillboardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WsBillboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WsBillboards.
     */
    skip?: number
    distinct?: WsBillboardsScalarFieldEnum | WsBillboardsScalarFieldEnum[]
  }

  /**
   * WsBillboards create
   */
  export type WsBillboardsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsBillboards
     */
    select?: WsBillboardsSelect<ExtArgs> | null
    /**
     * The data needed to create a WsBillboards.
     */
    data?: XOR<WsBillboardsCreateInput, WsBillboardsUncheckedCreateInput>
  }

  /**
   * WsBillboards createMany
   */
  export type WsBillboardsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WsBillboards.
     */
    data: WsBillboardsCreateManyInput | WsBillboardsCreateManyInput[]
  }

  /**
   * WsBillboards update
   */
  export type WsBillboardsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsBillboards
     */
    select?: WsBillboardsSelect<ExtArgs> | null
    /**
     * The data needed to update a WsBillboards.
     */
    data: XOR<WsBillboardsUpdateInput, WsBillboardsUncheckedUpdateInput>
    /**
     * Choose, which WsBillboards to update.
     */
    where: WsBillboardsWhereUniqueInput
  }

  /**
   * WsBillboards updateMany
   */
  export type WsBillboardsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WsBillboards.
     */
    data: XOR<WsBillboardsUpdateManyMutationInput, WsBillboardsUncheckedUpdateManyInput>
    /**
     * Filter which WsBillboards to update
     */
    where?: WsBillboardsWhereInput
  }

  /**
   * WsBillboards upsert
   */
  export type WsBillboardsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsBillboards
     */
    select?: WsBillboardsSelect<ExtArgs> | null
    /**
     * The filter to search for the WsBillboards to update in case it exists.
     */
    where: WsBillboardsWhereUniqueInput
    /**
     * In case the WsBillboards found by the `where` argument doesn't exist, create a new WsBillboards with this data.
     */
    create: XOR<WsBillboardsCreateInput, WsBillboardsUncheckedCreateInput>
    /**
     * In case the WsBillboards was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WsBillboardsUpdateInput, WsBillboardsUncheckedUpdateInput>
  }

  /**
   * WsBillboards delete
   */
  export type WsBillboardsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsBillboards
     */
    select?: WsBillboardsSelect<ExtArgs> | null
    /**
     * Filter which WsBillboards to delete.
     */
    where: WsBillboardsWhereUniqueInput
  }

  /**
   * WsBillboards deleteMany
   */
  export type WsBillboardsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WsBillboards to delete
     */
    where?: WsBillboardsWhereInput
  }

  /**
   * WsBillboards without action
   */
  export type WsBillboardsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsBillboards
     */
    select?: WsBillboardsSelect<ExtArgs> | null
  }


  /**
   * Model WsCategories
   */

  export type AggregateWsCategories = {
    _count: WsCategoriesCountAggregateOutputType | null
    _avg: WsCategoriesAvgAggregateOutputType | null
    _sum: WsCategoriesSumAggregateOutputType | null
    _min: WsCategoriesMinAggregateOutputType | null
    _max: WsCategoriesMaxAggregateOutputType | null
  }

  export type WsCategoriesAvgAggregateOutputType = {
    ID: number | null
  }

  export type WsCategoriesSumAggregateOutputType = {
    ID: number | null
  }

  export type WsCategoriesMinAggregateOutputType = {
    ID: number | null
    Category: string | null
    Type: string | null
  }

  export type WsCategoriesMaxAggregateOutputType = {
    ID: number | null
    Category: string | null
    Type: string | null
  }

  export type WsCategoriesCountAggregateOutputType = {
    ID: number
    Category: number
    Type: number
    _all: number
  }


  export type WsCategoriesAvgAggregateInputType = {
    ID?: true
  }

  export type WsCategoriesSumAggregateInputType = {
    ID?: true
  }

  export type WsCategoriesMinAggregateInputType = {
    ID?: true
    Category?: true
    Type?: true
  }

  export type WsCategoriesMaxAggregateInputType = {
    ID?: true
    Category?: true
    Type?: true
  }

  export type WsCategoriesCountAggregateInputType = {
    ID?: true
    Category?: true
    Type?: true
    _all?: true
  }

  export type WsCategoriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WsCategories to aggregate.
     */
    where?: WsCategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WsCategories to fetch.
     */
    orderBy?: WsCategoriesOrderByWithRelationInput | WsCategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WsCategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WsCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WsCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WsCategories
    **/
    _count?: true | WsCategoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WsCategoriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WsCategoriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WsCategoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WsCategoriesMaxAggregateInputType
  }

  export type GetWsCategoriesAggregateType<T extends WsCategoriesAggregateArgs> = {
        [P in keyof T & keyof AggregateWsCategories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWsCategories[P]>
      : GetScalarType<T[P], AggregateWsCategories[P]>
  }




  export type WsCategoriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WsCategoriesWhereInput
    orderBy?: WsCategoriesOrderByWithAggregationInput | WsCategoriesOrderByWithAggregationInput[]
    by: WsCategoriesScalarFieldEnum[] | WsCategoriesScalarFieldEnum
    having?: WsCategoriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WsCategoriesCountAggregateInputType | true
    _avg?: WsCategoriesAvgAggregateInputType
    _sum?: WsCategoriesSumAggregateInputType
    _min?: WsCategoriesMinAggregateInputType
    _max?: WsCategoriesMaxAggregateInputType
  }

  export type WsCategoriesGroupByOutputType = {
    ID: number
    Category: string
    Type: string
    _count: WsCategoriesCountAggregateOutputType | null
    _avg: WsCategoriesAvgAggregateOutputType | null
    _sum: WsCategoriesSumAggregateOutputType | null
    _min: WsCategoriesMinAggregateOutputType | null
    _max: WsCategoriesMaxAggregateOutputType | null
  }

  type GetWsCategoriesGroupByPayload<T extends WsCategoriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WsCategoriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WsCategoriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WsCategoriesGroupByOutputType[P]>
            : GetScalarType<T[P], WsCategoriesGroupByOutputType[P]>
        }
      >
    >


  export type WsCategoriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    Category?: boolean
    Type?: boolean
  }, ExtArgs["result"]["wsCategories"]>


  export type WsCategoriesSelectScalar = {
    ID?: boolean
    Category?: boolean
    Type?: boolean
  }


  export type $WsCategoriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WsCategories"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      Category: string
      Type: string
    }, ExtArgs["result"]["wsCategories"]>
    composites: {}
  }

  type WsCategoriesGetPayload<S extends boolean | null | undefined | WsCategoriesDefaultArgs> = $Result.GetResult<Prisma.$WsCategoriesPayload, S>

  type WsCategoriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WsCategoriesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WsCategoriesCountAggregateInputType | true
    }

  export interface WsCategoriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WsCategories'], meta: { name: 'WsCategories' } }
    /**
     * Find zero or one WsCategories that matches the filter.
     * @param {WsCategoriesFindUniqueArgs} args - Arguments to find a WsCategories
     * @example
     * // Get one WsCategories
     * const wsCategories = await prisma.wsCategories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WsCategoriesFindUniqueArgs>(args: SelectSubset<T, WsCategoriesFindUniqueArgs<ExtArgs>>): Prisma__WsCategoriesClient<$Result.GetResult<Prisma.$WsCategoriesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WsCategories that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WsCategoriesFindUniqueOrThrowArgs} args - Arguments to find a WsCategories
     * @example
     * // Get one WsCategories
     * const wsCategories = await prisma.wsCategories.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WsCategoriesFindUniqueOrThrowArgs>(args: SelectSubset<T, WsCategoriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WsCategoriesClient<$Result.GetResult<Prisma.$WsCategoriesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WsCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsCategoriesFindFirstArgs} args - Arguments to find a WsCategories
     * @example
     * // Get one WsCategories
     * const wsCategories = await prisma.wsCategories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WsCategoriesFindFirstArgs>(args?: SelectSubset<T, WsCategoriesFindFirstArgs<ExtArgs>>): Prisma__WsCategoriesClient<$Result.GetResult<Prisma.$WsCategoriesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WsCategories that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsCategoriesFindFirstOrThrowArgs} args - Arguments to find a WsCategories
     * @example
     * // Get one WsCategories
     * const wsCategories = await prisma.wsCategories.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WsCategoriesFindFirstOrThrowArgs>(args?: SelectSubset<T, WsCategoriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__WsCategoriesClient<$Result.GetResult<Prisma.$WsCategoriesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WsCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsCategoriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WsCategories
     * const wsCategories = await prisma.wsCategories.findMany()
     * 
     * // Get first 10 WsCategories
     * const wsCategories = await prisma.wsCategories.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const wsCategoriesWithIDOnly = await prisma.wsCategories.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends WsCategoriesFindManyArgs>(args?: SelectSubset<T, WsCategoriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WsCategoriesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WsCategories.
     * @param {WsCategoriesCreateArgs} args - Arguments to create a WsCategories.
     * @example
     * // Create one WsCategories
     * const WsCategories = await prisma.wsCategories.create({
     *   data: {
     *     // ... data to create a WsCategories
     *   }
     * })
     * 
     */
    create<T extends WsCategoriesCreateArgs>(args: SelectSubset<T, WsCategoriesCreateArgs<ExtArgs>>): Prisma__WsCategoriesClient<$Result.GetResult<Prisma.$WsCategoriesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WsCategories.
     * @param {WsCategoriesCreateManyArgs} args - Arguments to create many WsCategories.
     * @example
     * // Create many WsCategories
     * const wsCategories = await prisma.wsCategories.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WsCategoriesCreateManyArgs>(args?: SelectSubset<T, WsCategoriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WsCategories.
     * @param {WsCategoriesDeleteArgs} args - Arguments to delete one WsCategories.
     * @example
     * // Delete one WsCategories
     * const WsCategories = await prisma.wsCategories.delete({
     *   where: {
     *     // ... filter to delete one WsCategories
     *   }
     * })
     * 
     */
    delete<T extends WsCategoriesDeleteArgs>(args: SelectSubset<T, WsCategoriesDeleteArgs<ExtArgs>>): Prisma__WsCategoriesClient<$Result.GetResult<Prisma.$WsCategoriesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WsCategories.
     * @param {WsCategoriesUpdateArgs} args - Arguments to update one WsCategories.
     * @example
     * // Update one WsCategories
     * const wsCategories = await prisma.wsCategories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WsCategoriesUpdateArgs>(args: SelectSubset<T, WsCategoriesUpdateArgs<ExtArgs>>): Prisma__WsCategoriesClient<$Result.GetResult<Prisma.$WsCategoriesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WsCategories.
     * @param {WsCategoriesDeleteManyArgs} args - Arguments to filter WsCategories to delete.
     * @example
     * // Delete a few WsCategories
     * const { count } = await prisma.wsCategories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WsCategoriesDeleteManyArgs>(args?: SelectSubset<T, WsCategoriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WsCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsCategoriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WsCategories
     * const wsCategories = await prisma.wsCategories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WsCategoriesUpdateManyArgs>(args: SelectSubset<T, WsCategoriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WsCategories.
     * @param {WsCategoriesUpsertArgs} args - Arguments to update or create a WsCategories.
     * @example
     * // Update or create a WsCategories
     * const wsCategories = await prisma.wsCategories.upsert({
     *   create: {
     *     // ... data to create a WsCategories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WsCategories we want to update
     *   }
     * })
     */
    upsert<T extends WsCategoriesUpsertArgs>(args: SelectSubset<T, WsCategoriesUpsertArgs<ExtArgs>>): Prisma__WsCategoriesClient<$Result.GetResult<Prisma.$WsCategoriesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WsCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsCategoriesCountArgs} args - Arguments to filter WsCategories to count.
     * @example
     * // Count the number of WsCategories
     * const count = await prisma.wsCategories.count({
     *   where: {
     *     // ... the filter for the WsCategories we want to count
     *   }
     * })
    **/
    count<T extends WsCategoriesCountArgs>(
      args?: Subset<T, WsCategoriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WsCategoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WsCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsCategoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WsCategoriesAggregateArgs>(args: Subset<T, WsCategoriesAggregateArgs>): Prisma.PrismaPromise<GetWsCategoriesAggregateType<T>>

    /**
     * Group by WsCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsCategoriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WsCategoriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WsCategoriesGroupByArgs['orderBy'] }
        : { orderBy?: WsCategoriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WsCategoriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWsCategoriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WsCategories model
   */
  readonly fields: WsCategoriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WsCategories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WsCategoriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WsCategories model
   */ 
  interface WsCategoriesFieldRefs {
    readonly ID: FieldRef<"WsCategories", 'Int'>
    readonly Category: FieldRef<"WsCategories", 'String'>
    readonly Type: FieldRef<"WsCategories", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WsCategories findUnique
   */
  export type WsCategoriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsCategories
     */
    select?: WsCategoriesSelect<ExtArgs> | null
    /**
     * Filter, which WsCategories to fetch.
     */
    where: WsCategoriesWhereUniqueInput
  }

  /**
   * WsCategories findUniqueOrThrow
   */
  export type WsCategoriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsCategories
     */
    select?: WsCategoriesSelect<ExtArgs> | null
    /**
     * Filter, which WsCategories to fetch.
     */
    where: WsCategoriesWhereUniqueInput
  }

  /**
   * WsCategories findFirst
   */
  export type WsCategoriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsCategories
     */
    select?: WsCategoriesSelect<ExtArgs> | null
    /**
     * Filter, which WsCategories to fetch.
     */
    where?: WsCategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WsCategories to fetch.
     */
    orderBy?: WsCategoriesOrderByWithRelationInput | WsCategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WsCategories.
     */
    cursor?: WsCategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WsCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WsCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WsCategories.
     */
    distinct?: WsCategoriesScalarFieldEnum | WsCategoriesScalarFieldEnum[]
  }

  /**
   * WsCategories findFirstOrThrow
   */
  export type WsCategoriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsCategories
     */
    select?: WsCategoriesSelect<ExtArgs> | null
    /**
     * Filter, which WsCategories to fetch.
     */
    where?: WsCategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WsCategories to fetch.
     */
    orderBy?: WsCategoriesOrderByWithRelationInput | WsCategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WsCategories.
     */
    cursor?: WsCategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WsCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WsCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WsCategories.
     */
    distinct?: WsCategoriesScalarFieldEnum | WsCategoriesScalarFieldEnum[]
  }

  /**
   * WsCategories findMany
   */
  export type WsCategoriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsCategories
     */
    select?: WsCategoriesSelect<ExtArgs> | null
    /**
     * Filter, which WsCategories to fetch.
     */
    where?: WsCategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WsCategories to fetch.
     */
    orderBy?: WsCategoriesOrderByWithRelationInput | WsCategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WsCategories.
     */
    cursor?: WsCategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WsCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WsCategories.
     */
    skip?: number
    distinct?: WsCategoriesScalarFieldEnum | WsCategoriesScalarFieldEnum[]
  }

  /**
   * WsCategories create
   */
  export type WsCategoriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsCategories
     */
    select?: WsCategoriesSelect<ExtArgs> | null
    /**
     * The data needed to create a WsCategories.
     */
    data: XOR<WsCategoriesCreateInput, WsCategoriesUncheckedCreateInput>
  }

  /**
   * WsCategories createMany
   */
  export type WsCategoriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WsCategories.
     */
    data: WsCategoriesCreateManyInput | WsCategoriesCreateManyInput[]
  }

  /**
   * WsCategories update
   */
  export type WsCategoriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsCategories
     */
    select?: WsCategoriesSelect<ExtArgs> | null
    /**
     * The data needed to update a WsCategories.
     */
    data: XOR<WsCategoriesUpdateInput, WsCategoriesUncheckedUpdateInput>
    /**
     * Choose, which WsCategories to update.
     */
    where: WsCategoriesWhereUniqueInput
  }

  /**
   * WsCategories updateMany
   */
  export type WsCategoriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WsCategories.
     */
    data: XOR<WsCategoriesUpdateManyMutationInput, WsCategoriesUncheckedUpdateManyInput>
    /**
     * Filter which WsCategories to update
     */
    where?: WsCategoriesWhereInput
  }

  /**
   * WsCategories upsert
   */
  export type WsCategoriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsCategories
     */
    select?: WsCategoriesSelect<ExtArgs> | null
    /**
     * The filter to search for the WsCategories to update in case it exists.
     */
    where: WsCategoriesWhereUniqueInput
    /**
     * In case the WsCategories found by the `where` argument doesn't exist, create a new WsCategories with this data.
     */
    create: XOR<WsCategoriesCreateInput, WsCategoriesUncheckedCreateInput>
    /**
     * In case the WsCategories was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WsCategoriesUpdateInput, WsCategoriesUncheckedUpdateInput>
  }

  /**
   * WsCategories delete
   */
  export type WsCategoriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsCategories
     */
    select?: WsCategoriesSelect<ExtArgs> | null
    /**
     * Filter which WsCategories to delete.
     */
    where: WsCategoriesWhereUniqueInput
  }

  /**
   * WsCategories deleteMany
   */
  export type WsCategoriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WsCategories to delete
     */
    where?: WsCategoriesWhereInput
  }

  /**
   * WsCategories without action
   */
  export type WsCategoriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsCategories
     */
    select?: WsCategoriesSelect<ExtArgs> | null
  }


  /**
   * Model WsDepartments
   */

  export type AggregateWsDepartments = {
    _count: WsDepartmentsCountAggregateOutputType | null
    _avg: WsDepartmentsAvgAggregateOutputType | null
    _sum: WsDepartmentsSumAggregateOutputType | null
    _min: WsDepartmentsMinAggregateOutputType | null
    _max: WsDepartmentsMaxAggregateOutputType | null
  }

  export type WsDepartmentsAvgAggregateOutputType = {
    order: number | null
  }

  export type WsDepartmentsSumAggregateOutputType = {
    order: number | null
  }

  export type WsDepartmentsMinAggregateOutputType = {
    dep: string | null
    alias: string | null
    order: number | null
    app_bar: boolean | null
    banner_url: string | null
    created_on: Date | null
    created_by: string | null
  }

  export type WsDepartmentsMaxAggregateOutputType = {
    dep: string | null
    alias: string | null
    order: number | null
    app_bar: boolean | null
    banner_url: string | null
    created_on: Date | null
    created_by: string | null
  }

  export type WsDepartmentsCountAggregateOutputType = {
    dep: number
    alias: number
    order: number
    app_bar: number
    banner_url: number
    created_on: number
    created_by: number
    _all: number
  }


  export type WsDepartmentsAvgAggregateInputType = {
    order?: true
  }

  export type WsDepartmentsSumAggregateInputType = {
    order?: true
  }

  export type WsDepartmentsMinAggregateInputType = {
    dep?: true
    alias?: true
    order?: true
    app_bar?: true
    banner_url?: true
    created_on?: true
    created_by?: true
  }

  export type WsDepartmentsMaxAggregateInputType = {
    dep?: true
    alias?: true
    order?: true
    app_bar?: true
    banner_url?: true
    created_on?: true
    created_by?: true
  }

  export type WsDepartmentsCountAggregateInputType = {
    dep?: true
    alias?: true
    order?: true
    app_bar?: true
    banner_url?: true
    created_on?: true
    created_by?: true
    _all?: true
  }

  export type WsDepartmentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WsDepartments to aggregate.
     */
    where?: WsDepartmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WsDepartments to fetch.
     */
    orderBy?: WsDepartmentsOrderByWithRelationInput | WsDepartmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WsDepartmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WsDepartments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WsDepartments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WsDepartments
    **/
    _count?: true | WsDepartmentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WsDepartmentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WsDepartmentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WsDepartmentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WsDepartmentsMaxAggregateInputType
  }

  export type GetWsDepartmentsAggregateType<T extends WsDepartmentsAggregateArgs> = {
        [P in keyof T & keyof AggregateWsDepartments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWsDepartments[P]>
      : GetScalarType<T[P], AggregateWsDepartments[P]>
  }




  export type WsDepartmentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WsDepartmentsWhereInput
    orderBy?: WsDepartmentsOrderByWithAggregationInput | WsDepartmentsOrderByWithAggregationInput[]
    by: WsDepartmentsScalarFieldEnum[] | WsDepartmentsScalarFieldEnum
    having?: WsDepartmentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WsDepartmentsCountAggregateInputType | true
    _avg?: WsDepartmentsAvgAggregateInputType
    _sum?: WsDepartmentsSumAggregateInputType
    _min?: WsDepartmentsMinAggregateInputType
    _max?: WsDepartmentsMaxAggregateInputType
  }

  export type WsDepartmentsGroupByOutputType = {
    dep: string
    alias: string | null
    order: number | null
    app_bar: boolean | null
    banner_url: string | null
    created_on: Date | null
    created_by: string | null
    _count: WsDepartmentsCountAggregateOutputType | null
    _avg: WsDepartmentsAvgAggregateOutputType | null
    _sum: WsDepartmentsSumAggregateOutputType | null
    _min: WsDepartmentsMinAggregateOutputType | null
    _max: WsDepartmentsMaxAggregateOutputType | null
  }

  type GetWsDepartmentsGroupByPayload<T extends WsDepartmentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WsDepartmentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WsDepartmentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WsDepartmentsGroupByOutputType[P]>
            : GetScalarType<T[P], WsDepartmentsGroupByOutputType[P]>
        }
      >
    >


  export type WsDepartmentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    dep?: boolean
    alias?: boolean
    order?: boolean
    app_bar?: boolean
    banner_url?: boolean
    created_on?: boolean
    created_by?: boolean
    WsProducts?: boolean | WsDepartments$WsProductsArgs<ExtArgs>
    _count?: boolean | WsDepartmentsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wsDepartments"]>


  export type WsDepartmentsSelectScalar = {
    dep?: boolean
    alias?: boolean
    order?: boolean
    app_bar?: boolean
    banner_url?: boolean
    created_on?: boolean
    created_by?: boolean
  }

  export type WsDepartmentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    WsProducts?: boolean | WsDepartments$WsProductsArgs<ExtArgs>
    _count?: boolean | WsDepartmentsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $WsDepartmentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WsDepartments"
    objects: {
      WsProducts: Prisma.$WsProductsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      dep: string
      alias: string | null
      order: number | null
      app_bar: boolean | null
      banner_url: string | null
      created_on: Date | null
      created_by: string | null
    }, ExtArgs["result"]["wsDepartments"]>
    composites: {}
  }

  type WsDepartmentsGetPayload<S extends boolean | null | undefined | WsDepartmentsDefaultArgs> = $Result.GetResult<Prisma.$WsDepartmentsPayload, S>

  type WsDepartmentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WsDepartmentsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WsDepartmentsCountAggregateInputType | true
    }

  export interface WsDepartmentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WsDepartments'], meta: { name: 'WsDepartments' } }
    /**
     * Find zero or one WsDepartments that matches the filter.
     * @param {WsDepartmentsFindUniqueArgs} args - Arguments to find a WsDepartments
     * @example
     * // Get one WsDepartments
     * const wsDepartments = await prisma.wsDepartments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WsDepartmentsFindUniqueArgs>(args: SelectSubset<T, WsDepartmentsFindUniqueArgs<ExtArgs>>): Prisma__WsDepartmentsClient<$Result.GetResult<Prisma.$WsDepartmentsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WsDepartments that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WsDepartmentsFindUniqueOrThrowArgs} args - Arguments to find a WsDepartments
     * @example
     * // Get one WsDepartments
     * const wsDepartments = await prisma.wsDepartments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WsDepartmentsFindUniqueOrThrowArgs>(args: SelectSubset<T, WsDepartmentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WsDepartmentsClient<$Result.GetResult<Prisma.$WsDepartmentsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WsDepartments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsDepartmentsFindFirstArgs} args - Arguments to find a WsDepartments
     * @example
     * // Get one WsDepartments
     * const wsDepartments = await prisma.wsDepartments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WsDepartmentsFindFirstArgs>(args?: SelectSubset<T, WsDepartmentsFindFirstArgs<ExtArgs>>): Prisma__WsDepartmentsClient<$Result.GetResult<Prisma.$WsDepartmentsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WsDepartments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsDepartmentsFindFirstOrThrowArgs} args - Arguments to find a WsDepartments
     * @example
     * // Get one WsDepartments
     * const wsDepartments = await prisma.wsDepartments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WsDepartmentsFindFirstOrThrowArgs>(args?: SelectSubset<T, WsDepartmentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__WsDepartmentsClient<$Result.GetResult<Prisma.$WsDepartmentsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WsDepartments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsDepartmentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WsDepartments
     * const wsDepartments = await prisma.wsDepartments.findMany()
     * 
     * // Get first 10 WsDepartments
     * const wsDepartments = await prisma.wsDepartments.findMany({ take: 10 })
     * 
     * // Only select the `dep`
     * const wsDepartmentsWithDepOnly = await prisma.wsDepartments.findMany({ select: { dep: true } })
     * 
     */
    findMany<T extends WsDepartmentsFindManyArgs>(args?: SelectSubset<T, WsDepartmentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WsDepartmentsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WsDepartments.
     * @param {WsDepartmentsCreateArgs} args - Arguments to create a WsDepartments.
     * @example
     * // Create one WsDepartments
     * const WsDepartments = await prisma.wsDepartments.create({
     *   data: {
     *     // ... data to create a WsDepartments
     *   }
     * })
     * 
     */
    create<T extends WsDepartmentsCreateArgs>(args: SelectSubset<T, WsDepartmentsCreateArgs<ExtArgs>>): Prisma__WsDepartmentsClient<$Result.GetResult<Prisma.$WsDepartmentsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WsDepartments.
     * @param {WsDepartmentsCreateManyArgs} args - Arguments to create many WsDepartments.
     * @example
     * // Create many WsDepartments
     * const wsDepartments = await prisma.wsDepartments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WsDepartmentsCreateManyArgs>(args?: SelectSubset<T, WsDepartmentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WsDepartments.
     * @param {WsDepartmentsDeleteArgs} args - Arguments to delete one WsDepartments.
     * @example
     * // Delete one WsDepartments
     * const WsDepartments = await prisma.wsDepartments.delete({
     *   where: {
     *     // ... filter to delete one WsDepartments
     *   }
     * })
     * 
     */
    delete<T extends WsDepartmentsDeleteArgs>(args: SelectSubset<T, WsDepartmentsDeleteArgs<ExtArgs>>): Prisma__WsDepartmentsClient<$Result.GetResult<Prisma.$WsDepartmentsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WsDepartments.
     * @param {WsDepartmentsUpdateArgs} args - Arguments to update one WsDepartments.
     * @example
     * // Update one WsDepartments
     * const wsDepartments = await prisma.wsDepartments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WsDepartmentsUpdateArgs>(args: SelectSubset<T, WsDepartmentsUpdateArgs<ExtArgs>>): Prisma__WsDepartmentsClient<$Result.GetResult<Prisma.$WsDepartmentsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WsDepartments.
     * @param {WsDepartmentsDeleteManyArgs} args - Arguments to filter WsDepartments to delete.
     * @example
     * // Delete a few WsDepartments
     * const { count } = await prisma.wsDepartments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WsDepartmentsDeleteManyArgs>(args?: SelectSubset<T, WsDepartmentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WsDepartments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsDepartmentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WsDepartments
     * const wsDepartments = await prisma.wsDepartments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WsDepartmentsUpdateManyArgs>(args: SelectSubset<T, WsDepartmentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WsDepartments.
     * @param {WsDepartmentsUpsertArgs} args - Arguments to update or create a WsDepartments.
     * @example
     * // Update or create a WsDepartments
     * const wsDepartments = await prisma.wsDepartments.upsert({
     *   create: {
     *     // ... data to create a WsDepartments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WsDepartments we want to update
     *   }
     * })
     */
    upsert<T extends WsDepartmentsUpsertArgs>(args: SelectSubset<T, WsDepartmentsUpsertArgs<ExtArgs>>): Prisma__WsDepartmentsClient<$Result.GetResult<Prisma.$WsDepartmentsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WsDepartments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsDepartmentsCountArgs} args - Arguments to filter WsDepartments to count.
     * @example
     * // Count the number of WsDepartments
     * const count = await prisma.wsDepartments.count({
     *   where: {
     *     // ... the filter for the WsDepartments we want to count
     *   }
     * })
    **/
    count<T extends WsDepartmentsCountArgs>(
      args?: Subset<T, WsDepartmentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WsDepartmentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WsDepartments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsDepartmentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WsDepartmentsAggregateArgs>(args: Subset<T, WsDepartmentsAggregateArgs>): Prisma.PrismaPromise<GetWsDepartmentsAggregateType<T>>

    /**
     * Group by WsDepartments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsDepartmentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WsDepartmentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WsDepartmentsGroupByArgs['orderBy'] }
        : { orderBy?: WsDepartmentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WsDepartmentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWsDepartmentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WsDepartments model
   */
  readonly fields: WsDepartmentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WsDepartments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WsDepartmentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    WsProducts<T extends WsDepartments$WsProductsArgs<ExtArgs> = {}>(args?: Subset<T, WsDepartments$WsProductsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WsProductsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WsDepartments model
   */ 
  interface WsDepartmentsFieldRefs {
    readonly dep: FieldRef<"WsDepartments", 'String'>
    readonly alias: FieldRef<"WsDepartments", 'String'>
    readonly order: FieldRef<"WsDepartments", 'Int'>
    readonly app_bar: FieldRef<"WsDepartments", 'Boolean'>
    readonly banner_url: FieldRef<"WsDepartments", 'String'>
    readonly created_on: FieldRef<"WsDepartments", 'DateTime'>
    readonly created_by: FieldRef<"WsDepartments", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WsDepartments findUnique
   */
  export type WsDepartmentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsDepartments
     */
    select?: WsDepartmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WsDepartmentsInclude<ExtArgs> | null
    /**
     * Filter, which WsDepartments to fetch.
     */
    where: WsDepartmentsWhereUniqueInput
  }

  /**
   * WsDepartments findUniqueOrThrow
   */
  export type WsDepartmentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsDepartments
     */
    select?: WsDepartmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WsDepartmentsInclude<ExtArgs> | null
    /**
     * Filter, which WsDepartments to fetch.
     */
    where: WsDepartmentsWhereUniqueInput
  }

  /**
   * WsDepartments findFirst
   */
  export type WsDepartmentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsDepartments
     */
    select?: WsDepartmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WsDepartmentsInclude<ExtArgs> | null
    /**
     * Filter, which WsDepartments to fetch.
     */
    where?: WsDepartmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WsDepartments to fetch.
     */
    orderBy?: WsDepartmentsOrderByWithRelationInput | WsDepartmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WsDepartments.
     */
    cursor?: WsDepartmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WsDepartments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WsDepartments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WsDepartments.
     */
    distinct?: WsDepartmentsScalarFieldEnum | WsDepartmentsScalarFieldEnum[]
  }

  /**
   * WsDepartments findFirstOrThrow
   */
  export type WsDepartmentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsDepartments
     */
    select?: WsDepartmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WsDepartmentsInclude<ExtArgs> | null
    /**
     * Filter, which WsDepartments to fetch.
     */
    where?: WsDepartmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WsDepartments to fetch.
     */
    orderBy?: WsDepartmentsOrderByWithRelationInput | WsDepartmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WsDepartments.
     */
    cursor?: WsDepartmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WsDepartments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WsDepartments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WsDepartments.
     */
    distinct?: WsDepartmentsScalarFieldEnum | WsDepartmentsScalarFieldEnum[]
  }

  /**
   * WsDepartments findMany
   */
  export type WsDepartmentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsDepartments
     */
    select?: WsDepartmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WsDepartmentsInclude<ExtArgs> | null
    /**
     * Filter, which WsDepartments to fetch.
     */
    where?: WsDepartmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WsDepartments to fetch.
     */
    orderBy?: WsDepartmentsOrderByWithRelationInput | WsDepartmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WsDepartments.
     */
    cursor?: WsDepartmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WsDepartments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WsDepartments.
     */
    skip?: number
    distinct?: WsDepartmentsScalarFieldEnum | WsDepartmentsScalarFieldEnum[]
  }

  /**
   * WsDepartments create
   */
  export type WsDepartmentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsDepartments
     */
    select?: WsDepartmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WsDepartmentsInclude<ExtArgs> | null
    /**
     * The data needed to create a WsDepartments.
     */
    data: XOR<WsDepartmentsCreateInput, WsDepartmentsUncheckedCreateInput>
  }

  /**
   * WsDepartments createMany
   */
  export type WsDepartmentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WsDepartments.
     */
    data: WsDepartmentsCreateManyInput | WsDepartmentsCreateManyInput[]
  }

  /**
   * WsDepartments update
   */
  export type WsDepartmentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsDepartments
     */
    select?: WsDepartmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WsDepartmentsInclude<ExtArgs> | null
    /**
     * The data needed to update a WsDepartments.
     */
    data: XOR<WsDepartmentsUpdateInput, WsDepartmentsUncheckedUpdateInput>
    /**
     * Choose, which WsDepartments to update.
     */
    where: WsDepartmentsWhereUniqueInput
  }

  /**
   * WsDepartments updateMany
   */
  export type WsDepartmentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WsDepartments.
     */
    data: XOR<WsDepartmentsUpdateManyMutationInput, WsDepartmentsUncheckedUpdateManyInput>
    /**
     * Filter which WsDepartments to update
     */
    where?: WsDepartmentsWhereInput
  }

  /**
   * WsDepartments upsert
   */
  export type WsDepartmentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsDepartments
     */
    select?: WsDepartmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WsDepartmentsInclude<ExtArgs> | null
    /**
     * The filter to search for the WsDepartments to update in case it exists.
     */
    where: WsDepartmentsWhereUniqueInput
    /**
     * In case the WsDepartments found by the `where` argument doesn't exist, create a new WsDepartments with this data.
     */
    create: XOR<WsDepartmentsCreateInput, WsDepartmentsUncheckedCreateInput>
    /**
     * In case the WsDepartments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WsDepartmentsUpdateInput, WsDepartmentsUncheckedUpdateInput>
  }

  /**
   * WsDepartments delete
   */
  export type WsDepartmentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsDepartments
     */
    select?: WsDepartmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WsDepartmentsInclude<ExtArgs> | null
    /**
     * Filter which WsDepartments to delete.
     */
    where: WsDepartmentsWhereUniqueInput
  }

  /**
   * WsDepartments deleteMany
   */
  export type WsDepartmentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WsDepartments to delete
     */
    where?: WsDepartmentsWhereInput
  }

  /**
   * WsDepartments.WsProducts
   */
  export type WsDepartments$WsProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsProducts
     */
    select?: WsProductsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WsProductsInclude<ExtArgs> | null
    where?: WsProductsWhereInput
    orderBy?: WsProductsOrderByWithRelationInput | WsProductsOrderByWithRelationInput[]
    cursor?: WsProductsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WsProductsScalarFieldEnum | WsProductsScalarFieldEnum[]
  }

  /**
   * WsDepartments without action
   */
  export type WsDepartmentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsDepartments
     */
    select?: WsDepartmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WsDepartmentsInclude<ExtArgs> | null
  }


  /**
   * Model WsHomeBanners
   */

  export type AggregateWsHomeBanners = {
    _count: WsHomeBannersCountAggregateOutputType | null
    _avg: WsHomeBannersAvgAggregateOutputType | null
    _sum: WsHomeBannersSumAggregateOutputType | null
    _min: WsHomeBannersMinAggregateOutputType | null
    _max: WsHomeBannersMaxAggregateOutputType | null
  }

  export type WsHomeBannersAvgAggregateOutputType = {
    ID: number | null
  }

  export type WsHomeBannersSumAggregateOutputType = {
    ID: number | null
  }

  export type WsHomeBannersMinAggregateOutputType = {
    ID: number | null
    dep: string | null
    image_url: string | null
  }

  export type WsHomeBannersMaxAggregateOutputType = {
    ID: number | null
    dep: string | null
    image_url: string | null
  }

  export type WsHomeBannersCountAggregateOutputType = {
    ID: number
    dep: number
    image_url: number
    _all: number
  }


  export type WsHomeBannersAvgAggregateInputType = {
    ID?: true
  }

  export type WsHomeBannersSumAggregateInputType = {
    ID?: true
  }

  export type WsHomeBannersMinAggregateInputType = {
    ID?: true
    dep?: true
    image_url?: true
  }

  export type WsHomeBannersMaxAggregateInputType = {
    ID?: true
    dep?: true
    image_url?: true
  }

  export type WsHomeBannersCountAggregateInputType = {
    ID?: true
    dep?: true
    image_url?: true
    _all?: true
  }

  export type WsHomeBannersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WsHomeBanners to aggregate.
     */
    where?: WsHomeBannersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WsHomeBanners to fetch.
     */
    orderBy?: WsHomeBannersOrderByWithRelationInput | WsHomeBannersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WsHomeBannersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WsHomeBanners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WsHomeBanners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WsHomeBanners
    **/
    _count?: true | WsHomeBannersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WsHomeBannersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WsHomeBannersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WsHomeBannersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WsHomeBannersMaxAggregateInputType
  }

  export type GetWsHomeBannersAggregateType<T extends WsHomeBannersAggregateArgs> = {
        [P in keyof T & keyof AggregateWsHomeBanners]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWsHomeBanners[P]>
      : GetScalarType<T[P], AggregateWsHomeBanners[P]>
  }




  export type WsHomeBannersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WsHomeBannersWhereInput
    orderBy?: WsHomeBannersOrderByWithAggregationInput | WsHomeBannersOrderByWithAggregationInput[]
    by: WsHomeBannersScalarFieldEnum[] | WsHomeBannersScalarFieldEnum
    having?: WsHomeBannersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WsHomeBannersCountAggregateInputType | true
    _avg?: WsHomeBannersAvgAggregateInputType
    _sum?: WsHomeBannersSumAggregateInputType
    _min?: WsHomeBannersMinAggregateInputType
    _max?: WsHomeBannersMaxAggregateInputType
  }

  export type WsHomeBannersGroupByOutputType = {
    ID: number
    dep: string
    image_url: string
    _count: WsHomeBannersCountAggregateOutputType | null
    _avg: WsHomeBannersAvgAggregateOutputType | null
    _sum: WsHomeBannersSumAggregateOutputType | null
    _min: WsHomeBannersMinAggregateOutputType | null
    _max: WsHomeBannersMaxAggregateOutputType | null
  }

  type GetWsHomeBannersGroupByPayload<T extends WsHomeBannersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WsHomeBannersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WsHomeBannersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WsHomeBannersGroupByOutputType[P]>
            : GetScalarType<T[P], WsHomeBannersGroupByOutputType[P]>
        }
      >
    >


  export type WsHomeBannersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    dep?: boolean
    image_url?: boolean
  }, ExtArgs["result"]["wsHomeBanners"]>


  export type WsHomeBannersSelectScalar = {
    ID?: boolean
    dep?: boolean
    image_url?: boolean
  }


  export type $WsHomeBannersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WsHomeBanners"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      dep: string
      image_url: string
    }, ExtArgs["result"]["wsHomeBanners"]>
    composites: {}
  }

  type WsHomeBannersGetPayload<S extends boolean | null | undefined | WsHomeBannersDefaultArgs> = $Result.GetResult<Prisma.$WsHomeBannersPayload, S>

  type WsHomeBannersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WsHomeBannersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WsHomeBannersCountAggregateInputType | true
    }

  export interface WsHomeBannersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WsHomeBanners'], meta: { name: 'WsHomeBanners' } }
    /**
     * Find zero or one WsHomeBanners that matches the filter.
     * @param {WsHomeBannersFindUniqueArgs} args - Arguments to find a WsHomeBanners
     * @example
     * // Get one WsHomeBanners
     * const wsHomeBanners = await prisma.wsHomeBanners.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WsHomeBannersFindUniqueArgs>(args: SelectSubset<T, WsHomeBannersFindUniqueArgs<ExtArgs>>): Prisma__WsHomeBannersClient<$Result.GetResult<Prisma.$WsHomeBannersPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WsHomeBanners that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WsHomeBannersFindUniqueOrThrowArgs} args - Arguments to find a WsHomeBanners
     * @example
     * // Get one WsHomeBanners
     * const wsHomeBanners = await prisma.wsHomeBanners.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WsHomeBannersFindUniqueOrThrowArgs>(args: SelectSubset<T, WsHomeBannersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WsHomeBannersClient<$Result.GetResult<Prisma.$WsHomeBannersPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WsHomeBanners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsHomeBannersFindFirstArgs} args - Arguments to find a WsHomeBanners
     * @example
     * // Get one WsHomeBanners
     * const wsHomeBanners = await prisma.wsHomeBanners.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WsHomeBannersFindFirstArgs>(args?: SelectSubset<T, WsHomeBannersFindFirstArgs<ExtArgs>>): Prisma__WsHomeBannersClient<$Result.GetResult<Prisma.$WsHomeBannersPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WsHomeBanners that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsHomeBannersFindFirstOrThrowArgs} args - Arguments to find a WsHomeBanners
     * @example
     * // Get one WsHomeBanners
     * const wsHomeBanners = await prisma.wsHomeBanners.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WsHomeBannersFindFirstOrThrowArgs>(args?: SelectSubset<T, WsHomeBannersFindFirstOrThrowArgs<ExtArgs>>): Prisma__WsHomeBannersClient<$Result.GetResult<Prisma.$WsHomeBannersPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WsHomeBanners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsHomeBannersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WsHomeBanners
     * const wsHomeBanners = await prisma.wsHomeBanners.findMany()
     * 
     * // Get first 10 WsHomeBanners
     * const wsHomeBanners = await prisma.wsHomeBanners.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const wsHomeBannersWithIDOnly = await prisma.wsHomeBanners.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends WsHomeBannersFindManyArgs>(args?: SelectSubset<T, WsHomeBannersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WsHomeBannersPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WsHomeBanners.
     * @param {WsHomeBannersCreateArgs} args - Arguments to create a WsHomeBanners.
     * @example
     * // Create one WsHomeBanners
     * const WsHomeBanners = await prisma.wsHomeBanners.create({
     *   data: {
     *     // ... data to create a WsHomeBanners
     *   }
     * })
     * 
     */
    create<T extends WsHomeBannersCreateArgs>(args: SelectSubset<T, WsHomeBannersCreateArgs<ExtArgs>>): Prisma__WsHomeBannersClient<$Result.GetResult<Prisma.$WsHomeBannersPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WsHomeBanners.
     * @param {WsHomeBannersCreateManyArgs} args - Arguments to create many WsHomeBanners.
     * @example
     * // Create many WsHomeBanners
     * const wsHomeBanners = await prisma.wsHomeBanners.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WsHomeBannersCreateManyArgs>(args?: SelectSubset<T, WsHomeBannersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WsHomeBanners.
     * @param {WsHomeBannersDeleteArgs} args - Arguments to delete one WsHomeBanners.
     * @example
     * // Delete one WsHomeBanners
     * const WsHomeBanners = await prisma.wsHomeBanners.delete({
     *   where: {
     *     // ... filter to delete one WsHomeBanners
     *   }
     * })
     * 
     */
    delete<T extends WsHomeBannersDeleteArgs>(args: SelectSubset<T, WsHomeBannersDeleteArgs<ExtArgs>>): Prisma__WsHomeBannersClient<$Result.GetResult<Prisma.$WsHomeBannersPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WsHomeBanners.
     * @param {WsHomeBannersUpdateArgs} args - Arguments to update one WsHomeBanners.
     * @example
     * // Update one WsHomeBanners
     * const wsHomeBanners = await prisma.wsHomeBanners.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WsHomeBannersUpdateArgs>(args: SelectSubset<T, WsHomeBannersUpdateArgs<ExtArgs>>): Prisma__WsHomeBannersClient<$Result.GetResult<Prisma.$WsHomeBannersPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WsHomeBanners.
     * @param {WsHomeBannersDeleteManyArgs} args - Arguments to filter WsHomeBanners to delete.
     * @example
     * // Delete a few WsHomeBanners
     * const { count } = await prisma.wsHomeBanners.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WsHomeBannersDeleteManyArgs>(args?: SelectSubset<T, WsHomeBannersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WsHomeBanners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsHomeBannersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WsHomeBanners
     * const wsHomeBanners = await prisma.wsHomeBanners.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WsHomeBannersUpdateManyArgs>(args: SelectSubset<T, WsHomeBannersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WsHomeBanners.
     * @param {WsHomeBannersUpsertArgs} args - Arguments to update or create a WsHomeBanners.
     * @example
     * // Update or create a WsHomeBanners
     * const wsHomeBanners = await prisma.wsHomeBanners.upsert({
     *   create: {
     *     // ... data to create a WsHomeBanners
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WsHomeBanners we want to update
     *   }
     * })
     */
    upsert<T extends WsHomeBannersUpsertArgs>(args: SelectSubset<T, WsHomeBannersUpsertArgs<ExtArgs>>): Prisma__WsHomeBannersClient<$Result.GetResult<Prisma.$WsHomeBannersPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WsHomeBanners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsHomeBannersCountArgs} args - Arguments to filter WsHomeBanners to count.
     * @example
     * // Count the number of WsHomeBanners
     * const count = await prisma.wsHomeBanners.count({
     *   where: {
     *     // ... the filter for the WsHomeBanners we want to count
     *   }
     * })
    **/
    count<T extends WsHomeBannersCountArgs>(
      args?: Subset<T, WsHomeBannersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WsHomeBannersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WsHomeBanners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsHomeBannersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WsHomeBannersAggregateArgs>(args: Subset<T, WsHomeBannersAggregateArgs>): Prisma.PrismaPromise<GetWsHomeBannersAggregateType<T>>

    /**
     * Group by WsHomeBanners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsHomeBannersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WsHomeBannersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WsHomeBannersGroupByArgs['orderBy'] }
        : { orderBy?: WsHomeBannersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WsHomeBannersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWsHomeBannersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WsHomeBanners model
   */
  readonly fields: WsHomeBannersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WsHomeBanners.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WsHomeBannersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WsHomeBanners model
   */ 
  interface WsHomeBannersFieldRefs {
    readonly ID: FieldRef<"WsHomeBanners", 'Int'>
    readonly dep: FieldRef<"WsHomeBanners", 'String'>
    readonly image_url: FieldRef<"WsHomeBanners", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WsHomeBanners findUnique
   */
  export type WsHomeBannersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsHomeBanners
     */
    select?: WsHomeBannersSelect<ExtArgs> | null
    /**
     * Filter, which WsHomeBanners to fetch.
     */
    where: WsHomeBannersWhereUniqueInput
  }

  /**
   * WsHomeBanners findUniqueOrThrow
   */
  export type WsHomeBannersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsHomeBanners
     */
    select?: WsHomeBannersSelect<ExtArgs> | null
    /**
     * Filter, which WsHomeBanners to fetch.
     */
    where: WsHomeBannersWhereUniqueInput
  }

  /**
   * WsHomeBanners findFirst
   */
  export type WsHomeBannersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsHomeBanners
     */
    select?: WsHomeBannersSelect<ExtArgs> | null
    /**
     * Filter, which WsHomeBanners to fetch.
     */
    where?: WsHomeBannersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WsHomeBanners to fetch.
     */
    orderBy?: WsHomeBannersOrderByWithRelationInput | WsHomeBannersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WsHomeBanners.
     */
    cursor?: WsHomeBannersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WsHomeBanners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WsHomeBanners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WsHomeBanners.
     */
    distinct?: WsHomeBannersScalarFieldEnum | WsHomeBannersScalarFieldEnum[]
  }

  /**
   * WsHomeBanners findFirstOrThrow
   */
  export type WsHomeBannersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsHomeBanners
     */
    select?: WsHomeBannersSelect<ExtArgs> | null
    /**
     * Filter, which WsHomeBanners to fetch.
     */
    where?: WsHomeBannersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WsHomeBanners to fetch.
     */
    orderBy?: WsHomeBannersOrderByWithRelationInput | WsHomeBannersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WsHomeBanners.
     */
    cursor?: WsHomeBannersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WsHomeBanners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WsHomeBanners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WsHomeBanners.
     */
    distinct?: WsHomeBannersScalarFieldEnum | WsHomeBannersScalarFieldEnum[]
  }

  /**
   * WsHomeBanners findMany
   */
  export type WsHomeBannersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsHomeBanners
     */
    select?: WsHomeBannersSelect<ExtArgs> | null
    /**
     * Filter, which WsHomeBanners to fetch.
     */
    where?: WsHomeBannersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WsHomeBanners to fetch.
     */
    orderBy?: WsHomeBannersOrderByWithRelationInput | WsHomeBannersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WsHomeBanners.
     */
    cursor?: WsHomeBannersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WsHomeBanners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WsHomeBanners.
     */
    skip?: number
    distinct?: WsHomeBannersScalarFieldEnum | WsHomeBannersScalarFieldEnum[]
  }

  /**
   * WsHomeBanners create
   */
  export type WsHomeBannersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsHomeBanners
     */
    select?: WsHomeBannersSelect<ExtArgs> | null
    /**
     * The data needed to create a WsHomeBanners.
     */
    data: XOR<WsHomeBannersCreateInput, WsHomeBannersUncheckedCreateInput>
  }

  /**
   * WsHomeBanners createMany
   */
  export type WsHomeBannersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WsHomeBanners.
     */
    data: WsHomeBannersCreateManyInput | WsHomeBannersCreateManyInput[]
  }

  /**
   * WsHomeBanners update
   */
  export type WsHomeBannersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsHomeBanners
     */
    select?: WsHomeBannersSelect<ExtArgs> | null
    /**
     * The data needed to update a WsHomeBanners.
     */
    data: XOR<WsHomeBannersUpdateInput, WsHomeBannersUncheckedUpdateInput>
    /**
     * Choose, which WsHomeBanners to update.
     */
    where: WsHomeBannersWhereUniqueInput
  }

  /**
   * WsHomeBanners updateMany
   */
  export type WsHomeBannersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WsHomeBanners.
     */
    data: XOR<WsHomeBannersUpdateManyMutationInput, WsHomeBannersUncheckedUpdateManyInput>
    /**
     * Filter which WsHomeBanners to update
     */
    where?: WsHomeBannersWhereInput
  }

  /**
   * WsHomeBanners upsert
   */
  export type WsHomeBannersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsHomeBanners
     */
    select?: WsHomeBannersSelect<ExtArgs> | null
    /**
     * The filter to search for the WsHomeBanners to update in case it exists.
     */
    where: WsHomeBannersWhereUniqueInput
    /**
     * In case the WsHomeBanners found by the `where` argument doesn't exist, create a new WsHomeBanners with this data.
     */
    create: XOR<WsHomeBannersCreateInput, WsHomeBannersUncheckedCreateInput>
    /**
     * In case the WsHomeBanners was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WsHomeBannersUpdateInput, WsHomeBannersUncheckedUpdateInput>
  }

  /**
   * WsHomeBanners delete
   */
  export type WsHomeBannersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsHomeBanners
     */
    select?: WsHomeBannersSelect<ExtArgs> | null
    /**
     * Filter which WsHomeBanners to delete.
     */
    where: WsHomeBannersWhereUniqueInput
  }

  /**
   * WsHomeBanners deleteMany
   */
  export type WsHomeBannersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WsHomeBanners to delete
     */
    where?: WsHomeBannersWhereInput
  }

  /**
   * WsHomeBanners without action
   */
  export type WsHomeBannersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsHomeBanners
     */
    select?: WsHomeBannersSelect<ExtArgs> | null
  }


  /**
   * Model WsImages
   */

  export type AggregateWsImages = {
    _count: WsImagesCountAggregateOutputType | null
    _avg: WsImagesAvgAggregateOutputType | null
    _sum: WsImagesSumAggregateOutputType | null
    _min: WsImagesMinAggregateOutputType | null
    _max: WsImagesMaxAggregateOutputType | null
  }

  export type WsImagesAvgAggregateOutputType = {
    vendor_id: number | null
  }

  export type WsImagesSumAggregateOutputType = {
    vendor_id: number | null
  }

  export type WsImagesMinAggregateOutputType = {
    vendor_id: number | null
    item_number: string | null
    image_url: string | null
    created_on: Date | null
    created_by: string | null
  }

  export type WsImagesMaxAggregateOutputType = {
    vendor_id: number | null
    item_number: string | null
    image_url: string | null
    created_on: Date | null
    created_by: string | null
  }

  export type WsImagesCountAggregateOutputType = {
    vendor_id: number
    item_number: number
    image_url: number
    created_on: number
    created_by: number
    _all: number
  }


  export type WsImagesAvgAggregateInputType = {
    vendor_id?: true
  }

  export type WsImagesSumAggregateInputType = {
    vendor_id?: true
  }

  export type WsImagesMinAggregateInputType = {
    vendor_id?: true
    item_number?: true
    image_url?: true
    created_on?: true
    created_by?: true
  }

  export type WsImagesMaxAggregateInputType = {
    vendor_id?: true
    item_number?: true
    image_url?: true
    created_on?: true
    created_by?: true
  }

  export type WsImagesCountAggregateInputType = {
    vendor_id?: true
    item_number?: true
    image_url?: true
    created_on?: true
    created_by?: true
    _all?: true
  }

  export type WsImagesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WsImages to aggregate.
     */
    where?: WsImagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WsImages to fetch.
     */
    orderBy?: WsImagesOrderByWithRelationInput | WsImagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WsImagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WsImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WsImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WsImages
    **/
    _count?: true | WsImagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WsImagesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WsImagesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WsImagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WsImagesMaxAggregateInputType
  }

  export type GetWsImagesAggregateType<T extends WsImagesAggregateArgs> = {
        [P in keyof T & keyof AggregateWsImages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWsImages[P]>
      : GetScalarType<T[P], AggregateWsImages[P]>
  }




  export type WsImagesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WsImagesWhereInput
    orderBy?: WsImagesOrderByWithAggregationInput | WsImagesOrderByWithAggregationInput[]
    by: WsImagesScalarFieldEnum[] | WsImagesScalarFieldEnum
    having?: WsImagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WsImagesCountAggregateInputType | true
    _avg?: WsImagesAvgAggregateInputType
    _sum?: WsImagesSumAggregateInputType
    _min?: WsImagesMinAggregateInputType
    _max?: WsImagesMaxAggregateInputType
  }

  export type WsImagesGroupByOutputType = {
    vendor_id: number
    item_number: string
    image_url: string | null
    created_on: Date | null
    created_by: string | null
    _count: WsImagesCountAggregateOutputType | null
    _avg: WsImagesAvgAggregateOutputType | null
    _sum: WsImagesSumAggregateOutputType | null
    _min: WsImagesMinAggregateOutputType | null
    _max: WsImagesMaxAggregateOutputType | null
  }

  type GetWsImagesGroupByPayload<T extends WsImagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WsImagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WsImagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WsImagesGroupByOutputType[P]>
            : GetScalarType<T[P], WsImagesGroupByOutputType[P]>
        }
      >
    >


  export type WsImagesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    vendor_id?: boolean
    item_number?: boolean
    image_url?: boolean
    created_on?: boolean
    created_by?: boolean
  }, ExtArgs["result"]["wsImages"]>


  export type WsImagesSelectScalar = {
    vendor_id?: boolean
    item_number?: boolean
    image_url?: boolean
    created_on?: boolean
    created_by?: boolean
  }


  export type $WsImagesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WsImages"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      vendor_id: number
      item_number: string
      image_url: string | null
      created_on: Date | null
      created_by: string | null
    }, ExtArgs["result"]["wsImages"]>
    composites: {}
  }

  type WsImagesGetPayload<S extends boolean | null | undefined | WsImagesDefaultArgs> = $Result.GetResult<Prisma.$WsImagesPayload, S>

  type WsImagesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WsImagesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WsImagesCountAggregateInputType | true
    }

  export interface WsImagesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WsImages'], meta: { name: 'WsImages' } }
    /**
     * Find zero or one WsImages that matches the filter.
     * @param {WsImagesFindUniqueArgs} args - Arguments to find a WsImages
     * @example
     * // Get one WsImages
     * const wsImages = await prisma.wsImages.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WsImagesFindUniqueArgs>(args: SelectSubset<T, WsImagesFindUniqueArgs<ExtArgs>>): Prisma__WsImagesClient<$Result.GetResult<Prisma.$WsImagesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WsImages that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WsImagesFindUniqueOrThrowArgs} args - Arguments to find a WsImages
     * @example
     * // Get one WsImages
     * const wsImages = await prisma.wsImages.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WsImagesFindUniqueOrThrowArgs>(args: SelectSubset<T, WsImagesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WsImagesClient<$Result.GetResult<Prisma.$WsImagesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WsImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsImagesFindFirstArgs} args - Arguments to find a WsImages
     * @example
     * // Get one WsImages
     * const wsImages = await prisma.wsImages.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WsImagesFindFirstArgs>(args?: SelectSubset<T, WsImagesFindFirstArgs<ExtArgs>>): Prisma__WsImagesClient<$Result.GetResult<Prisma.$WsImagesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WsImages that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsImagesFindFirstOrThrowArgs} args - Arguments to find a WsImages
     * @example
     * // Get one WsImages
     * const wsImages = await prisma.wsImages.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WsImagesFindFirstOrThrowArgs>(args?: SelectSubset<T, WsImagesFindFirstOrThrowArgs<ExtArgs>>): Prisma__WsImagesClient<$Result.GetResult<Prisma.$WsImagesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WsImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsImagesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WsImages
     * const wsImages = await prisma.wsImages.findMany()
     * 
     * // Get first 10 WsImages
     * const wsImages = await prisma.wsImages.findMany({ take: 10 })
     * 
     * // Only select the `vendor_id`
     * const wsImagesWithVendor_idOnly = await prisma.wsImages.findMany({ select: { vendor_id: true } })
     * 
     */
    findMany<T extends WsImagesFindManyArgs>(args?: SelectSubset<T, WsImagesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WsImagesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WsImages.
     * @param {WsImagesCreateArgs} args - Arguments to create a WsImages.
     * @example
     * // Create one WsImages
     * const WsImages = await prisma.wsImages.create({
     *   data: {
     *     // ... data to create a WsImages
     *   }
     * })
     * 
     */
    create<T extends WsImagesCreateArgs>(args: SelectSubset<T, WsImagesCreateArgs<ExtArgs>>): Prisma__WsImagesClient<$Result.GetResult<Prisma.$WsImagesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WsImages.
     * @param {WsImagesCreateManyArgs} args - Arguments to create many WsImages.
     * @example
     * // Create many WsImages
     * const wsImages = await prisma.wsImages.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WsImagesCreateManyArgs>(args?: SelectSubset<T, WsImagesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WsImages.
     * @param {WsImagesDeleteArgs} args - Arguments to delete one WsImages.
     * @example
     * // Delete one WsImages
     * const WsImages = await prisma.wsImages.delete({
     *   where: {
     *     // ... filter to delete one WsImages
     *   }
     * })
     * 
     */
    delete<T extends WsImagesDeleteArgs>(args: SelectSubset<T, WsImagesDeleteArgs<ExtArgs>>): Prisma__WsImagesClient<$Result.GetResult<Prisma.$WsImagesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WsImages.
     * @param {WsImagesUpdateArgs} args - Arguments to update one WsImages.
     * @example
     * // Update one WsImages
     * const wsImages = await prisma.wsImages.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WsImagesUpdateArgs>(args: SelectSubset<T, WsImagesUpdateArgs<ExtArgs>>): Prisma__WsImagesClient<$Result.GetResult<Prisma.$WsImagesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WsImages.
     * @param {WsImagesDeleteManyArgs} args - Arguments to filter WsImages to delete.
     * @example
     * // Delete a few WsImages
     * const { count } = await prisma.wsImages.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WsImagesDeleteManyArgs>(args?: SelectSubset<T, WsImagesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WsImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsImagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WsImages
     * const wsImages = await prisma.wsImages.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WsImagesUpdateManyArgs>(args: SelectSubset<T, WsImagesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WsImages.
     * @param {WsImagesUpsertArgs} args - Arguments to update or create a WsImages.
     * @example
     * // Update or create a WsImages
     * const wsImages = await prisma.wsImages.upsert({
     *   create: {
     *     // ... data to create a WsImages
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WsImages we want to update
     *   }
     * })
     */
    upsert<T extends WsImagesUpsertArgs>(args: SelectSubset<T, WsImagesUpsertArgs<ExtArgs>>): Prisma__WsImagesClient<$Result.GetResult<Prisma.$WsImagesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WsImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsImagesCountArgs} args - Arguments to filter WsImages to count.
     * @example
     * // Count the number of WsImages
     * const count = await prisma.wsImages.count({
     *   where: {
     *     // ... the filter for the WsImages we want to count
     *   }
     * })
    **/
    count<T extends WsImagesCountArgs>(
      args?: Subset<T, WsImagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WsImagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WsImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsImagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WsImagesAggregateArgs>(args: Subset<T, WsImagesAggregateArgs>): Prisma.PrismaPromise<GetWsImagesAggregateType<T>>

    /**
     * Group by WsImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsImagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WsImagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WsImagesGroupByArgs['orderBy'] }
        : { orderBy?: WsImagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WsImagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWsImagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WsImages model
   */
  readonly fields: WsImagesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WsImages.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WsImagesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WsImages model
   */ 
  interface WsImagesFieldRefs {
    readonly vendor_id: FieldRef<"WsImages", 'Int'>
    readonly item_number: FieldRef<"WsImages", 'String'>
    readonly image_url: FieldRef<"WsImages", 'String'>
    readonly created_on: FieldRef<"WsImages", 'DateTime'>
    readonly created_by: FieldRef<"WsImages", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WsImages findUnique
   */
  export type WsImagesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsImages
     */
    select?: WsImagesSelect<ExtArgs> | null
    /**
     * Filter, which WsImages to fetch.
     */
    where: WsImagesWhereUniqueInput
  }

  /**
   * WsImages findUniqueOrThrow
   */
  export type WsImagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsImages
     */
    select?: WsImagesSelect<ExtArgs> | null
    /**
     * Filter, which WsImages to fetch.
     */
    where: WsImagesWhereUniqueInput
  }

  /**
   * WsImages findFirst
   */
  export type WsImagesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsImages
     */
    select?: WsImagesSelect<ExtArgs> | null
    /**
     * Filter, which WsImages to fetch.
     */
    where?: WsImagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WsImages to fetch.
     */
    orderBy?: WsImagesOrderByWithRelationInput | WsImagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WsImages.
     */
    cursor?: WsImagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WsImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WsImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WsImages.
     */
    distinct?: WsImagesScalarFieldEnum | WsImagesScalarFieldEnum[]
  }

  /**
   * WsImages findFirstOrThrow
   */
  export type WsImagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsImages
     */
    select?: WsImagesSelect<ExtArgs> | null
    /**
     * Filter, which WsImages to fetch.
     */
    where?: WsImagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WsImages to fetch.
     */
    orderBy?: WsImagesOrderByWithRelationInput | WsImagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WsImages.
     */
    cursor?: WsImagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WsImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WsImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WsImages.
     */
    distinct?: WsImagesScalarFieldEnum | WsImagesScalarFieldEnum[]
  }

  /**
   * WsImages findMany
   */
  export type WsImagesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsImages
     */
    select?: WsImagesSelect<ExtArgs> | null
    /**
     * Filter, which WsImages to fetch.
     */
    where?: WsImagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WsImages to fetch.
     */
    orderBy?: WsImagesOrderByWithRelationInput | WsImagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WsImages.
     */
    cursor?: WsImagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WsImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WsImages.
     */
    skip?: number
    distinct?: WsImagesScalarFieldEnum | WsImagesScalarFieldEnum[]
  }

  /**
   * WsImages create
   */
  export type WsImagesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsImages
     */
    select?: WsImagesSelect<ExtArgs> | null
    /**
     * The data needed to create a WsImages.
     */
    data: XOR<WsImagesCreateInput, WsImagesUncheckedCreateInput>
  }

  /**
   * WsImages createMany
   */
  export type WsImagesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WsImages.
     */
    data: WsImagesCreateManyInput | WsImagesCreateManyInput[]
  }

  /**
   * WsImages update
   */
  export type WsImagesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsImages
     */
    select?: WsImagesSelect<ExtArgs> | null
    /**
     * The data needed to update a WsImages.
     */
    data: XOR<WsImagesUpdateInput, WsImagesUncheckedUpdateInput>
    /**
     * Choose, which WsImages to update.
     */
    where: WsImagesWhereUniqueInput
  }

  /**
   * WsImages updateMany
   */
  export type WsImagesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WsImages.
     */
    data: XOR<WsImagesUpdateManyMutationInput, WsImagesUncheckedUpdateManyInput>
    /**
     * Filter which WsImages to update
     */
    where?: WsImagesWhereInput
  }

  /**
   * WsImages upsert
   */
  export type WsImagesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsImages
     */
    select?: WsImagesSelect<ExtArgs> | null
    /**
     * The filter to search for the WsImages to update in case it exists.
     */
    where: WsImagesWhereUniqueInput
    /**
     * In case the WsImages found by the `where` argument doesn't exist, create a new WsImages with this data.
     */
    create: XOR<WsImagesCreateInput, WsImagesUncheckedCreateInput>
    /**
     * In case the WsImages was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WsImagesUpdateInput, WsImagesUncheckedUpdateInput>
  }

  /**
   * WsImages delete
   */
  export type WsImagesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsImages
     */
    select?: WsImagesSelect<ExtArgs> | null
    /**
     * Filter which WsImages to delete.
     */
    where: WsImagesWhereUniqueInput
  }

  /**
   * WsImages deleteMany
   */
  export type WsImagesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WsImages to delete
     */
    where?: WsImagesWhereInput
  }

  /**
   * WsImages without action
   */
  export type WsImagesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsImages
     */
    select?: WsImagesSelect<ExtArgs> | null
  }


  /**
   * Model WSJob
   */

  export type AggregateWSJob = {
    _count: WSJobCountAggregateOutputType | null
    _avg: WSJobAvgAggregateOutputType | null
    _sum: WSJobSumAggregateOutputType | null
    _min: WSJobMinAggregateOutputType | null
    _max: WSJobMaxAggregateOutputType | null
  }

  export type WSJobAvgAggregateOutputType = {
    ID: number | null
    StoreId: number | null
    MaxSalary: number | null
    MinSalary: number | null
  }

  export type WSJobSumAggregateOutputType = {
    ID: number | null
    StoreId: number | null
    MaxSalary: number | null
    MinSalary: number | null
  }

  export type WSJobMinAggregateOutputType = {
    ID: number | null
    Name: string | null
    Description: string | null
    Type: string | null
    Category: string | null
    CreatedOn: Date | null
    Active: boolean | null
    StoreId: number | null
    Status: string | null
    CreatedBy: string | null
    MaxSalary: number | null
    MinSalary: number | null
    SalaryType: string | null
  }

  export type WSJobMaxAggregateOutputType = {
    ID: number | null
    Name: string | null
    Description: string | null
    Type: string | null
    Category: string | null
    CreatedOn: Date | null
    Active: boolean | null
    StoreId: number | null
    Status: string | null
    CreatedBy: string | null
    MaxSalary: number | null
    MinSalary: number | null
    SalaryType: string | null
  }

  export type WSJobCountAggregateOutputType = {
    ID: number
    Name: number
    Description: number
    Type: number
    Category: number
    CreatedOn: number
    Active: number
    StoreId: number
    Status: number
    CreatedBy: number
    MaxSalary: number
    MinSalary: number
    SalaryType: number
    _all: number
  }


  export type WSJobAvgAggregateInputType = {
    ID?: true
    StoreId?: true
    MaxSalary?: true
    MinSalary?: true
  }

  export type WSJobSumAggregateInputType = {
    ID?: true
    StoreId?: true
    MaxSalary?: true
    MinSalary?: true
  }

  export type WSJobMinAggregateInputType = {
    ID?: true
    Name?: true
    Description?: true
    Type?: true
    Category?: true
    CreatedOn?: true
    Active?: true
    StoreId?: true
    Status?: true
    CreatedBy?: true
    MaxSalary?: true
    MinSalary?: true
    SalaryType?: true
  }

  export type WSJobMaxAggregateInputType = {
    ID?: true
    Name?: true
    Description?: true
    Type?: true
    Category?: true
    CreatedOn?: true
    Active?: true
    StoreId?: true
    Status?: true
    CreatedBy?: true
    MaxSalary?: true
    MinSalary?: true
    SalaryType?: true
  }

  export type WSJobCountAggregateInputType = {
    ID?: true
    Name?: true
    Description?: true
    Type?: true
    Category?: true
    CreatedOn?: true
    Active?: true
    StoreId?: true
    Status?: true
    CreatedBy?: true
    MaxSalary?: true
    MinSalary?: true
    SalaryType?: true
    _all?: true
  }

  export type WSJobAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WSJob to aggregate.
     */
    where?: WSJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WSJobs to fetch.
     */
    orderBy?: WSJobOrderByWithRelationInput | WSJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WSJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WSJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WSJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WSJobs
    **/
    _count?: true | WSJobCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WSJobAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WSJobSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WSJobMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WSJobMaxAggregateInputType
  }

  export type GetWSJobAggregateType<T extends WSJobAggregateArgs> = {
        [P in keyof T & keyof AggregateWSJob]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWSJob[P]>
      : GetScalarType<T[P], AggregateWSJob[P]>
  }




  export type WSJobGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WSJobWhereInput
    orderBy?: WSJobOrderByWithAggregationInput | WSJobOrderByWithAggregationInput[]
    by: WSJobScalarFieldEnum[] | WSJobScalarFieldEnum
    having?: WSJobScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WSJobCountAggregateInputType | true
    _avg?: WSJobAvgAggregateInputType
    _sum?: WSJobSumAggregateInputType
    _min?: WSJobMinAggregateInputType
    _max?: WSJobMaxAggregateInputType
  }

  export type WSJobGroupByOutputType = {
    ID: number
    Name: string
    Description: string | null
    Type: string | null
    Category: string | null
    CreatedOn: Date | null
    Active: boolean
    StoreId: number
    Status: string | null
    CreatedBy: string
    MaxSalary: number
    MinSalary: number
    SalaryType: string
    _count: WSJobCountAggregateOutputType | null
    _avg: WSJobAvgAggregateOutputType | null
    _sum: WSJobSumAggregateOutputType | null
    _min: WSJobMinAggregateOutputType | null
    _max: WSJobMaxAggregateOutputType | null
  }

  type GetWSJobGroupByPayload<T extends WSJobGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WSJobGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WSJobGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WSJobGroupByOutputType[P]>
            : GetScalarType<T[P], WSJobGroupByOutputType[P]>
        }
      >
    >


  export type WSJobSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    Name?: boolean
    Description?: boolean
    Type?: boolean
    Category?: boolean
    CreatedOn?: boolean
    Active?: boolean
    StoreId?: boolean
    Status?: boolean
    CreatedBy?: boolean
    MaxSalary?: boolean
    MinSalary?: boolean
    SalaryType?: boolean
    WsStore?: boolean | WsStoreDefaultArgs<ExtArgs>
    WSJobApplication?: boolean | WSJob$WSJobApplicationArgs<ExtArgs>
    _count?: boolean | WSJobCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wSJob"]>


  export type WSJobSelectScalar = {
    ID?: boolean
    Name?: boolean
    Description?: boolean
    Type?: boolean
    Category?: boolean
    CreatedOn?: boolean
    Active?: boolean
    StoreId?: boolean
    Status?: boolean
    CreatedBy?: boolean
    MaxSalary?: boolean
    MinSalary?: boolean
    SalaryType?: boolean
  }

  export type WSJobInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    WsStore?: boolean | WsStoreDefaultArgs<ExtArgs>
    WSJobApplication?: boolean | WSJob$WSJobApplicationArgs<ExtArgs>
    _count?: boolean | WSJobCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $WSJobPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WSJob"
    objects: {
      WsStore: Prisma.$WsStorePayload<ExtArgs>
      WSJobApplication: Prisma.$WSJobApplicationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      Name: string
      Description: string | null
      Type: string | null
      Category: string | null
      CreatedOn: Date | null
      Active: boolean
      StoreId: number
      Status: string | null
      CreatedBy: string
      MaxSalary: number
      MinSalary: number
      SalaryType: string
    }, ExtArgs["result"]["wSJob"]>
    composites: {}
  }

  type WSJobGetPayload<S extends boolean | null | undefined | WSJobDefaultArgs> = $Result.GetResult<Prisma.$WSJobPayload, S>

  type WSJobCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WSJobFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WSJobCountAggregateInputType | true
    }

  export interface WSJobDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WSJob'], meta: { name: 'WSJob' } }
    /**
     * Find zero or one WSJob that matches the filter.
     * @param {WSJobFindUniqueArgs} args - Arguments to find a WSJob
     * @example
     * // Get one WSJob
     * const wSJob = await prisma.wSJob.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WSJobFindUniqueArgs>(args: SelectSubset<T, WSJobFindUniqueArgs<ExtArgs>>): Prisma__WSJobClient<$Result.GetResult<Prisma.$WSJobPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WSJob that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WSJobFindUniqueOrThrowArgs} args - Arguments to find a WSJob
     * @example
     * // Get one WSJob
     * const wSJob = await prisma.wSJob.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WSJobFindUniqueOrThrowArgs>(args: SelectSubset<T, WSJobFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WSJobClient<$Result.GetResult<Prisma.$WSJobPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WSJob that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSJobFindFirstArgs} args - Arguments to find a WSJob
     * @example
     * // Get one WSJob
     * const wSJob = await prisma.wSJob.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WSJobFindFirstArgs>(args?: SelectSubset<T, WSJobFindFirstArgs<ExtArgs>>): Prisma__WSJobClient<$Result.GetResult<Prisma.$WSJobPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WSJob that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSJobFindFirstOrThrowArgs} args - Arguments to find a WSJob
     * @example
     * // Get one WSJob
     * const wSJob = await prisma.wSJob.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WSJobFindFirstOrThrowArgs>(args?: SelectSubset<T, WSJobFindFirstOrThrowArgs<ExtArgs>>): Prisma__WSJobClient<$Result.GetResult<Prisma.$WSJobPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WSJobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSJobFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WSJobs
     * const wSJobs = await prisma.wSJob.findMany()
     * 
     * // Get first 10 WSJobs
     * const wSJobs = await prisma.wSJob.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const wSJobWithIDOnly = await prisma.wSJob.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends WSJobFindManyArgs>(args?: SelectSubset<T, WSJobFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WSJobPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WSJob.
     * @param {WSJobCreateArgs} args - Arguments to create a WSJob.
     * @example
     * // Create one WSJob
     * const WSJob = await prisma.wSJob.create({
     *   data: {
     *     // ... data to create a WSJob
     *   }
     * })
     * 
     */
    create<T extends WSJobCreateArgs>(args: SelectSubset<T, WSJobCreateArgs<ExtArgs>>): Prisma__WSJobClient<$Result.GetResult<Prisma.$WSJobPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WSJobs.
     * @param {WSJobCreateManyArgs} args - Arguments to create many WSJobs.
     * @example
     * // Create many WSJobs
     * const wSJob = await prisma.wSJob.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WSJobCreateManyArgs>(args?: SelectSubset<T, WSJobCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WSJob.
     * @param {WSJobDeleteArgs} args - Arguments to delete one WSJob.
     * @example
     * // Delete one WSJob
     * const WSJob = await prisma.wSJob.delete({
     *   where: {
     *     // ... filter to delete one WSJob
     *   }
     * })
     * 
     */
    delete<T extends WSJobDeleteArgs>(args: SelectSubset<T, WSJobDeleteArgs<ExtArgs>>): Prisma__WSJobClient<$Result.GetResult<Prisma.$WSJobPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WSJob.
     * @param {WSJobUpdateArgs} args - Arguments to update one WSJob.
     * @example
     * // Update one WSJob
     * const wSJob = await prisma.wSJob.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WSJobUpdateArgs>(args: SelectSubset<T, WSJobUpdateArgs<ExtArgs>>): Prisma__WSJobClient<$Result.GetResult<Prisma.$WSJobPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WSJobs.
     * @param {WSJobDeleteManyArgs} args - Arguments to filter WSJobs to delete.
     * @example
     * // Delete a few WSJobs
     * const { count } = await prisma.wSJob.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WSJobDeleteManyArgs>(args?: SelectSubset<T, WSJobDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WSJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSJobUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WSJobs
     * const wSJob = await prisma.wSJob.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WSJobUpdateManyArgs>(args: SelectSubset<T, WSJobUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WSJob.
     * @param {WSJobUpsertArgs} args - Arguments to update or create a WSJob.
     * @example
     * // Update or create a WSJob
     * const wSJob = await prisma.wSJob.upsert({
     *   create: {
     *     // ... data to create a WSJob
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WSJob we want to update
     *   }
     * })
     */
    upsert<T extends WSJobUpsertArgs>(args: SelectSubset<T, WSJobUpsertArgs<ExtArgs>>): Prisma__WSJobClient<$Result.GetResult<Prisma.$WSJobPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WSJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSJobCountArgs} args - Arguments to filter WSJobs to count.
     * @example
     * // Count the number of WSJobs
     * const count = await prisma.wSJob.count({
     *   where: {
     *     // ... the filter for the WSJobs we want to count
     *   }
     * })
    **/
    count<T extends WSJobCountArgs>(
      args?: Subset<T, WSJobCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WSJobCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WSJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSJobAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WSJobAggregateArgs>(args: Subset<T, WSJobAggregateArgs>): Prisma.PrismaPromise<GetWSJobAggregateType<T>>

    /**
     * Group by WSJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSJobGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WSJobGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WSJobGroupByArgs['orderBy'] }
        : { orderBy?: WSJobGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WSJobGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWSJobGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WSJob model
   */
  readonly fields: WSJobFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WSJob.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WSJobClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    WsStore<T extends WsStoreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WsStoreDefaultArgs<ExtArgs>>): Prisma__WsStoreClient<$Result.GetResult<Prisma.$WsStorePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    WSJobApplication<T extends WSJob$WSJobApplicationArgs<ExtArgs> = {}>(args?: Subset<T, WSJob$WSJobApplicationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WSJobApplicationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WSJob model
   */ 
  interface WSJobFieldRefs {
    readonly ID: FieldRef<"WSJob", 'Int'>
    readonly Name: FieldRef<"WSJob", 'String'>
    readonly Description: FieldRef<"WSJob", 'String'>
    readonly Type: FieldRef<"WSJob", 'String'>
    readonly Category: FieldRef<"WSJob", 'String'>
    readonly CreatedOn: FieldRef<"WSJob", 'DateTime'>
    readonly Active: FieldRef<"WSJob", 'Boolean'>
    readonly StoreId: FieldRef<"WSJob", 'Int'>
    readonly Status: FieldRef<"WSJob", 'String'>
    readonly CreatedBy: FieldRef<"WSJob", 'String'>
    readonly MaxSalary: FieldRef<"WSJob", 'Float'>
    readonly MinSalary: FieldRef<"WSJob", 'Float'>
    readonly SalaryType: FieldRef<"WSJob", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WSJob findUnique
   */
  export type WSJobFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJob
     */
    select?: WSJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobInclude<ExtArgs> | null
    /**
     * Filter, which WSJob to fetch.
     */
    where: WSJobWhereUniqueInput
  }

  /**
   * WSJob findUniqueOrThrow
   */
  export type WSJobFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJob
     */
    select?: WSJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobInclude<ExtArgs> | null
    /**
     * Filter, which WSJob to fetch.
     */
    where: WSJobWhereUniqueInput
  }

  /**
   * WSJob findFirst
   */
  export type WSJobFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJob
     */
    select?: WSJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobInclude<ExtArgs> | null
    /**
     * Filter, which WSJob to fetch.
     */
    where?: WSJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WSJobs to fetch.
     */
    orderBy?: WSJobOrderByWithRelationInput | WSJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WSJobs.
     */
    cursor?: WSJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WSJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WSJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WSJobs.
     */
    distinct?: WSJobScalarFieldEnum | WSJobScalarFieldEnum[]
  }

  /**
   * WSJob findFirstOrThrow
   */
  export type WSJobFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJob
     */
    select?: WSJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobInclude<ExtArgs> | null
    /**
     * Filter, which WSJob to fetch.
     */
    where?: WSJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WSJobs to fetch.
     */
    orderBy?: WSJobOrderByWithRelationInput | WSJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WSJobs.
     */
    cursor?: WSJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WSJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WSJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WSJobs.
     */
    distinct?: WSJobScalarFieldEnum | WSJobScalarFieldEnum[]
  }

  /**
   * WSJob findMany
   */
  export type WSJobFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJob
     */
    select?: WSJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobInclude<ExtArgs> | null
    /**
     * Filter, which WSJobs to fetch.
     */
    where?: WSJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WSJobs to fetch.
     */
    orderBy?: WSJobOrderByWithRelationInput | WSJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WSJobs.
     */
    cursor?: WSJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WSJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WSJobs.
     */
    skip?: number
    distinct?: WSJobScalarFieldEnum | WSJobScalarFieldEnum[]
  }

  /**
   * WSJob create
   */
  export type WSJobCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJob
     */
    select?: WSJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobInclude<ExtArgs> | null
    /**
     * The data needed to create a WSJob.
     */
    data: XOR<WSJobCreateInput, WSJobUncheckedCreateInput>
  }

  /**
   * WSJob createMany
   */
  export type WSJobCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WSJobs.
     */
    data: WSJobCreateManyInput | WSJobCreateManyInput[]
  }

  /**
   * WSJob update
   */
  export type WSJobUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJob
     */
    select?: WSJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobInclude<ExtArgs> | null
    /**
     * The data needed to update a WSJob.
     */
    data: XOR<WSJobUpdateInput, WSJobUncheckedUpdateInput>
    /**
     * Choose, which WSJob to update.
     */
    where: WSJobWhereUniqueInput
  }

  /**
   * WSJob updateMany
   */
  export type WSJobUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WSJobs.
     */
    data: XOR<WSJobUpdateManyMutationInput, WSJobUncheckedUpdateManyInput>
    /**
     * Filter which WSJobs to update
     */
    where?: WSJobWhereInput
  }

  /**
   * WSJob upsert
   */
  export type WSJobUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJob
     */
    select?: WSJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobInclude<ExtArgs> | null
    /**
     * The filter to search for the WSJob to update in case it exists.
     */
    where: WSJobWhereUniqueInput
    /**
     * In case the WSJob found by the `where` argument doesn't exist, create a new WSJob with this data.
     */
    create: XOR<WSJobCreateInput, WSJobUncheckedCreateInput>
    /**
     * In case the WSJob was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WSJobUpdateInput, WSJobUncheckedUpdateInput>
  }

  /**
   * WSJob delete
   */
  export type WSJobDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJob
     */
    select?: WSJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobInclude<ExtArgs> | null
    /**
     * Filter which WSJob to delete.
     */
    where: WSJobWhereUniqueInput
  }

  /**
   * WSJob deleteMany
   */
  export type WSJobDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WSJobs to delete
     */
    where?: WSJobWhereInput
  }

  /**
   * WSJob.WSJobApplication
   */
  export type WSJob$WSJobApplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJobApplication
     */
    select?: WSJobApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobApplicationInclude<ExtArgs> | null
    where?: WSJobApplicationWhereInput
    orderBy?: WSJobApplicationOrderByWithRelationInput | WSJobApplicationOrderByWithRelationInput[]
    cursor?: WSJobApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WSJobApplicationScalarFieldEnum | WSJobApplicationScalarFieldEnum[]
  }

  /**
   * WSJob without action
   */
  export type WSJobDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJob
     */
    select?: WSJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobInclude<ExtArgs> | null
  }


  /**
   * Model WSJobApplication
   */

  export type AggregateWSJobApplication = {
    _count: WSJobApplicationCountAggregateOutputType | null
    _avg: WSJobApplicationAvgAggregateOutputType | null
    _sum: WSJobApplicationSumAggregateOutputType | null
    _min: WSJobApplicationMinAggregateOutputType | null
    _max: WSJobApplicationMaxAggregateOutputType | null
  }

  export type WSJobApplicationAvgAggregateOutputType = {
    ID: number | null
    JobId: number | null
    UserId: number | null
  }

  export type WSJobApplicationSumAggregateOutputType = {
    ID: number | null
    JobId: number | null
    UserId: number | null
  }

  export type WSJobApplicationMinAggregateOutputType = {
    ID: number | null
    JobId: number | null
    UserId: number | null
    IsValid: string | null
    Status: string | null
    Active: boolean | null
    CreatedBy: string | null
    CreatedOn: Date | null
    IsDenied: boolean | null
  }

  export type WSJobApplicationMaxAggregateOutputType = {
    ID: number | null
    JobId: number | null
    UserId: number | null
    IsValid: string | null
    Status: string | null
    Active: boolean | null
    CreatedBy: string | null
    CreatedOn: Date | null
    IsDenied: boolean | null
  }

  export type WSJobApplicationCountAggregateOutputType = {
    ID: number
    JobId: number
    UserId: number
    IsValid: number
    Status: number
    Active: number
    CreatedBy: number
    CreatedOn: number
    IsDenied: number
    _all: number
  }


  export type WSJobApplicationAvgAggregateInputType = {
    ID?: true
    JobId?: true
    UserId?: true
  }

  export type WSJobApplicationSumAggregateInputType = {
    ID?: true
    JobId?: true
    UserId?: true
  }

  export type WSJobApplicationMinAggregateInputType = {
    ID?: true
    JobId?: true
    UserId?: true
    IsValid?: true
    Status?: true
    Active?: true
    CreatedBy?: true
    CreatedOn?: true
    IsDenied?: true
  }

  export type WSJobApplicationMaxAggregateInputType = {
    ID?: true
    JobId?: true
    UserId?: true
    IsValid?: true
    Status?: true
    Active?: true
    CreatedBy?: true
    CreatedOn?: true
    IsDenied?: true
  }

  export type WSJobApplicationCountAggregateInputType = {
    ID?: true
    JobId?: true
    UserId?: true
    IsValid?: true
    Status?: true
    Active?: true
    CreatedBy?: true
    CreatedOn?: true
    IsDenied?: true
    _all?: true
  }

  export type WSJobApplicationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WSJobApplication to aggregate.
     */
    where?: WSJobApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WSJobApplications to fetch.
     */
    orderBy?: WSJobApplicationOrderByWithRelationInput | WSJobApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WSJobApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WSJobApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WSJobApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WSJobApplications
    **/
    _count?: true | WSJobApplicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WSJobApplicationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WSJobApplicationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WSJobApplicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WSJobApplicationMaxAggregateInputType
  }

  export type GetWSJobApplicationAggregateType<T extends WSJobApplicationAggregateArgs> = {
        [P in keyof T & keyof AggregateWSJobApplication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWSJobApplication[P]>
      : GetScalarType<T[P], AggregateWSJobApplication[P]>
  }




  export type WSJobApplicationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WSJobApplicationWhereInput
    orderBy?: WSJobApplicationOrderByWithAggregationInput | WSJobApplicationOrderByWithAggregationInput[]
    by: WSJobApplicationScalarFieldEnum[] | WSJobApplicationScalarFieldEnum
    having?: WSJobApplicationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WSJobApplicationCountAggregateInputType | true
    _avg?: WSJobApplicationAvgAggregateInputType
    _sum?: WSJobApplicationSumAggregateInputType
    _min?: WSJobApplicationMinAggregateInputType
    _max?: WSJobApplicationMaxAggregateInputType
  }

  export type WSJobApplicationGroupByOutputType = {
    ID: number
    JobId: number
    UserId: number
    IsValid: string | null
    Status: string | null
    Active: boolean
    CreatedBy: string | null
    CreatedOn: Date | null
    IsDenied: boolean
    _count: WSJobApplicationCountAggregateOutputType | null
    _avg: WSJobApplicationAvgAggregateOutputType | null
    _sum: WSJobApplicationSumAggregateOutputType | null
    _min: WSJobApplicationMinAggregateOutputType | null
    _max: WSJobApplicationMaxAggregateOutputType | null
  }

  type GetWSJobApplicationGroupByPayload<T extends WSJobApplicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WSJobApplicationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WSJobApplicationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WSJobApplicationGroupByOutputType[P]>
            : GetScalarType<T[P], WSJobApplicationGroupByOutputType[P]>
        }
      >
    >


  export type WSJobApplicationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    JobId?: boolean
    UserId?: boolean
    IsValid?: boolean
    Status?: boolean
    Active?: boolean
    CreatedBy?: boolean
    CreatedOn?: boolean
    IsDenied?: boolean
    WSJob?: boolean | WSJobDefaultArgs<ExtArgs>
    WsUser?: boolean | WsUserDefaultArgs<ExtArgs>
    WSJobApplicationEducation?: boolean | WSJobApplication$WSJobApplicationEducationArgs<ExtArgs>
    WSJobApplicationFeedback?: boolean | WSJobApplication$WSJobApplicationFeedbackArgs<ExtArgs>
    WSJobApplicationPreviousEmployment?: boolean | WSJobApplication$WSJobApplicationPreviousEmploymentArgs<ExtArgs>
    WSJobApplicationReference?: boolean | WSJobApplication$WSJobApplicationReferenceArgs<ExtArgs>
    _count?: boolean | WSJobApplicationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wSJobApplication"]>


  export type WSJobApplicationSelectScalar = {
    ID?: boolean
    JobId?: boolean
    UserId?: boolean
    IsValid?: boolean
    Status?: boolean
    Active?: boolean
    CreatedBy?: boolean
    CreatedOn?: boolean
    IsDenied?: boolean
  }

  export type WSJobApplicationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    WSJob?: boolean | WSJobDefaultArgs<ExtArgs>
    WsUser?: boolean | WsUserDefaultArgs<ExtArgs>
    WSJobApplicationEducation?: boolean | WSJobApplication$WSJobApplicationEducationArgs<ExtArgs>
    WSJobApplicationFeedback?: boolean | WSJobApplication$WSJobApplicationFeedbackArgs<ExtArgs>
    WSJobApplicationPreviousEmployment?: boolean | WSJobApplication$WSJobApplicationPreviousEmploymentArgs<ExtArgs>
    WSJobApplicationReference?: boolean | WSJobApplication$WSJobApplicationReferenceArgs<ExtArgs>
    _count?: boolean | WSJobApplicationCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $WSJobApplicationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WSJobApplication"
    objects: {
      WSJob: Prisma.$WSJobPayload<ExtArgs>
      WsUser: Prisma.$WsUserPayload<ExtArgs>
      WSJobApplicationEducation: Prisma.$WSJobApplicationEducationPayload<ExtArgs>[]
      WSJobApplicationFeedback: Prisma.$WSJobApplicationFeedbackPayload<ExtArgs>[]
      WSJobApplicationPreviousEmployment: Prisma.$WSJobApplicationPreviousEmploymentPayload<ExtArgs>[]
      WSJobApplicationReference: Prisma.$WSJobApplicationReferencePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      JobId: number
      UserId: number
      IsValid: string | null
      Status: string | null
      Active: boolean
      CreatedBy: string | null
      CreatedOn: Date | null
      IsDenied: boolean
    }, ExtArgs["result"]["wSJobApplication"]>
    composites: {}
  }

  type WSJobApplicationGetPayload<S extends boolean | null | undefined | WSJobApplicationDefaultArgs> = $Result.GetResult<Prisma.$WSJobApplicationPayload, S>

  type WSJobApplicationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WSJobApplicationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WSJobApplicationCountAggregateInputType | true
    }

  export interface WSJobApplicationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WSJobApplication'], meta: { name: 'WSJobApplication' } }
    /**
     * Find zero or one WSJobApplication that matches the filter.
     * @param {WSJobApplicationFindUniqueArgs} args - Arguments to find a WSJobApplication
     * @example
     * // Get one WSJobApplication
     * const wSJobApplication = await prisma.wSJobApplication.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WSJobApplicationFindUniqueArgs>(args: SelectSubset<T, WSJobApplicationFindUniqueArgs<ExtArgs>>): Prisma__WSJobApplicationClient<$Result.GetResult<Prisma.$WSJobApplicationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WSJobApplication that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WSJobApplicationFindUniqueOrThrowArgs} args - Arguments to find a WSJobApplication
     * @example
     * // Get one WSJobApplication
     * const wSJobApplication = await prisma.wSJobApplication.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WSJobApplicationFindUniqueOrThrowArgs>(args: SelectSubset<T, WSJobApplicationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WSJobApplicationClient<$Result.GetResult<Prisma.$WSJobApplicationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WSJobApplication that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSJobApplicationFindFirstArgs} args - Arguments to find a WSJobApplication
     * @example
     * // Get one WSJobApplication
     * const wSJobApplication = await prisma.wSJobApplication.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WSJobApplicationFindFirstArgs>(args?: SelectSubset<T, WSJobApplicationFindFirstArgs<ExtArgs>>): Prisma__WSJobApplicationClient<$Result.GetResult<Prisma.$WSJobApplicationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WSJobApplication that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSJobApplicationFindFirstOrThrowArgs} args - Arguments to find a WSJobApplication
     * @example
     * // Get one WSJobApplication
     * const wSJobApplication = await prisma.wSJobApplication.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WSJobApplicationFindFirstOrThrowArgs>(args?: SelectSubset<T, WSJobApplicationFindFirstOrThrowArgs<ExtArgs>>): Prisma__WSJobApplicationClient<$Result.GetResult<Prisma.$WSJobApplicationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WSJobApplications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSJobApplicationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WSJobApplications
     * const wSJobApplications = await prisma.wSJobApplication.findMany()
     * 
     * // Get first 10 WSJobApplications
     * const wSJobApplications = await prisma.wSJobApplication.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const wSJobApplicationWithIDOnly = await prisma.wSJobApplication.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends WSJobApplicationFindManyArgs>(args?: SelectSubset<T, WSJobApplicationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WSJobApplicationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WSJobApplication.
     * @param {WSJobApplicationCreateArgs} args - Arguments to create a WSJobApplication.
     * @example
     * // Create one WSJobApplication
     * const WSJobApplication = await prisma.wSJobApplication.create({
     *   data: {
     *     // ... data to create a WSJobApplication
     *   }
     * })
     * 
     */
    create<T extends WSJobApplicationCreateArgs>(args: SelectSubset<T, WSJobApplicationCreateArgs<ExtArgs>>): Prisma__WSJobApplicationClient<$Result.GetResult<Prisma.$WSJobApplicationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WSJobApplications.
     * @param {WSJobApplicationCreateManyArgs} args - Arguments to create many WSJobApplications.
     * @example
     * // Create many WSJobApplications
     * const wSJobApplication = await prisma.wSJobApplication.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WSJobApplicationCreateManyArgs>(args?: SelectSubset<T, WSJobApplicationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WSJobApplication.
     * @param {WSJobApplicationDeleteArgs} args - Arguments to delete one WSJobApplication.
     * @example
     * // Delete one WSJobApplication
     * const WSJobApplication = await prisma.wSJobApplication.delete({
     *   where: {
     *     // ... filter to delete one WSJobApplication
     *   }
     * })
     * 
     */
    delete<T extends WSJobApplicationDeleteArgs>(args: SelectSubset<T, WSJobApplicationDeleteArgs<ExtArgs>>): Prisma__WSJobApplicationClient<$Result.GetResult<Prisma.$WSJobApplicationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WSJobApplication.
     * @param {WSJobApplicationUpdateArgs} args - Arguments to update one WSJobApplication.
     * @example
     * // Update one WSJobApplication
     * const wSJobApplication = await prisma.wSJobApplication.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WSJobApplicationUpdateArgs>(args: SelectSubset<T, WSJobApplicationUpdateArgs<ExtArgs>>): Prisma__WSJobApplicationClient<$Result.GetResult<Prisma.$WSJobApplicationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WSJobApplications.
     * @param {WSJobApplicationDeleteManyArgs} args - Arguments to filter WSJobApplications to delete.
     * @example
     * // Delete a few WSJobApplications
     * const { count } = await prisma.wSJobApplication.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WSJobApplicationDeleteManyArgs>(args?: SelectSubset<T, WSJobApplicationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WSJobApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSJobApplicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WSJobApplications
     * const wSJobApplication = await prisma.wSJobApplication.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WSJobApplicationUpdateManyArgs>(args: SelectSubset<T, WSJobApplicationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WSJobApplication.
     * @param {WSJobApplicationUpsertArgs} args - Arguments to update or create a WSJobApplication.
     * @example
     * // Update or create a WSJobApplication
     * const wSJobApplication = await prisma.wSJobApplication.upsert({
     *   create: {
     *     // ... data to create a WSJobApplication
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WSJobApplication we want to update
     *   }
     * })
     */
    upsert<T extends WSJobApplicationUpsertArgs>(args: SelectSubset<T, WSJobApplicationUpsertArgs<ExtArgs>>): Prisma__WSJobApplicationClient<$Result.GetResult<Prisma.$WSJobApplicationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WSJobApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSJobApplicationCountArgs} args - Arguments to filter WSJobApplications to count.
     * @example
     * // Count the number of WSJobApplications
     * const count = await prisma.wSJobApplication.count({
     *   where: {
     *     // ... the filter for the WSJobApplications we want to count
     *   }
     * })
    **/
    count<T extends WSJobApplicationCountArgs>(
      args?: Subset<T, WSJobApplicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WSJobApplicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WSJobApplication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSJobApplicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WSJobApplicationAggregateArgs>(args: Subset<T, WSJobApplicationAggregateArgs>): Prisma.PrismaPromise<GetWSJobApplicationAggregateType<T>>

    /**
     * Group by WSJobApplication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSJobApplicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WSJobApplicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WSJobApplicationGroupByArgs['orderBy'] }
        : { orderBy?: WSJobApplicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WSJobApplicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWSJobApplicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WSJobApplication model
   */
  readonly fields: WSJobApplicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WSJobApplication.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WSJobApplicationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    WSJob<T extends WSJobDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WSJobDefaultArgs<ExtArgs>>): Prisma__WSJobClient<$Result.GetResult<Prisma.$WSJobPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    WsUser<T extends WsUserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WsUserDefaultArgs<ExtArgs>>): Prisma__WsUserClient<$Result.GetResult<Prisma.$WsUserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    WSJobApplicationEducation<T extends WSJobApplication$WSJobApplicationEducationArgs<ExtArgs> = {}>(args?: Subset<T, WSJobApplication$WSJobApplicationEducationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WSJobApplicationEducationPayload<ExtArgs>, T, "findMany"> | Null>
    WSJobApplicationFeedback<T extends WSJobApplication$WSJobApplicationFeedbackArgs<ExtArgs> = {}>(args?: Subset<T, WSJobApplication$WSJobApplicationFeedbackArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WSJobApplicationFeedbackPayload<ExtArgs>, T, "findMany"> | Null>
    WSJobApplicationPreviousEmployment<T extends WSJobApplication$WSJobApplicationPreviousEmploymentArgs<ExtArgs> = {}>(args?: Subset<T, WSJobApplication$WSJobApplicationPreviousEmploymentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WSJobApplicationPreviousEmploymentPayload<ExtArgs>, T, "findMany"> | Null>
    WSJobApplicationReference<T extends WSJobApplication$WSJobApplicationReferenceArgs<ExtArgs> = {}>(args?: Subset<T, WSJobApplication$WSJobApplicationReferenceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WSJobApplicationReferencePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WSJobApplication model
   */ 
  interface WSJobApplicationFieldRefs {
    readonly ID: FieldRef<"WSJobApplication", 'Int'>
    readonly JobId: FieldRef<"WSJobApplication", 'Int'>
    readonly UserId: FieldRef<"WSJobApplication", 'Int'>
    readonly IsValid: FieldRef<"WSJobApplication", 'String'>
    readonly Status: FieldRef<"WSJobApplication", 'String'>
    readonly Active: FieldRef<"WSJobApplication", 'Boolean'>
    readonly CreatedBy: FieldRef<"WSJobApplication", 'String'>
    readonly CreatedOn: FieldRef<"WSJobApplication", 'DateTime'>
    readonly IsDenied: FieldRef<"WSJobApplication", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * WSJobApplication findUnique
   */
  export type WSJobApplicationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJobApplication
     */
    select?: WSJobApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobApplicationInclude<ExtArgs> | null
    /**
     * Filter, which WSJobApplication to fetch.
     */
    where: WSJobApplicationWhereUniqueInput
  }

  /**
   * WSJobApplication findUniqueOrThrow
   */
  export type WSJobApplicationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJobApplication
     */
    select?: WSJobApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobApplicationInclude<ExtArgs> | null
    /**
     * Filter, which WSJobApplication to fetch.
     */
    where: WSJobApplicationWhereUniqueInput
  }

  /**
   * WSJobApplication findFirst
   */
  export type WSJobApplicationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJobApplication
     */
    select?: WSJobApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobApplicationInclude<ExtArgs> | null
    /**
     * Filter, which WSJobApplication to fetch.
     */
    where?: WSJobApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WSJobApplications to fetch.
     */
    orderBy?: WSJobApplicationOrderByWithRelationInput | WSJobApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WSJobApplications.
     */
    cursor?: WSJobApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WSJobApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WSJobApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WSJobApplications.
     */
    distinct?: WSJobApplicationScalarFieldEnum | WSJobApplicationScalarFieldEnum[]
  }

  /**
   * WSJobApplication findFirstOrThrow
   */
  export type WSJobApplicationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJobApplication
     */
    select?: WSJobApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobApplicationInclude<ExtArgs> | null
    /**
     * Filter, which WSJobApplication to fetch.
     */
    where?: WSJobApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WSJobApplications to fetch.
     */
    orderBy?: WSJobApplicationOrderByWithRelationInput | WSJobApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WSJobApplications.
     */
    cursor?: WSJobApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WSJobApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WSJobApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WSJobApplications.
     */
    distinct?: WSJobApplicationScalarFieldEnum | WSJobApplicationScalarFieldEnum[]
  }

  /**
   * WSJobApplication findMany
   */
  export type WSJobApplicationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJobApplication
     */
    select?: WSJobApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobApplicationInclude<ExtArgs> | null
    /**
     * Filter, which WSJobApplications to fetch.
     */
    where?: WSJobApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WSJobApplications to fetch.
     */
    orderBy?: WSJobApplicationOrderByWithRelationInput | WSJobApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WSJobApplications.
     */
    cursor?: WSJobApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WSJobApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WSJobApplications.
     */
    skip?: number
    distinct?: WSJobApplicationScalarFieldEnum | WSJobApplicationScalarFieldEnum[]
  }

  /**
   * WSJobApplication create
   */
  export type WSJobApplicationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJobApplication
     */
    select?: WSJobApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobApplicationInclude<ExtArgs> | null
    /**
     * The data needed to create a WSJobApplication.
     */
    data: XOR<WSJobApplicationCreateInput, WSJobApplicationUncheckedCreateInput>
  }

  /**
   * WSJobApplication createMany
   */
  export type WSJobApplicationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WSJobApplications.
     */
    data: WSJobApplicationCreateManyInput | WSJobApplicationCreateManyInput[]
  }

  /**
   * WSJobApplication update
   */
  export type WSJobApplicationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJobApplication
     */
    select?: WSJobApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobApplicationInclude<ExtArgs> | null
    /**
     * The data needed to update a WSJobApplication.
     */
    data: XOR<WSJobApplicationUpdateInput, WSJobApplicationUncheckedUpdateInput>
    /**
     * Choose, which WSJobApplication to update.
     */
    where: WSJobApplicationWhereUniqueInput
  }

  /**
   * WSJobApplication updateMany
   */
  export type WSJobApplicationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WSJobApplications.
     */
    data: XOR<WSJobApplicationUpdateManyMutationInput, WSJobApplicationUncheckedUpdateManyInput>
    /**
     * Filter which WSJobApplications to update
     */
    where?: WSJobApplicationWhereInput
  }

  /**
   * WSJobApplication upsert
   */
  export type WSJobApplicationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJobApplication
     */
    select?: WSJobApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobApplicationInclude<ExtArgs> | null
    /**
     * The filter to search for the WSJobApplication to update in case it exists.
     */
    where: WSJobApplicationWhereUniqueInput
    /**
     * In case the WSJobApplication found by the `where` argument doesn't exist, create a new WSJobApplication with this data.
     */
    create: XOR<WSJobApplicationCreateInput, WSJobApplicationUncheckedCreateInput>
    /**
     * In case the WSJobApplication was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WSJobApplicationUpdateInput, WSJobApplicationUncheckedUpdateInput>
  }

  /**
   * WSJobApplication delete
   */
  export type WSJobApplicationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJobApplication
     */
    select?: WSJobApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobApplicationInclude<ExtArgs> | null
    /**
     * Filter which WSJobApplication to delete.
     */
    where: WSJobApplicationWhereUniqueInput
  }

  /**
   * WSJobApplication deleteMany
   */
  export type WSJobApplicationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WSJobApplications to delete
     */
    where?: WSJobApplicationWhereInput
  }

  /**
   * WSJobApplication.WSJobApplicationEducation
   */
  export type WSJobApplication$WSJobApplicationEducationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJobApplicationEducation
     */
    select?: WSJobApplicationEducationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobApplicationEducationInclude<ExtArgs> | null
    where?: WSJobApplicationEducationWhereInput
    orderBy?: WSJobApplicationEducationOrderByWithRelationInput | WSJobApplicationEducationOrderByWithRelationInput[]
    cursor?: WSJobApplicationEducationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WSJobApplicationEducationScalarFieldEnum | WSJobApplicationEducationScalarFieldEnum[]
  }

  /**
   * WSJobApplication.WSJobApplicationFeedback
   */
  export type WSJobApplication$WSJobApplicationFeedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJobApplicationFeedback
     */
    select?: WSJobApplicationFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobApplicationFeedbackInclude<ExtArgs> | null
    where?: WSJobApplicationFeedbackWhereInput
    orderBy?: WSJobApplicationFeedbackOrderByWithRelationInput | WSJobApplicationFeedbackOrderByWithRelationInput[]
    cursor?: WSJobApplicationFeedbackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WSJobApplicationFeedbackScalarFieldEnum | WSJobApplicationFeedbackScalarFieldEnum[]
  }

  /**
   * WSJobApplication.WSJobApplicationPreviousEmployment
   */
  export type WSJobApplication$WSJobApplicationPreviousEmploymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJobApplicationPreviousEmployment
     */
    select?: WSJobApplicationPreviousEmploymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobApplicationPreviousEmploymentInclude<ExtArgs> | null
    where?: WSJobApplicationPreviousEmploymentWhereInput
    orderBy?: WSJobApplicationPreviousEmploymentOrderByWithRelationInput | WSJobApplicationPreviousEmploymentOrderByWithRelationInput[]
    cursor?: WSJobApplicationPreviousEmploymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WSJobApplicationPreviousEmploymentScalarFieldEnum | WSJobApplicationPreviousEmploymentScalarFieldEnum[]
  }

  /**
   * WSJobApplication.WSJobApplicationReference
   */
  export type WSJobApplication$WSJobApplicationReferenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJobApplicationReference
     */
    select?: WSJobApplicationReferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobApplicationReferenceInclude<ExtArgs> | null
    where?: WSJobApplicationReferenceWhereInput
    orderBy?: WSJobApplicationReferenceOrderByWithRelationInput | WSJobApplicationReferenceOrderByWithRelationInput[]
    cursor?: WSJobApplicationReferenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WSJobApplicationReferenceScalarFieldEnum | WSJobApplicationReferenceScalarFieldEnum[]
  }

  /**
   * WSJobApplication without action
   */
  export type WSJobApplicationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJobApplication
     */
    select?: WSJobApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobApplicationInclude<ExtArgs> | null
  }


  /**
   * Model WSJobApplicationEducation
   */

  export type AggregateWSJobApplicationEducation = {
    _count: WSJobApplicationEducationCountAggregateOutputType | null
    _avg: WSJobApplicationEducationAvgAggregateOutputType | null
    _sum: WSJobApplicationEducationSumAggregateOutputType | null
    _min: WSJobApplicationEducationMinAggregateOutputType | null
    _max: WSJobApplicationEducationMaxAggregateOutputType | null
  }

  export type WSJobApplicationEducationAvgAggregateOutputType = {
    ID: number | null
    JobApplicationId: number | null
  }

  export type WSJobApplicationEducationSumAggregateOutputType = {
    ID: number | null
    JobApplicationId: number | null
  }

  export type WSJobApplicationEducationMinAggregateOutputType = {
    ID: number | null
    JobApplicationId: number | null
    EducationLevel: string | null
    Name: string | null
    Address: string | null
    FromDate: string | null
    ToDate: string | null
    IsGraduated: string | null
    IsValid: string | null
  }

  export type WSJobApplicationEducationMaxAggregateOutputType = {
    ID: number | null
    JobApplicationId: number | null
    EducationLevel: string | null
    Name: string | null
    Address: string | null
    FromDate: string | null
    ToDate: string | null
    IsGraduated: string | null
    IsValid: string | null
  }

  export type WSJobApplicationEducationCountAggregateOutputType = {
    ID: number
    JobApplicationId: number
    EducationLevel: number
    Name: number
    Address: number
    FromDate: number
    ToDate: number
    IsGraduated: number
    IsValid: number
    _all: number
  }


  export type WSJobApplicationEducationAvgAggregateInputType = {
    ID?: true
    JobApplicationId?: true
  }

  export type WSJobApplicationEducationSumAggregateInputType = {
    ID?: true
    JobApplicationId?: true
  }

  export type WSJobApplicationEducationMinAggregateInputType = {
    ID?: true
    JobApplicationId?: true
    EducationLevel?: true
    Name?: true
    Address?: true
    FromDate?: true
    ToDate?: true
    IsGraduated?: true
    IsValid?: true
  }

  export type WSJobApplicationEducationMaxAggregateInputType = {
    ID?: true
    JobApplicationId?: true
    EducationLevel?: true
    Name?: true
    Address?: true
    FromDate?: true
    ToDate?: true
    IsGraduated?: true
    IsValid?: true
  }

  export type WSJobApplicationEducationCountAggregateInputType = {
    ID?: true
    JobApplicationId?: true
    EducationLevel?: true
    Name?: true
    Address?: true
    FromDate?: true
    ToDate?: true
    IsGraduated?: true
    IsValid?: true
    _all?: true
  }

  export type WSJobApplicationEducationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WSJobApplicationEducation to aggregate.
     */
    where?: WSJobApplicationEducationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WSJobApplicationEducations to fetch.
     */
    orderBy?: WSJobApplicationEducationOrderByWithRelationInput | WSJobApplicationEducationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WSJobApplicationEducationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WSJobApplicationEducations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WSJobApplicationEducations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WSJobApplicationEducations
    **/
    _count?: true | WSJobApplicationEducationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WSJobApplicationEducationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WSJobApplicationEducationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WSJobApplicationEducationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WSJobApplicationEducationMaxAggregateInputType
  }

  export type GetWSJobApplicationEducationAggregateType<T extends WSJobApplicationEducationAggregateArgs> = {
        [P in keyof T & keyof AggregateWSJobApplicationEducation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWSJobApplicationEducation[P]>
      : GetScalarType<T[P], AggregateWSJobApplicationEducation[P]>
  }




  export type WSJobApplicationEducationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WSJobApplicationEducationWhereInput
    orderBy?: WSJobApplicationEducationOrderByWithAggregationInput | WSJobApplicationEducationOrderByWithAggregationInput[]
    by: WSJobApplicationEducationScalarFieldEnum[] | WSJobApplicationEducationScalarFieldEnum
    having?: WSJobApplicationEducationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WSJobApplicationEducationCountAggregateInputType | true
    _avg?: WSJobApplicationEducationAvgAggregateInputType
    _sum?: WSJobApplicationEducationSumAggregateInputType
    _min?: WSJobApplicationEducationMinAggregateInputType
    _max?: WSJobApplicationEducationMaxAggregateInputType
  }

  export type WSJobApplicationEducationGroupByOutputType = {
    ID: number
    JobApplicationId: number | null
    EducationLevel: string
    Name: string
    Address: string
    FromDate: string
    ToDate: string | null
    IsGraduated: string
    IsValid: string | null
    _count: WSJobApplicationEducationCountAggregateOutputType | null
    _avg: WSJobApplicationEducationAvgAggregateOutputType | null
    _sum: WSJobApplicationEducationSumAggregateOutputType | null
    _min: WSJobApplicationEducationMinAggregateOutputType | null
    _max: WSJobApplicationEducationMaxAggregateOutputType | null
  }

  type GetWSJobApplicationEducationGroupByPayload<T extends WSJobApplicationEducationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WSJobApplicationEducationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WSJobApplicationEducationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WSJobApplicationEducationGroupByOutputType[P]>
            : GetScalarType<T[P], WSJobApplicationEducationGroupByOutputType[P]>
        }
      >
    >


  export type WSJobApplicationEducationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    JobApplicationId?: boolean
    EducationLevel?: boolean
    Name?: boolean
    Address?: boolean
    FromDate?: boolean
    ToDate?: boolean
    IsGraduated?: boolean
    IsValid?: boolean
    WSJobApplication?: boolean | WSJobApplicationEducation$WSJobApplicationArgs<ExtArgs>
  }, ExtArgs["result"]["wSJobApplicationEducation"]>


  export type WSJobApplicationEducationSelectScalar = {
    ID?: boolean
    JobApplicationId?: boolean
    EducationLevel?: boolean
    Name?: boolean
    Address?: boolean
    FromDate?: boolean
    ToDate?: boolean
    IsGraduated?: boolean
    IsValid?: boolean
  }

  export type WSJobApplicationEducationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    WSJobApplication?: boolean | WSJobApplicationEducation$WSJobApplicationArgs<ExtArgs>
  }

  export type $WSJobApplicationEducationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WSJobApplicationEducation"
    objects: {
      WSJobApplication: Prisma.$WSJobApplicationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      JobApplicationId: number | null
      EducationLevel: string
      Name: string
      Address: string
      FromDate: string
      ToDate: string | null
      IsGraduated: string
      IsValid: string | null
    }, ExtArgs["result"]["wSJobApplicationEducation"]>
    composites: {}
  }

  type WSJobApplicationEducationGetPayload<S extends boolean | null | undefined | WSJobApplicationEducationDefaultArgs> = $Result.GetResult<Prisma.$WSJobApplicationEducationPayload, S>

  type WSJobApplicationEducationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WSJobApplicationEducationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WSJobApplicationEducationCountAggregateInputType | true
    }

  export interface WSJobApplicationEducationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WSJobApplicationEducation'], meta: { name: 'WSJobApplicationEducation' } }
    /**
     * Find zero or one WSJobApplicationEducation that matches the filter.
     * @param {WSJobApplicationEducationFindUniqueArgs} args - Arguments to find a WSJobApplicationEducation
     * @example
     * // Get one WSJobApplicationEducation
     * const wSJobApplicationEducation = await prisma.wSJobApplicationEducation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WSJobApplicationEducationFindUniqueArgs>(args: SelectSubset<T, WSJobApplicationEducationFindUniqueArgs<ExtArgs>>): Prisma__WSJobApplicationEducationClient<$Result.GetResult<Prisma.$WSJobApplicationEducationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WSJobApplicationEducation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WSJobApplicationEducationFindUniqueOrThrowArgs} args - Arguments to find a WSJobApplicationEducation
     * @example
     * // Get one WSJobApplicationEducation
     * const wSJobApplicationEducation = await prisma.wSJobApplicationEducation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WSJobApplicationEducationFindUniqueOrThrowArgs>(args: SelectSubset<T, WSJobApplicationEducationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WSJobApplicationEducationClient<$Result.GetResult<Prisma.$WSJobApplicationEducationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WSJobApplicationEducation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSJobApplicationEducationFindFirstArgs} args - Arguments to find a WSJobApplicationEducation
     * @example
     * // Get one WSJobApplicationEducation
     * const wSJobApplicationEducation = await prisma.wSJobApplicationEducation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WSJobApplicationEducationFindFirstArgs>(args?: SelectSubset<T, WSJobApplicationEducationFindFirstArgs<ExtArgs>>): Prisma__WSJobApplicationEducationClient<$Result.GetResult<Prisma.$WSJobApplicationEducationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WSJobApplicationEducation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSJobApplicationEducationFindFirstOrThrowArgs} args - Arguments to find a WSJobApplicationEducation
     * @example
     * // Get one WSJobApplicationEducation
     * const wSJobApplicationEducation = await prisma.wSJobApplicationEducation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WSJobApplicationEducationFindFirstOrThrowArgs>(args?: SelectSubset<T, WSJobApplicationEducationFindFirstOrThrowArgs<ExtArgs>>): Prisma__WSJobApplicationEducationClient<$Result.GetResult<Prisma.$WSJobApplicationEducationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WSJobApplicationEducations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSJobApplicationEducationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WSJobApplicationEducations
     * const wSJobApplicationEducations = await prisma.wSJobApplicationEducation.findMany()
     * 
     * // Get first 10 WSJobApplicationEducations
     * const wSJobApplicationEducations = await prisma.wSJobApplicationEducation.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const wSJobApplicationEducationWithIDOnly = await prisma.wSJobApplicationEducation.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends WSJobApplicationEducationFindManyArgs>(args?: SelectSubset<T, WSJobApplicationEducationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WSJobApplicationEducationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WSJobApplicationEducation.
     * @param {WSJobApplicationEducationCreateArgs} args - Arguments to create a WSJobApplicationEducation.
     * @example
     * // Create one WSJobApplicationEducation
     * const WSJobApplicationEducation = await prisma.wSJobApplicationEducation.create({
     *   data: {
     *     // ... data to create a WSJobApplicationEducation
     *   }
     * })
     * 
     */
    create<T extends WSJobApplicationEducationCreateArgs>(args: SelectSubset<T, WSJobApplicationEducationCreateArgs<ExtArgs>>): Prisma__WSJobApplicationEducationClient<$Result.GetResult<Prisma.$WSJobApplicationEducationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WSJobApplicationEducations.
     * @param {WSJobApplicationEducationCreateManyArgs} args - Arguments to create many WSJobApplicationEducations.
     * @example
     * // Create many WSJobApplicationEducations
     * const wSJobApplicationEducation = await prisma.wSJobApplicationEducation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WSJobApplicationEducationCreateManyArgs>(args?: SelectSubset<T, WSJobApplicationEducationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WSJobApplicationEducation.
     * @param {WSJobApplicationEducationDeleteArgs} args - Arguments to delete one WSJobApplicationEducation.
     * @example
     * // Delete one WSJobApplicationEducation
     * const WSJobApplicationEducation = await prisma.wSJobApplicationEducation.delete({
     *   where: {
     *     // ... filter to delete one WSJobApplicationEducation
     *   }
     * })
     * 
     */
    delete<T extends WSJobApplicationEducationDeleteArgs>(args: SelectSubset<T, WSJobApplicationEducationDeleteArgs<ExtArgs>>): Prisma__WSJobApplicationEducationClient<$Result.GetResult<Prisma.$WSJobApplicationEducationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WSJobApplicationEducation.
     * @param {WSJobApplicationEducationUpdateArgs} args - Arguments to update one WSJobApplicationEducation.
     * @example
     * // Update one WSJobApplicationEducation
     * const wSJobApplicationEducation = await prisma.wSJobApplicationEducation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WSJobApplicationEducationUpdateArgs>(args: SelectSubset<T, WSJobApplicationEducationUpdateArgs<ExtArgs>>): Prisma__WSJobApplicationEducationClient<$Result.GetResult<Prisma.$WSJobApplicationEducationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WSJobApplicationEducations.
     * @param {WSJobApplicationEducationDeleteManyArgs} args - Arguments to filter WSJobApplicationEducations to delete.
     * @example
     * // Delete a few WSJobApplicationEducations
     * const { count } = await prisma.wSJobApplicationEducation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WSJobApplicationEducationDeleteManyArgs>(args?: SelectSubset<T, WSJobApplicationEducationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WSJobApplicationEducations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSJobApplicationEducationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WSJobApplicationEducations
     * const wSJobApplicationEducation = await prisma.wSJobApplicationEducation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WSJobApplicationEducationUpdateManyArgs>(args: SelectSubset<T, WSJobApplicationEducationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WSJobApplicationEducation.
     * @param {WSJobApplicationEducationUpsertArgs} args - Arguments to update or create a WSJobApplicationEducation.
     * @example
     * // Update or create a WSJobApplicationEducation
     * const wSJobApplicationEducation = await prisma.wSJobApplicationEducation.upsert({
     *   create: {
     *     // ... data to create a WSJobApplicationEducation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WSJobApplicationEducation we want to update
     *   }
     * })
     */
    upsert<T extends WSJobApplicationEducationUpsertArgs>(args: SelectSubset<T, WSJobApplicationEducationUpsertArgs<ExtArgs>>): Prisma__WSJobApplicationEducationClient<$Result.GetResult<Prisma.$WSJobApplicationEducationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WSJobApplicationEducations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSJobApplicationEducationCountArgs} args - Arguments to filter WSJobApplicationEducations to count.
     * @example
     * // Count the number of WSJobApplicationEducations
     * const count = await prisma.wSJobApplicationEducation.count({
     *   where: {
     *     // ... the filter for the WSJobApplicationEducations we want to count
     *   }
     * })
    **/
    count<T extends WSJobApplicationEducationCountArgs>(
      args?: Subset<T, WSJobApplicationEducationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WSJobApplicationEducationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WSJobApplicationEducation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSJobApplicationEducationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WSJobApplicationEducationAggregateArgs>(args: Subset<T, WSJobApplicationEducationAggregateArgs>): Prisma.PrismaPromise<GetWSJobApplicationEducationAggregateType<T>>

    /**
     * Group by WSJobApplicationEducation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSJobApplicationEducationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WSJobApplicationEducationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WSJobApplicationEducationGroupByArgs['orderBy'] }
        : { orderBy?: WSJobApplicationEducationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WSJobApplicationEducationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWSJobApplicationEducationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WSJobApplicationEducation model
   */
  readonly fields: WSJobApplicationEducationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WSJobApplicationEducation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WSJobApplicationEducationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    WSJobApplication<T extends WSJobApplicationEducation$WSJobApplicationArgs<ExtArgs> = {}>(args?: Subset<T, WSJobApplicationEducation$WSJobApplicationArgs<ExtArgs>>): Prisma__WSJobApplicationClient<$Result.GetResult<Prisma.$WSJobApplicationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WSJobApplicationEducation model
   */ 
  interface WSJobApplicationEducationFieldRefs {
    readonly ID: FieldRef<"WSJobApplicationEducation", 'Int'>
    readonly JobApplicationId: FieldRef<"WSJobApplicationEducation", 'Int'>
    readonly EducationLevel: FieldRef<"WSJobApplicationEducation", 'String'>
    readonly Name: FieldRef<"WSJobApplicationEducation", 'String'>
    readonly Address: FieldRef<"WSJobApplicationEducation", 'String'>
    readonly FromDate: FieldRef<"WSJobApplicationEducation", 'String'>
    readonly ToDate: FieldRef<"WSJobApplicationEducation", 'String'>
    readonly IsGraduated: FieldRef<"WSJobApplicationEducation", 'String'>
    readonly IsValid: FieldRef<"WSJobApplicationEducation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WSJobApplicationEducation findUnique
   */
  export type WSJobApplicationEducationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJobApplicationEducation
     */
    select?: WSJobApplicationEducationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobApplicationEducationInclude<ExtArgs> | null
    /**
     * Filter, which WSJobApplicationEducation to fetch.
     */
    where: WSJobApplicationEducationWhereUniqueInput
  }

  /**
   * WSJobApplicationEducation findUniqueOrThrow
   */
  export type WSJobApplicationEducationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJobApplicationEducation
     */
    select?: WSJobApplicationEducationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobApplicationEducationInclude<ExtArgs> | null
    /**
     * Filter, which WSJobApplicationEducation to fetch.
     */
    where: WSJobApplicationEducationWhereUniqueInput
  }

  /**
   * WSJobApplicationEducation findFirst
   */
  export type WSJobApplicationEducationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJobApplicationEducation
     */
    select?: WSJobApplicationEducationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobApplicationEducationInclude<ExtArgs> | null
    /**
     * Filter, which WSJobApplicationEducation to fetch.
     */
    where?: WSJobApplicationEducationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WSJobApplicationEducations to fetch.
     */
    orderBy?: WSJobApplicationEducationOrderByWithRelationInput | WSJobApplicationEducationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WSJobApplicationEducations.
     */
    cursor?: WSJobApplicationEducationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WSJobApplicationEducations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WSJobApplicationEducations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WSJobApplicationEducations.
     */
    distinct?: WSJobApplicationEducationScalarFieldEnum | WSJobApplicationEducationScalarFieldEnum[]
  }

  /**
   * WSJobApplicationEducation findFirstOrThrow
   */
  export type WSJobApplicationEducationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJobApplicationEducation
     */
    select?: WSJobApplicationEducationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobApplicationEducationInclude<ExtArgs> | null
    /**
     * Filter, which WSJobApplicationEducation to fetch.
     */
    where?: WSJobApplicationEducationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WSJobApplicationEducations to fetch.
     */
    orderBy?: WSJobApplicationEducationOrderByWithRelationInput | WSJobApplicationEducationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WSJobApplicationEducations.
     */
    cursor?: WSJobApplicationEducationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WSJobApplicationEducations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WSJobApplicationEducations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WSJobApplicationEducations.
     */
    distinct?: WSJobApplicationEducationScalarFieldEnum | WSJobApplicationEducationScalarFieldEnum[]
  }

  /**
   * WSJobApplicationEducation findMany
   */
  export type WSJobApplicationEducationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJobApplicationEducation
     */
    select?: WSJobApplicationEducationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobApplicationEducationInclude<ExtArgs> | null
    /**
     * Filter, which WSJobApplicationEducations to fetch.
     */
    where?: WSJobApplicationEducationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WSJobApplicationEducations to fetch.
     */
    orderBy?: WSJobApplicationEducationOrderByWithRelationInput | WSJobApplicationEducationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WSJobApplicationEducations.
     */
    cursor?: WSJobApplicationEducationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WSJobApplicationEducations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WSJobApplicationEducations.
     */
    skip?: number
    distinct?: WSJobApplicationEducationScalarFieldEnum | WSJobApplicationEducationScalarFieldEnum[]
  }

  /**
   * WSJobApplicationEducation create
   */
  export type WSJobApplicationEducationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJobApplicationEducation
     */
    select?: WSJobApplicationEducationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobApplicationEducationInclude<ExtArgs> | null
    /**
     * The data needed to create a WSJobApplicationEducation.
     */
    data: XOR<WSJobApplicationEducationCreateInput, WSJobApplicationEducationUncheckedCreateInput>
  }

  /**
   * WSJobApplicationEducation createMany
   */
  export type WSJobApplicationEducationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WSJobApplicationEducations.
     */
    data: WSJobApplicationEducationCreateManyInput | WSJobApplicationEducationCreateManyInput[]
  }

  /**
   * WSJobApplicationEducation update
   */
  export type WSJobApplicationEducationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJobApplicationEducation
     */
    select?: WSJobApplicationEducationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobApplicationEducationInclude<ExtArgs> | null
    /**
     * The data needed to update a WSJobApplicationEducation.
     */
    data: XOR<WSJobApplicationEducationUpdateInput, WSJobApplicationEducationUncheckedUpdateInput>
    /**
     * Choose, which WSJobApplicationEducation to update.
     */
    where: WSJobApplicationEducationWhereUniqueInput
  }

  /**
   * WSJobApplicationEducation updateMany
   */
  export type WSJobApplicationEducationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WSJobApplicationEducations.
     */
    data: XOR<WSJobApplicationEducationUpdateManyMutationInput, WSJobApplicationEducationUncheckedUpdateManyInput>
    /**
     * Filter which WSJobApplicationEducations to update
     */
    where?: WSJobApplicationEducationWhereInput
  }

  /**
   * WSJobApplicationEducation upsert
   */
  export type WSJobApplicationEducationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJobApplicationEducation
     */
    select?: WSJobApplicationEducationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobApplicationEducationInclude<ExtArgs> | null
    /**
     * The filter to search for the WSJobApplicationEducation to update in case it exists.
     */
    where: WSJobApplicationEducationWhereUniqueInput
    /**
     * In case the WSJobApplicationEducation found by the `where` argument doesn't exist, create a new WSJobApplicationEducation with this data.
     */
    create: XOR<WSJobApplicationEducationCreateInput, WSJobApplicationEducationUncheckedCreateInput>
    /**
     * In case the WSJobApplicationEducation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WSJobApplicationEducationUpdateInput, WSJobApplicationEducationUncheckedUpdateInput>
  }

  /**
   * WSJobApplicationEducation delete
   */
  export type WSJobApplicationEducationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJobApplicationEducation
     */
    select?: WSJobApplicationEducationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobApplicationEducationInclude<ExtArgs> | null
    /**
     * Filter which WSJobApplicationEducation to delete.
     */
    where: WSJobApplicationEducationWhereUniqueInput
  }

  /**
   * WSJobApplicationEducation deleteMany
   */
  export type WSJobApplicationEducationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WSJobApplicationEducations to delete
     */
    where?: WSJobApplicationEducationWhereInput
  }

  /**
   * WSJobApplicationEducation.WSJobApplication
   */
  export type WSJobApplicationEducation$WSJobApplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJobApplication
     */
    select?: WSJobApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobApplicationInclude<ExtArgs> | null
    where?: WSJobApplicationWhereInput
  }

  /**
   * WSJobApplicationEducation without action
   */
  export type WSJobApplicationEducationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJobApplicationEducation
     */
    select?: WSJobApplicationEducationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobApplicationEducationInclude<ExtArgs> | null
  }


  /**
   * Model WSJobApplicationFeedback
   */

  export type AggregateWSJobApplicationFeedback = {
    _count: WSJobApplicationFeedbackCountAggregateOutputType | null
    _avg: WSJobApplicationFeedbackAvgAggregateOutputType | null
    _sum: WSJobApplicationFeedbackSumAggregateOutputType | null
    _min: WSJobApplicationFeedbackMinAggregateOutputType | null
    _max: WSJobApplicationFeedbackMaxAggregateOutputType | null
  }

  export type WSJobApplicationFeedbackAvgAggregateOutputType = {
    ID: number | null
    JobApplicationID: number | null
  }

  export type WSJobApplicationFeedbackSumAggregateOutputType = {
    ID: number | null
    JobApplicationID: number | null
  }

  export type WSJobApplicationFeedbackMinAggregateOutputType = {
    ID: number | null
    JobApplicationID: number | null
    Feedback: string | null
    CreatedBy: string | null
    CreatedOn: Date | null
  }

  export type WSJobApplicationFeedbackMaxAggregateOutputType = {
    ID: number | null
    JobApplicationID: number | null
    Feedback: string | null
    CreatedBy: string | null
    CreatedOn: Date | null
  }

  export type WSJobApplicationFeedbackCountAggregateOutputType = {
    ID: number
    JobApplicationID: number
    Feedback: number
    CreatedBy: number
    CreatedOn: number
    _all: number
  }


  export type WSJobApplicationFeedbackAvgAggregateInputType = {
    ID?: true
    JobApplicationID?: true
  }

  export type WSJobApplicationFeedbackSumAggregateInputType = {
    ID?: true
    JobApplicationID?: true
  }

  export type WSJobApplicationFeedbackMinAggregateInputType = {
    ID?: true
    JobApplicationID?: true
    Feedback?: true
    CreatedBy?: true
    CreatedOn?: true
  }

  export type WSJobApplicationFeedbackMaxAggregateInputType = {
    ID?: true
    JobApplicationID?: true
    Feedback?: true
    CreatedBy?: true
    CreatedOn?: true
  }

  export type WSJobApplicationFeedbackCountAggregateInputType = {
    ID?: true
    JobApplicationID?: true
    Feedback?: true
    CreatedBy?: true
    CreatedOn?: true
    _all?: true
  }

  export type WSJobApplicationFeedbackAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WSJobApplicationFeedback to aggregate.
     */
    where?: WSJobApplicationFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WSJobApplicationFeedbacks to fetch.
     */
    orderBy?: WSJobApplicationFeedbackOrderByWithRelationInput | WSJobApplicationFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WSJobApplicationFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WSJobApplicationFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WSJobApplicationFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WSJobApplicationFeedbacks
    **/
    _count?: true | WSJobApplicationFeedbackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WSJobApplicationFeedbackAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WSJobApplicationFeedbackSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WSJobApplicationFeedbackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WSJobApplicationFeedbackMaxAggregateInputType
  }

  export type GetWSJobApplicationFeedbackAggregateType<T extends WSJobApplicationFeedbackAggregateArgs> = {
        [P in keyof T & keyof AggregateWSJobApplicationFeedback]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWSJobApplicationFeedback[P]>
      : GetScalarType<T[P], AggregateWSJobApplicationFeedback[P]>
  }




  export type WSJobApplicationFeedbackGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WSJobApplicationFeedbackWhereInput
    orderBy?: WSJobApplicationFeedbackOrderByWithAggregationInput | WSJobApplicationFeedbackOrderByWithAggregationInput[]
    by: WSJobApplicationFeedbackScalarFieldEnum[] | WSJobApplicationFeedbackScalarFieldEnum
    having?: WSJobApplicationFeedbackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WSJobApplicationFeedbackCountAggregateInputType | true
    _avg?: WSJobApplicationFeedbackAvgAggregateInputType
    _sum?: WSJobApplicationFeedbackSumAggregateInputType
    _min?: WSJobApplicationFeedbackMinAggregateInputType
    _max?: WSJobApplicationFeedbackMaxAggregateInputType
  }

  export type WSJobApplicationFeedbackGroupByOutputType = {
    ID: number
    JobApplicationID: number
    Feedback: string
    CreatedBy: string
    CreatedOn: Date
    _count: WSJobApplicationFeedbackCountAggregateOutputType | null
    _avg: WSJobApplicationFeedbackAvgAggregateOutputType | null
    _sum: WSJobApplicationFeedbackSumAggregateOutputType | null
    _min: WSJobApplicationFeedbackMinAggregateOutputType | null
    _max: WSJobApplicationFeedbackMaxAggregateOutputType | null
  }

  type GetWSJobApplicationFeedbackGroupByPayload<T extends WSJobApplicationFeedbackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WSJobApplicationFeedbackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WSJobApplicationFeedbackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WSJobApplicationFeedbackGroupByOutputType[P]>
            : GetScalarType<T[P], WSJobApplicationFeedbackGroupByOutputType[P]>
        }
      >
    >


  export type WSJobApplicationFeedbackSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    JobApplicationID?: boolean
    Feedback?: boolean
    CreatedBy?: boolean
    CreatedOn?: boolean
    WSJobApplication?: boolean | WSJobApplicationDefaultArgs<ExtArgs>
    WsJobApplicationReply?: boolean | WSJobApplicationFeedback$WsJobApplicationReplyArgs<ExtArgs>
    _count?: boolean | WSJobApplicationFeedbackCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wSJobApplicationFeedback"]>


  export type WSJobApplicationFeedbackSelectScalar = {
    ID?: boolean
    JobApplicationID?: boolean
    Feedback?: boolean
    CreatedBy?: boolean
    CreatedOn?: boolean
  }

  export type WSJobApplicationFeedbackInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    WSJobApplication?: boolean | WSJobApplicationDefaultArgs<ExtArgs>
    WsJobApplicationReply?: boolean | WSJobApplicationFeedback$WsJobApplicationReplyArgs<ExtArgs>
    _count?: boolean | WSJobApplicationFeedbackCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $WSJobApplicationFeedbackPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WSJobApplicationFeedback"
    objects: {
      WSJobApplication: Prisma.$WSJobApplicationPayload<ExtArgs>
      WsJobApplicationReply: Prisma.$WsJobApplicationReplyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      JobApplicationID: number
      Feedback: string
      CreatedBy: string
      CreatedOn: Date
    }, ExtArgs["result"]["wSJobApplicationFeedback"]>
    composites: {}
  }

  type WSJobApplicationFeedbackGetPayload<S extends boolean | null | undefined | WSJobApplicationFeedbackDefaultArgs> = $Result.GetResult<Prisma.$WSJobApplicationFeedbackPayload, S>

  type WSJobApplicationFeedbackCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WSJobApplicationFeedbackFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WSJobApplicationFeedbackCountAggregateInputType | true
    }

  export interface WSJobApplicationFeedbackDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WSJobApplicationFeedback'], meta: { name: 'WSJobApplicationFeedback' } }
    /**
     * Find zero or one WSJobApplicationFeedback that matches the filter.
     * @param {WSJobApplicationFeedbackFindUniqueArgs} args - Arguments to find a WSJobApplicationFeedback
     * @example
     * // Get one WSJobApplicationFeedback
     * const wSJobApplicationFeedback = await prisma.wSJobApplicationFeedback.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WSJobApplicationFeedbackFindUniqueArgs>(args: SelectSubset<T, WSJobApplicationFeedbackFindUniqueArgs<ExtArgs>>): Prisma__WSJobApplicationFeedbackClient<$Result.GetResult<Prisma.$WSJobApplicationFeedbackPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WSJobApplicationFeedback that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WSJobApplicationFeedbackFindUniqueOrThrowArgs} args - Arguments to find a WSJobApplicationFeedback
     * @example
     * // Get one WSJobApplicationFeedback
     * const wSJobApplicationFeedback = await prisma.wSJobApplicationFeedback.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WSJobApplicationFeedbackFindUniqueOrThrowArgs>(args: SelectSubset<T, WSJobApplicationFeedbackFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WSJobApplicationFeedbackClient<$Result.GetResult<Prisma.$WSJobApplicationFeedbackPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WSJobApplicationFeedback that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSJobApplicationFeedbackFindFirstArgs} args - Arguments to find a WSJobApplicationFeedback
     * @example
     * // Get one WSJobApplicationFeedback
     * const wSJobApplicationFeedback = await prisma.wSJobApplicationFeedback.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WSJobApplicationFeedbackFindFirstArgs>(args?: SelectSubset<T, WSJobApplicationFeedbackFindFirstArgs<ExtArgs>>): Prisma__WSJobApplicationFeedbackClient<$Result.GetResult<Prisma.$WSJobApplicationFeedbackPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WSJobApplicationFeedback that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSJobApplicationFeedbackFindFirstOrThrowArgs} args - Arguments to find a WSJobApplicationFeedback
     * @example
     * // Get one WSJobApplicationFeedback
     * const wSJobApplicationFeedback = await prisma.wSJobApplicationFeedback.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WSJobApplicationFeedbackFindFirstOrThrowArgs>(args?: SelectSubset<T, WSJobApplicationFeedbackFindFirstOrThrowArgs<ExtArgs>>): Prisma__WSJobApplicationFeedbackClient<$Result.GetResult<Prisma.$WSJobApplicationFeedbackPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WSJobApplicationFeedbacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSJobApplicationFeedbackFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WSJobApplicationFeedbacks
     * const wSJobApplicationFeedbacks = await prisma.wSJobApplicationFeedback.findMany()
     * 
     * // Get first 10 WSJobApplicationFeedbacks
     * const wSJobApplicationFeedbacks = await prisma.wSJobApplicationFeedback.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const wSJobApplicationFeedbackWithIDOnly = await prisma.wSJobApplicationFeedback.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends WSJobApplicationFeedbackFindManyArgs>(args?: SelectSubset<T, WSJobApplicationFeedbackFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WSJobApplicationFeedbackPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WSJobApplicationFeedback.
     * @param {WSJobApplicationFeedbackCreateArgs} args - Arguments to create a WSJobApplicationFeedback.
     * @example
     * // Create one WSJobApplicationFeedback
     * const WSJobApplicationFeedback = await prisma.wSJobApplicationFeedback.create({
     *   data: {
     *     // ... data to create a WSJobApplicationFeedback
     *   }
     * })
     * 
     */
    create<T extends WSJobApplicationFeedbackCreateArgs>(args: SelectSubset<T, WSJobApplicationFeedbackCreateArgs<ExtArgs>>): Prisma__WSJobApplicationFeedbackClient<$Result.GetResult<Prisma.$WSJobApplicationFeedbackPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WSJobApplicationFeedbacks.
     * @param {WSJobApplicationFeedbackCreateManyArgs} args - Arguments to create many WSJobApplicationFeedbacks.
     * @example
     * // Create many WSJobApplicationFeedbacks
     * const wSJobApplicationFeedback = await prisma.wSJobApplicationFeedback.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WSJobApplicationFeedbackCreateManyArgs>(args?: SelectSubset<T, WSJobApplicationFeedbackCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WSJobApplicationFeedback.
     * @param {WSJobApplicationFeedbackDeleteArgs} args - Arguments to delete one WSJobApplicationFeedback.
     * @example
     * // Delete one WSJobApplicationFeedback
     * const WSJobApplicationFeedback = await prisma.wSJobApplicationFeedback.delete({
     *   where: {
     *     // ... filter to delete one WSJobApplicationFeedback
     *   }
     * })
     * 
     */
    delete<T extends WSJobApplicationFeedbackDeleteArgs>(args: SelectSubset<T, WSJobApplicationFeedbackDeleteArgs<ExtArgs>>): Prisma__WSJobApplicationFeedbackClient<$Result.GetResult<Prisma.$WSJobApplicationFeedbackPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WSJobApplicationFeedback.
     * @param {WSJobApplicationFeedbackUpdateArgs} args - Arguments to update one WSJobApplicationFeedback.
     * @example
     * // Update one WSJobApplicationFeedback
     * const wSJobApplicationFeedback = await prisma.wSJobApplicationFeedback.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WSJobApplicationFeedbackUpdateArgs>(args: SelectSubset<T, WSJobApplicationFeedbackUpdateArgs<ExtArgs>>): Prisma__WSJobApplicationFeedbackClient<$Result.GetResult<Prisma.$WSJobApplicationFeedbackPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WSJobApplicationFeedbacks.
     * @param {WSJobApplicationFeedbackDeleteManyArgs} args - Arguments to filter WSJobApplicationFeedbacks to delete.
     * @example
     * // Delete a few WSJobApplicationFeedbacks
     * const { count } = await prisma.wSJobApplicationFeedback.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WSJobApplicationFeedbackDeleteManyArgs>(args?: SelectSubset<T, WSJobApplicationFeedbackDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WSJobApplicationFeedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSJobApplicationFeedbackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WSJobApplicationFeedbacks
     * const wSJobApplicationFeedback = await prisma.wSJobApplicationFeedback.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WSJobApplicationFeedbackUpdateManyArgs>(args: SelectSubset<T, WSJobApplicationFeedbackUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WSJobApplicationFeedback.
     * @param {WSJobApplicationFeedbackUpsertArgs} args - Arguments to update or create a WSJobApplicationFeedback.
     * @example
     * // Update or create a WSJobApplicationFeedback
     * const wSJobApplicationFeedback = await prisma.wSJobApplicationFeedback.upsert({
     *   create: {
     *     // ... data to create a WSJobApplicationFeedback
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WSJobApplicationFeedback we want to update
     *   }
     * })
     */
    upsert<T extends WSJobApplicationFeedbackUpsertArgs>(args: SelectSubset<T, WSJobApplicationFeedbackUpsertArgs<ExtArgs>>): Prisma__WSJobApplicationFeedbackClient<$Result.GetResult<Prisma.$WSJobApplicationFeedbackPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WSJobApplicationFeedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSJobApplicationFeedbackCountArgs} args - Arguments to filter WSJobApplicationFeedbacks to count.
     * @example
     * // Count the number of WSJobApplicationFeedbacks
     * const count = await prisma.wSJobApplicationFeedback.count({
     *   where: {
     *     // ... the filter for the WSJobApplicationFeedbacks we want to count
     *   }
     * })
    **/
    count<T extends WSJobApplicationFeedbackCountArgs>(
      args?: Subset<T, WSJobApplicationFeedbackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WSJobApplicationFeedbackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WSJobApplicationFeedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSJobApplicationFeedbackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WSJobApplicationFeedbackAggregateArgs>(args: Subset<T, WSJobApplicationFeedbackAggregateArgs>): Prisma.PrismaPromise<GetWSJobApplicationFeedbackAggregateType<T>>

    /**
     * Group by WSJobApplicationFeedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSJobApplicationFeedbackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WSJobApplicationFeedbackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WSJobApplicationFeedbackGroupByArgs['orderBy'] }
        : { orderBy?: WSJobApplicationFeedbackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WSJobApplicationFeedbackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWSJobApplicationFeedbackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WSJobApplicationFeedback model
   */
  readonly fields: WSJobApplicationFeedbackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WSJobApplicationFeedback.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WSJobApplicationFeedbackClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    WSJobApplication<T extends WSJobApplicationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WSJobApplicationDefaultArgs<ExtArgs>>): Prisma__WSJobApplicationClient<$Result.GetResult<Prisma.$WSJobApplicationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    WsJobApplicationReply<T extends WSJobApplicationFeedback$WsJobApplicationReplyArgs<ExtArgs> = {}>(args?: Subset<T, WSJobApplicationFeedback$WsJobApplicationReplyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WsJobApplicationReplyPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WSJobApplicationFeedback model
   */ 
  interface WSJobApplicationFeedbackFieldRefs {
    readonly ID: FieldRef<"WSJobApplicationFeedback", 'Int'>
    readonly JobApplicationID: FieldRef<"WSJobApplicationFeedback", 'Int'>
    readonly Feedback: FieldRef<"WSJobApplicationFeedback", 'String'>
    readonly CreatedBy: FieldRef<"WSJobApplicationFeedback", 'String'>
    readonly CreatedOn: FieldRef<"WSJobApplicationFeedback", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WSJobApplicationFeedback findUnique
   */
  export type WSJobApplicationFeedbackFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJobApplicationFeedback
     */
    select?: WSJobApplicationFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobApplicationFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which WSJobApplicationFeedback to fetch.
     */
    where: WSJobApplicationFeedbackWhereUniqueInput
  }

  /**
   * WSJobApplicationFeedback findUniqueOrThrow
   */
  export type WSJobApplicationFeedbackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJobApplicationFeedback
     */
    select?: WSJobApplicationFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobApplicationFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which WSJobApplicationFeedback to fetch.
     */
    where: WSJobApplicationFeedbackWhereUniqueInput
  }

  /**
   * WSJobApplicationFeedback findFirst
   */
  export type WSJobApplicationFeedbackFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJobApplicationFeedback
     */
    select?: WSJobApplicationFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobApplicationFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which WSJobApplicationFeedback to fetch.
     */
    where?: WSJobApplicationFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WSJobApplicationFeedbacks to fetch.
     */
    orderBy?: WSJobApplicationFeedbackOrderByWithRelationInput | WSJobApplicationFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WSJobApplicationFeedbacks.
     */
    cursor?: WSJobApplicationFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WSJobApplicationFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WSJobApplicationFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WSJobApplicationFeedbacks.
     */
    distinct?: WSJobApplicationFeedbackScalarFieldEnum | WSJobApplicationFeedbackScalarFieldEnum[]
  }

  /**
   * WSJobApplicationFeedback findFirstOrThrow
   */
  export type WSJobApplicationFeedbackFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJobApplicationFeedback
     */
    select?: WSJobApplicationFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobApplicationFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which WSJobApplicationFeedback to fetch.
     */
    where?: WSJobApplicationFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WSJobApplicationFeedbacks to fetch.
     */
    orderBy?: WSJobApplicationFeedbackOrderByWithRelationInput | WSJobApplicationFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WSJobApplicationFeedbacks.
     */
    cursor?: WSJobApplicationFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WSJobApplicationFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WSJobApplicationFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WSJobApplicationFeedbacks.
     */
    distinct?: WSJobApplicationFeedbackScalarFieldEnum | WSJobApplicationFeedbackScalarFieldEnum[]
  }

  /**
   * WSJobApplicationFeedback findMany
   */
  export type WSJobApplicationFeedbackFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJobApplicationFeedback
     */
    select?: WSJobApplicationFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobApplicationFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which WSJobApplicationFeedbacks to fetch.
     */
    where?: WSJobApplicationFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WSJobApplicationFeedbacks to fetch.
     */
    orderBy?: WSJobApplicationFeedbackOrderByWithRelationInput | WSJobApplicationFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WSJobApplicationFeedbacks.
     */
    cursor?: WSJobApplicationFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WSJobApplicationFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WSJobApplicationFeedbacks.
     */
    skip?: number
    distinct?: WSJobApplicationFeedbackScalarFieldEnum | WSJobApplicationFeedbackScalarFieldEnum[]
  }

  /**
   * WSJobApplicationFeedback create
   */
  export type WSJobApplicationFeedbackCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJobApplicationFeedback
     */
    select?: WSJobApplicationFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobApplicationFeedbackInclude<ExtArgs> | null
    /**
     * The data needed to create a WSJobApplicationFeedback.
     */
    data: XOR<WSJobApplicationFeedbackCreateInput, WSJobApplicationFeedbackUncheckedCreateInput>
  }

  /**
   * WSJobApplicationFeedback createMany
   */
  export type WSJobApplicationFeedbackCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WSJobApplicationFeedbacks.
     */
    data: WSJobApplicationFeedbackCreateManyInput | WSJobApplicationFeedbackCreateManyInput[]
  }

  /**
   * WSJobApplicationFeedback update
   */
  export type WSJobApplicationFeedbackUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJobApplicationFeedback
     */
    select?: WSJobApplicationFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobApplicationFeedbackInclude<ExtArgs> | null
    /**
     * The data needed to update a WSJobApplicationFeedback.
     */
    data: XOR<WSJobApplicationFeedbackUpdateInput, WSJobApplicationFeedbackUncheckedUpdateInput>
    /**
     * Choose, which WSJobApplicationFeedback to update.
     */
    where: WSJobApplicationFeedbackWhereUniqueInput
  }

  /**
   * WSJobApplicationFeedback updateMany
   */
  export type WSJobApplicationFeedbackUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WSJobApplicationFeedbacks.
     */
    data: XOR<WSJobApplicationFeedbackUpdateManyMutationInput, WSJobApplicationFeedbackUncheckedUpdateManyInput>
    /**
     * Filter which WSJobApplicationFeedbacks to update
     */
    where?: WSJobApplicationFeedbackWhereInput
  }

  /**
   * WSJobApplicationFeedback upsert
   */
  export type WSJobApplicationFeedbackUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJobApplicationFeedback
     */
    select?: WSJobApplicationFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobApplicationFeedbackInclude<ExtArgs> | null
    /**
     * The filter to search for the WSJobApplicationFeedback to update in case it exists.
     */
    where: WSJobApplicationFeedbackWhereUniqueInput
    /**
     * In case the WSJobApplicationFeedback found by the `where` argument doesn't exist, create a new WSJobApplicationFeedback with this data.
     */
    create: XOR<WSJobApplicationFeedbackCreateInput, WSJobApplicationFeedbackUncheckedCreateInput>
    /**
     * In case the WSJobApplicationFeedback was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WSJobApplicationFeedbackUpdateInput, WSJobApplicationFeedbackUncheckedUpdateInput>
  }

  /**
   * WSJobApplicationFeedback delete
   */
  export type WSJobApplicationFeedbackDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJobApplicationFeedback
     */
    select?: WSJobApplicationFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobApplicationFeedbackInclude<ExtArgs> | null
    /**
     * Filter which WSJobApplicationFeedback to delete.
     */
    where: WSJobApplicationFeedbackWhereUniqueInput
  }

  /**
   * WSJobApplicationFeedback deleteMany
   */
  export type WSJobApplicationFeedbackDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WSJobApplicationFeedbacks to delete
     */
    where?: WSJobApplicationFeedbackWhereInput
  }

  /**
   * WSJobApplicationFeedback.WsJobApplicationReply
   */
  export type WSJobApplicationFeedback$WsJobApplicationReplyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsJobApplicationReply
     */
    select?: WsJobApplicationReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WsJobApplicationReplyInclude<ExtArgs> | null
    where?: WsJobApplicationReplyWhereInput
    orderBy?: WsJobApplicationReplyOrderByWithRelationInput | WsJobApplicationReplyOrderByWithRelationInput[]
    cursor?: WsJobApplicationReplyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WsJobApplicationReplyScalarFieldEnum | WsJobApplicationReplyScalarFieldEnum[]
  }

  /**
   * WSJobApplicationFeedback without action
   */
  export type WSJobApplicationFeedbackDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJobApplicationFeedback
     */
    select?: WSJobApplicationFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobApplicationFeedbackInclude<ExtArgs> | null
  }


  /**
   * Model WSJobApplicationPreviousEmployment
   */

  export type AggregateWSJobApplicationPreviousEmployment = {
    _count: WSJobApplicationPreviousEmploymentCountAggregateOutputType | null
    _avg: WSJobApplicationPreviousEmploymentAvgAggregateOutputType | null
    _sum: WSJobApplicationPreviousEmploymentSumAggregateOutputType | null
    _min: WSJobApplicationPreviousEmploymentMinAggregateOutputType | null
    _max: WSJobApplicationPreviousEmploymentMaxAggregateOutputType | null
  }

  export type WSJobApplicationPreviousEmploymentAvgAggregateOutputType = {
    ID: number | null
    JobApplicationId: number | null
    EndingSalary: number | null
  }

  export type WSJobApplicationPreviousEmploymentSumAggregateOutputType = {
    ID: number | null
    JobApplicationId: number | null
    EndingSalary: number | null
  }

  export type WSJobApplicationPreviousEmploymentMinAggregateOutputType = {
    ID: number | null
    JobApplicationId: number | null
    Company: string | null
    Supervisor: string | null
    Address: string | null
    FromDate: Date | null
    ToDate: Date | null
    JobTitle: string | null
    EndingSalary: number | null
    IsHourlyRate: string | null
    LeavingReason: string | null
    IsValid: string | null
  }

  export type WSJobApplicationPreviousEmploymentMaxAggregateOutputType = {
    ID: number | null
    JobApplicationId: number | null
    Company: string | null
    Supervisor: string | null
    Address: string | null
    FromDate: Date | null
    ToDate: Date | null
    JobTitle: string | null
    EndingSalary: number | null
    IsHourlyRate: string | null
    LeavingReason: string | null
    IsValid: string | null
  }

  export type WSJobApplicationPreviousEmploymentCountAggregateOutputType = {
    ID: number
    JobApplicationId: number
    Company: number
    Supervisor: number
    Address: number
    FromDate: number
    ToDate: number
    JobTitle: number
    EndingSalary: number
    IsHourlyRate: number
    LeavingReason: number
    IsValid: number
    _all: number
  }


  export type WSJobApplicationPreviousEmploymentAvgAggregateInputType = {
    ID?: true
    JobApplicationId?: true
    EndingSalary?: true
  }

  export type WSJobApplicationPreviousEmploymentSumAggregateInputType = {
    ID?: true
    JobApplicationId?: true
    EndingSalary?: true
  }

  export type WSJobApplicationPreviousEmploymentMinAggregateInputType = {
    ID?: true
    JobApplicationId?: true
    Company?: true
    Supervisor?: true
    Address?: true
    FromDate?: true
    ToDate?: true
    JobTitle?: true
    EndingSalary?: true
    IsHourlyRate?: true
    LeavingReason?: true
    IsValid?: true
  }

  export type WSJobApplicationPreviousEmploymentMaxAggregateInputType = {
    ID?: true
    JobApplicationId?: true
    Company?: true
    Supervisor?: true
    Address?: true
    FromDate?: true
    ToDate?: true
    JobTitle?: true
    EndingSalary?: true
    IsHourlyRate?: true
    LeavingReason?: true
    IsValid?: true
  }

  export type WSJobApplicationPreviousEmploymentCountAggregateInputType = {
    ID?: true
    JobApplicationId?: true
    Company?: true
    Supervisor?: true
    Address?: true
    FromDate?: true
    ToDate?: true
    JobTitle?: true
    EndingSalary?: true
    IsHourlyRate?: true
    LeavingReason?: true
    IsValid?: true
    _all?: true
  }

  export type WSJobApplicationPreviousEmploymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WSJobApplicationPreviousEmployment to aggregate.
     */
    where?: WSJobApplicationPreviousEmploymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WSJobApplicationPreviousEmployments to fetch.
     */
    orderBy?: WSJobApplicationPreviousEmploymentOrderByWithRelationInput | WSJobApplicationPreviousEmploymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WSJobApplicationPreviousEmploymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WSJobApplicationPreviousEmployments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WSJobApplicationPreviousEmployments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WSJobApplicationPreviousEmployments
    **/
    _count?: true | WSJobApplicationPreviousEmploymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WSJobApplicationPreviousEmploymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WSJobApplicationPreviousEmploymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WSJobApplicationPreviousEmploymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WSJobApplicationPreviousEmploymentMaxAggregateInputType
  }

  export type GetWSJobApplicationPreviousEmploymentAggregateType<T extends WSJobApplicationPreviousEmploymentAggregateArgs> = {
        [P in keyof T & keyof AggregateWSJobApplicationPreviousEmployment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWSJobApplicationPreviousEmployment[P]>
      : GetScalarType<T[P], AggregateWSJobApplicationPreviousEmployment[P]>
  }




  export type WSJobApplicationPreviousEmploymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WSJobApplicationPreviousEmploymentWhereInput
    orderBy?: WSJobApplicationPreviousEmploymentOrderByWithAggregationInput | WSJobApplicationPreviousEmploymentOrderByWithAggregationInput[]
    by: WSJobApplicationPreviousEmploymentScalarFieldEnum[] | WSJobApplicationPreviousEmploymentScalarFieldEnum
    having?: WSJobApplicationPreviousEmploymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WSJobApplicationPreviousEmploymentCountAggregateInputType | true
    _avg?: WSJobApplicationPreviousEmploymentAvgAggregateInputType
    _sum?: WSJobApplicationPreviousEmploymentSumAggregateInputType
    _min?: WSJobApplicationPreviousEmploymentMinAggregateInputType
    _max?: WSJobApplicationPreviousEmploymentMaxAggregateInputType
  }

  export type WSJobApplicationPreviousEmploymentGroupByOutputType = {
    ID: number
    JobApplicationId: number | null
    Company: string
    Supervisor: string
    Address: string
    FromDate: Date
    ToDate: Date | null
    JobTitle: string
    EndingSalary: number | null
    IsHourlyRate: string | null
    LeavingReason: string | null
    IsValid: string | null
    _count: WSJobApplicationPreviousEmploymentCountAggregateOutputType | null
    _avg: WSJobApplicationPreviousEmploymentAvgAggregateOutputType | null
    _sum: WSJobApplicationPreviousEmploymentSumAggregateOutputType | null
    _min: WSJobApplicationPreviousEmploymentMinAggregateOutputType | null
    _max: WSJobApplicationPreviousEmploymentMaxAggregateOutputType | null
  }

  type GetWSJobApplicationPreviousEmploymentGroupByPayload<T extends WSJobApplicationPreviousEmploymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WSJobApplicationPreviousEmploymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WSJobApplicationPreviousEmploymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WSJobApplicationPreviousEmploymentGroupByOutputType[P]>
            : GetScalarType<T[P], WSJobApplicationPreviousEmploymentGroupByOutputType[P]>
        }
      >
    >


  export type WSJobApplicationPreviousEmploymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    JobApplicationId?: boolean
    Company?: boolean
    Supervisor?: boolean
    Address?: boolean
    FromDate?: boolean
    ToDate?: boolean
    JobTitle?: boolean
    EndingSalary?: boolean
    IsHourlyRate?: boolean
    LeavingReason?: boolean
    IsValid?: boolean
    WSJobApplication?: boolean | WSJobApplicationPreviousEmployment$WSJobApplicationArgs<ExtArgs>
  }, ExtArgs["result"]["wSJobApplicationPreviousEmployment"]>


  export type WSJobApplicationPreviousEmploymentSelectScalar = {
    ID?: boolean
    JobApplicationId?: boolean
    Company?: boolean
    Supervisor?: boolean
    Address?: boolean
    FromDate?: boolean
    ToDate?: boolean
    JobTitle?: boolean
    EndingSalary?: boolean
    IsHourlyRate?: boolean
    LeavingReason?: boolean
    IsValid?: boolean
  }

  export type WSJobApplicationPreviousEmploymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    WSJobApplication?: boolean | WSJobApplicationPreviousEmployment$WSJobApplicationArgs<ExtArgs>
  }

  export type $WSJobApplicationPreviousEmploymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WSJobApplicationPreviousEmployment"
    objects: {
      WSJobApplication: Prisma.$WSJobApplicationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      JobApplicationId: number | null
      Company: string
      Supervisor: string
      Address: string
      FromDate: Date
      ToDate: Date | null
      JobTitle: string
      EndingSalary: number | null
      IsHourlyRate: string | null
      LeavingReason: string | null
      IsValid: string | null
    }, ExtArgs["result"]["wSJobApplicationPreviousEmployment"]>
    composites: {}
  }

  type WSJobApplicationPreviousEmploymentGetPayload<S extends boolean | null | undefined | WSJobApplicationPreviousEmploymentDefaultArgs> = $Result.GetResult<Prisma.$WSJobApplicationPreviousEmploymentPayload, S>

  type WSJobApplicationPreviousEmploymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WSJobApplicationPreviousEmploymentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WSJobApplicationPreviousEmploymentCountAggregateInputType | true
    }

  export interface WSJobApplicationPreviousEmploymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WSJobApplicationPreviousEmployment'], meta: { name: 'WSJobApplicationPreviousEmployment' } }
    /**
     * Find zero or one WSJobApplicationPreviousEmployment that matches the filter.
     * @param {WSJobApplicationPreviousEmploymentFindUniqueArgs} args - Arguments to find a WSJobApplicationPreviousEmployment
     * @example
     * // Get one WSJobApplicationPreviousEmployment
     * const wSJobApplicationPreviousEmployment = await prisma.wSJobApplicationPreviousEmployment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WSJobApplicationPreviousEmploymentFindUniqueArgs>(args: SelectSubset<T, WSJobApplicationPreviousEmploymentFindUniqueArgs<ExtArgs>>): Prisma__WSJobApplicationPreviousEmploymentClient<$Result.GetResult<Prisma.$WSJobApplicationPreviousEmploymentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WSJobApplicationPreviousEmployment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WSJobApplicationPreviousEmploymentFindUniqueOrThrowArgs} args - Arguments to find a WSJobApplicationPreviousEmployment
     * @example
     * // Get one WSJobApplicationPreviousEmployment
     * const wSJobApplicationPreviousEmployment = await prisma.wSJobApplicationPreviousEmployment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WSJobApplicationPreviousEmploymentFindUniqueOrThrowArgs>(args: SelectSubset<T, WSJobApplicationPreviousEmploymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WSJobApplicationPreviousEmploymentClient<$Result.GetResult<Prisma.$WSJobApplicationPreviousEmploymentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WSJobApplicationPreviousEmployment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSJobApplicationPreviousEmploymentFindFirstArgs} args - Arguments to find a WSJobApplicationPreviousEmployment
     * @example
     * // Get one WSJobApplicationPreviousEmployment
     * const wSJobApplicationPreviousEmployment = await prisma.wSJobApplicationPreviousEmployment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WSJobApplicationPreviousEmploymentFindFirstArgs>(args?: SelectSubset<T, WSJobApplicationPreviousEmploymentFindFirstArgs<ExtArgs>>): Prisma__WSJobApplicationPreviousEmploymentClient<$Result.GetResult<Prisma.$WSJobApplicationPreviousEmploymentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WSJobApplicationPreviousEmployment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSJobApplicationPreviousEmploymentFindFirstOrThrowArgs} args - Arguments to find a WSJobApplicationPreviousEmployment
     * @example
     * // Get one WSJobApplicationPreviousEmployment
     * const wSJobApplicationPreviousEmployment = await prisma.wSJobApplicationPreviousEmployment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WSJobApplicationPreviousEmploymentFindFirstOrThrowArgs>(args?: SelectSubset<T, WSJobApplicationPreviousEmploymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__WSJobApplicationPreviousEmploymentClient<$Result.GetResult<Prisma.$WSJobApplicationPreviousEmploymentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WSJobApplicationPreviousEmployments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSJobApplicationPreviousEmploymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WSJobApplicationPreviousEmployments
     * const wSJobApplicationPreviousEmployments = await prisma.wSJobApplicationPreviousEmployment.findMany()
     * 
     * // Get first 10 WSJobApplicationPreviousEmployments
     * const wSJobApplicationPreviousEmployments = await prisma.wSJobApplicationPreviousEmployment.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const wSJobApplicationPreviousEmploymentWithIDOnly = await prisma.wSJobApplicationPreviousEmployment.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends WSJobApplicationPreviousEmploymentFindManyArgs>(args?: SelectSubset<T, WSJobApplicationPreviousEmploymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WSJobApplicationPreviousEmploymentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WSJobApplicationPreviousEmployment.
     * @param {WSJobApplicationPreviousEmploymentCreateArgs} args - Arguments to create a WSJobApplicationPreviousEmployment.
     * @example
     * // Create one WSJobApplicationPreviousEmployment
     * const WSJobApplicationPreviousEmployment = await prisma.wSJobApplicationPreviousEmployment.create({
     *   data: {
     *     // ... data to create a WSJobApplicationPreviousEmployment
     *   }
     * })
     * 
     */
    create<T extends WSJobApplicationPreviousEmploymentCreateArgs>(args: SelectSubset<T, WSJobApplicationPreviousEmploymentCreateArgs<ExtArgs>>): Prisma__WSJobApplicationPreviousEmploymentClient<$Result.GetResult<Prisma.$WSJobApplicationPreviousEmploymentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WSJobApplicationPreviousEmployments.
     * @param {WSJobApplicationPreviousEmploymentCreateManyArgs} args - Arguments to create many WSJobApplicationPreviousEmployments.
     * @example
     * // Create many WSJobApplicationPreviousEmployments
     * const wSJobApplicationPreviousEmployment = await prisma.wSJobApplicationPreviousEmployment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WSJobApplicationPreviousEmploymentCreateManyArgs>(args?: SelectSubset<T, WSJobApplicationPreviousEmploymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WSJobApplicationPreviousEmployment.
     * @param {WSJobApplicationPreviousEmploymentDeleteArgs} args - Arguments to delete one WSJobApplicationPreviousEmployment.
     * @example
     * // Delete one WSJobApplicationPreviousEmployment
     * const WSJobApplicationPreviousEmployment = await prisma.wSJobApplicationPreviousEmployment.delete({
     *   where: {
     *     // ... filter to delete one WSJobApplicationPreviousEmployment
     *   }
     * })
     * 
     */
    delete<T extends WSJobApplicationPreviousEmploymentDeleteArgs>(args: SelectSubset<T, WSJobApplicationPreviousEmploymentDeleteArgs<ExtArgs>>): Prisma__WSJobApplicationPreviousEmploymentClient<$Result.GetResult<Prisma.$WSJobApplicationPreviousEmploymentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WSJobApplicationPreviousEmployment.
     * @param {WSJobApplicationPreviousEmploymentUpdateArgs} args - Arguments to update one WSJobApplicationPreviousEmployment.
     * @example
     * // Update one WSJobApplicationPreviousEmployment
     * const wSJobApplicationPreviousEmployment = await prisma.wSJobApplicationPreviousEmployment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WSJobApplicationPreviousEmploymentUpdateArgs>(args: SelectSubset<T, WSJobApplicationPreviousEmploymentUpdateArgs<ExtArgs>>): Prisma__WSJobApplicationPreviousEmploymentClient<$Result.GetResult<Prisma.$WSJobApplicationPreviousEmploymentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WSJobApplicationPreviousEmployments.
     * @param {WSJobApplicationPreviousEmploymentDeleteManyArgs} args - Arguments to filter WSJobApplicationPreviousEmployments to delete.
     * @example
     * // Delete a few WSJobApplicationPreviousEmployments
     * const { count } = await prisma.wSJobApplicationPreviousEmployment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WSJobApplicationPreviousEmploymentDeleteManyArgs>(args?: SelectSubset<T, WSJobApplicationPreviousEmploymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WSJobApplicationPreviousEmployments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSJobApplicationPreviousEmploymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WSJobApplicationPreviousEmployments
     * const wSJobApplicationPreviousEmployment = await prisma.wSJobApplicationPreviousEmployment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WSJobApplicationPreviousEmploymentUpdateManyArgs>(args: SelectSubset<T, WSJobApplicationPreviousEmploymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WSJobApplicationPreviousEmployment.
     * @param {WSJobApplicationPreviousEmploymentUpsertArgs} args - Arguments to update or create a WSJobApplicationPreviousEmployment.
     * @example
     * // Update or create a WSJobApplicationPreviousEmployment
     * const wSJobApplicationPreviousEmployment = await prisma.wSJobApplicationPreviousEmployment.upsert({
     *   create: {
     *     // ... data to create a WSJobApplicationPreviousEmployment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WSJobApplicationPreviousEmployment we want to update
     *   }
     * })
     */
    upsert<T extends WSJobApplicationPreviousEmploymentUpsertArgs>(args: SelectSubset<T, WSJobApplicationPreviousEmploymentUpsertArgs<ExtArgs>>): Prisma__WSJobApplicationPreviousEmploymentClient<$Result.GetResult<Prisma.$WSJobApplicationPreviousEmploymentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WSJobApplicationPreviousEmployments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSJobApplicationPreviousEmploymentCountArgs} args - Arguments to filter WSJobApplicationPreviousEmployments to count.
     * @example
     * // Count the number of WSJobApplicationPreviousEmployments
     * const count = await prisma.wSJobApplicationPreviousEmployment.count({
     *   where: {
     *     // ... the filter for the WSJobApplicationPreviousEmployments we want to count
     *   }
     * })
    **/
    count<T extends WSJobApplicationPreviousEmploymentCountArgs>(
      args?: Subset<T, WSJobApplicationPreviousEmploymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WSJobApplicationPreviousEmploymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WSJobApplicationPreviousEmployment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSJobApplicationPreviousEmploymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WSJobApplicationPreviousEmploymentAggregateArgs>(args: Subset<T, WSJobApplicationPreviousEmploymentAggregateArgs>): Prisma.PrismaPromise<GetWSJobApplicationPreviousEmploymentAggregateType<T>>

    /**
     * Group by WSJobApplicationPreviousEmployment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSJobApplicationPreviousEmploymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WSJobApplicationPreviousEmploymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WSJobApplicationPreviousEmploymentGroupByArgs['orderBy'] }
        : { orderBy?: WSJobApplicationPreviousEmploymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WSJobApplicationPreviousEmploymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWSJobApplicationPreviousEmploymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WSJobApplicationPreviousEmployment model
   */
  readonly fields: WSJobApplicationPreviousEmploymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WSJobApplicationPreviousEmployment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WSJobApplicationPreviousEmploymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    WSJobApplication<T extends WSJobApplicationPreviousEmployment$WSJobApplicationArgs<ExtArgs> = {}>(args?: Subset<T, WSJobApplicationPreviousEmployment$WSJobApplicationArgs<ExtArgs>>): Prisma__WSJobApplicationClient<$Result.GetResult<Prisma.$WSJobApplicationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WSJobApplicationPreviousEmployment model
   */ 
  interface WSJobApplicationPreviousEmploymentFieldRefs {
    readonly ID: FieldRef<"WSJobApplicationPreviousEmployment", 'Int'>
    readonly JobApplicationId: FieldRef<"WSJobApplicationPreviousEmployment", 'Int'>
    readonly Company: FieldRef<"WSJobApplicationPreviousEmployment", 'String'>
    readonly Supervisor: FieldRef<"WSJobApplicationPreviousEmployment", 'String'>
    readonly Address: FieldRef<"WSJobApplicationPreviousEmployment", 'String'>
    readonly FromDate: FieldRef<"WSJobApplicationPreviousEmployment", 'DateTime'>
    readonly ToDate: FieldRef<"WSJobApplicationPreviousEmployment", 'DateTime'>
    readonly JobTitle: FieldRef<"WSJobApplicationPreviousEmployment", 'String'>
    readonly EndingSalary: FieldRef<"WSJobApplicationPreviousEmployment", 'Float'>
    readonly IsHourlyRate: FieldRef<"WSJobApplicationPreviousEmployment", 'String'>
    readonly LeavingReason: FieldRef<"WSJobApplicationPreviousEmployment", 'String'>
    readonly IsValid: FieldRef<"WSJobApplicationPreviousEmployment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WSJobApplicationPreviousEmployment findUnique
   */
  export type WSJobApplicationPreviousEmploymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJobApplicationPreviousEmployment
     */
    select?: WSJobApplicationPreviousEmploymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobApplicationPreviousEmploymentInclude<ExtArgs> | null
    /**
     * Filter, which WSJobApplicationPreviousEmployment to fetch.
     */
    where: WSJobApplicationPreviousEmploymentWhereUniqueInput
  }

  /**
   * WSJobApplicationPreviousEmployment findUniqueOrThrow
   */
  export type WSJobApplicationPreviousEmploymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJobApplicationPreviousEmployment
     */
    select?: WSJobApplicationPreviousEmploymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobApplicationPreviousEmploymentInclude<ExtArgs> | null
    /**
     * Filter, which WSJobApplicationPreviousEmployment to fetch.
     */
    where: WSJobApplicationPreviousEmploymentWhereUniqueInput
  }

  /**
   * WSJobApplicationPreviousEmployment findFirst
   */
  export type WSJobApplicationPreviousEmploymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJobApplicationPreviousEmployment
     */
    select?: WSJobApplicationPreviousEmploymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobApplicationPreviousEmploymentInclude<ExtArgs> | null
    /**
     * Filter, which WSJobApplicationPreviousEmployment to fetch.
     */
    where?: WSJobApplicationPreviousEmploymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WSJobApplicationPreviousEmployments to fetch.
     */
    orderBy?: WSJobApplicationPreviousEmploymentOrderByWithRelationInput | WSJobApplicationPreviousEmploymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WSJobApplicationPreviousEmployments.
     */
    cursor?: WSJobApplicationPreviousEmploymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WSJobApplicationPreviousEmployments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WSJobApplicationPreviousEmployments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WSJobApplicationPreviousEmployments.
     */
    distinct?: WSJobApplicationPreviousEmploymentScalarFieldEnum | WSJobApplicationPreviousEmploymentScalarFieldEnum[]
  }

  /**
   * WSJobApplicationPreviousEmployment findFirstOrThrow
   */
  export type WSJobApplicationPreviousEmploymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJobApplicationPreviousEmployment
     */
    select?: WSJobApplicationPreviousEmploymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobApplicationPreviousEmploymentInclude<ExtArgs> | null
    /**
     * Filter, which WSJobApplicationPreviousEmployment to fetch.
     */
    where?: WSJobApplicationPreviousEmploymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WSJobApplicationPreviousEmployments to fetch.
     */
    orderBy?: WSJobApplicationPreviousEmploymentOrderByWithRelationInput | WSJobApplicationPreviousEmploymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WSJobApplicationPreviousEmployments.
     */
    cursor?: WSJobApplicationPreviousEmploymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WSJobApplicationPreviousEmployments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WSJobApplicationPreviousEmployments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WSJobApplicationPreviousEmployments.
     */
    distinct?: WSJobApplicationPreviousEmploymentScalarFieldEnum | WSJobApplicationPreviousEmploymentScalarFieldEnum[]
  }

  /**
   * WSJobApplicationPreviousEmployment findMany
   */
  export type WSJobApplicationPreviousEmploymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJobApplicationPreviousEmployment
     */
    select?: WSJobApplicationPreviousEmploymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobApplicationPreviousEmploymentInclude<ExtArgs> | null
    /**
     * Filter, which WSJobApplicationPreviousEmployments to fetch.
     */
    where?: WSJobApplicationPreviousEmploymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WSJobApplicationPreviousEmployments to fetch.
     */
    orderBy?: WSJobApplicationPreviousEmploymentOrderByWithRelationInput | WSJobApplicationPreviousEmploymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WSJobApplicationPreviousEmployments.
     */
    cursor?: WSJobApplicationPreviousEmploymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WSJobApplicationPreviousEmployments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WSJobApplicationPreviousEmployments.
     */
    skip?: number
    distinct?: WSJobApplicationPreviousEmploymentScalarFieldEnum | WSJobApplicationPreviousEmploymentScalarFieldEnum[]
  }

  /**
   * WSJobApplicationPreviousEmployment create
   */
  export type WSJobApplicationPreviousEmploymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJobApplicationPreviousEmployment
     */
    select?: WSJobApplicationPreviousEmploymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobApplicationPreviousEmploymentInclude<ExtArgs> | null
    /**
     * The data needed to create a WSJobApplicationPreviousEmployment.
     */
    data: XOR<WSJobApplicationPreviousEmploymentCreateInput, WSJobApplicationPreviousEmploymentUncheckedCreateInput>
  }

  /**
   * WSJobApplicationPreviousEmployment createMany
   */
  export type WSJobApplicationPreviousEmploymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WSJobApplicationPreviousEmployments.
     */
    data: WSJobApplicationPreviousEmploymentCreateManyInput | WSJobApplicationPreviousEmploymentCreateManyInput[]
  }

  /**
   * WSJobApplicationPreviousEmployment update
   */
  export type WSJobApplicationPreviousEmploymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJobApplicationPreviousEmployment
     */
    select?: WSJobApplicationPreviousEmploymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobApplicationPreviousEmploymentInclude<ExtArgs> | null
    /**
     * The data needed to update a WSJobApplicationPreviousEmployment.
     */
    data: XOR<WSJobApplicationPreviousEmploymentUpdateInput, WSJobApplicationPreviousEmploymentUncheckedUpdateInput>
    /**
     * Choose, which WSJobApplicationPreviousEmployment to update.
     */
    where: WSJobApplicationPreviousEmploymentWhereUniqueInput
  }

  /**
   * WSJobApplicationPreviousEmployment updateMany
   */
  export type WSJobApplicationPreviousEmploymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WSJobApplicationPreviousEmployments.
     */
    data: XOR<WSJobApplicationPreviousEmploymentUpdateManyMutationInput, WSJobApplicationPreviousEmploymentUncheckedUpdateManyInput>
    /**
     * Filter which WSJobApplicationPreviousEmployments to update
     */
    where?: WSJobApplicationPreviousEmploymentWhereInput
  }

  /**
   * WSJobApplicationPreviousEmployment upsert
   */
  export type WSJobApplicationPreviousEmploymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJobApplicationPreviousEmployment
     */
    select?: WSJobApplicationPreviousEmploymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobApplicationPreviousEmploymentInclude<ExtArgs> | null
    /**
     * The filter to search for the WSJobApplicationPreviousEmployment to update in case it exists.
     */
    where: WSJobApplicationPreviousEmploymentWhereUniqueInput
    /**
     * In case the WSJobApplicationPreviousEmployment found by the `where` argument doesn't exist, create a new WSJobApplicationPreviousEmployment with this data.
     */
    create: XOR<WSJobApplicationPreviousEmploymentCreateInput, WSJobApplicationPreviousEmploymentUncheckedCreateInput>
    /**
     * In case the WSJobApplicationPreviousEmployment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WSJobApplicationPreviousEmploymentUpdateInput, WSJobApplicationPreviousEmploymentUncheckedUpdateInput>
  }

  /**
   * WSJobApplicationPreviousEmployment delete
   */
  export type WSJobApplicationPreviousEmploymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJobApplicationPreviousEmployment
     */
    select?: WSJobApplicationPreviousEmploymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobApplicationPreviousEmploymentInclude<ExtArgs> | null
    /**
     * Filter which WSJobApplicationPreviousEmployment to delete.
     */
    where: WSJobApplicationPreviousEmploymentWhereUniqueInput
  }

  /**
   * WSJobApplicationPreviousEmployment deleteMany
   */
  export type WSJobApplicationPreviousEmploymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WSJobApplicationPreviousEmployments to delete
     */
    where?: WSJobApplicationPreviousEmploymentWhereInput
  }

  /**
   * WSJobApplicationPreviousEmployment.WSJobApplication
   */
  export type WSJobApplicationPreviousEmployment$WSJobApplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJobApplication
     */
    select?: WSJobApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobApplicationInclude<ExtArgs> | null
    where?: WSJobApplicationWhereInput
  }

  /**
   * WSJobApplicationPreviousEmployment without action
   */
  export type WSJobApplicationPreviousEmploymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJobApplicationPreviousEmployment
     */
    select?: WSJobApplicationPreviousEmploymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobApplicationPreviousEmploymentInclude<ExtArgs> | null
  }


  /**
   * Model WSJobApplicationReference
   */

  export type AggregateWSJobApplicationReference = {
    _count: WSJobApplicationReferenceCountAggregateOutputType | null
    _avg: WSJobApplicationReferenceAvgAggregateOutputType | null
    _sum: WSJobApplicationReferenceSumAggregateOutputType | null
    _min: WSJobApplicationReferenceMinAggregateOutputType | null
    _max: WSJobApplicationReferenceMaxAggregateOutputType | null
  }

  export type WSJobApplicationReferenceAvgAggregateOutputType = {
    ID: number | null
    JobApplicationId: number | null
  }

  export type WSJobApplicationReferenceSumAggregateOutputType = {
    ID: number | null
    JobApplicationId: number | null
  }

  export type WSJobApplicationReferenceMinAggregateOutputType = {
    ID: number | null
    JobApplicationId: number | null
    FullName: string | null
    Relationship: string | null
    Company: string | null
    Phone: string | null
    Email: string | null
    IsValid: string | null
  }

  export type WSJobApplicationReferenceMaxAggregateOutputType = {
    ID: number | null
    JobApplicationId: number | null
    FullName: string | null
    Relationship: string | null
    Company: string | null
    Phone: string | null
    Email: string | null
    IsValid: string | null
  }

  export type WSJobApplicationReferenceCountAggregateOutputType = {
    ID: number
    JobApplicationId: number
    FullName: number
    Relationship: number
    Company: number
    Phone: number
    Email: number
    IsValid: number
    _all: number
  }


  export type WSJobApplicationReferenceAvgAggregateInputType = {
    ID?: true
    JobApplicationId?: true
  }

  export type WSJobApplicationReferenceSumAggregateInputType = {
    ID?: true
    JobApplicationId?: true
  }

  export type WSJobApplicationReferenceMinAggregateInputType = {
    ID?: true
    JobApplicationId?: true
    FullName?: true
    Relationship?: true
    Company?: true
    Phone?: true
    Email?: true
    IsValid?: true
  }

  export type WSJobApplicationReferenceMaxAggregateInputType = {
    ID?: true
    JobApplicationId?: true
    FullName?: true
    Relationship?: true
    Company?: true
    Phone?: true
    Email?: true
    IsValid?: true
  }

  export type WSJobApplicationReferenceCountAggregateInputType = {
    ID?: true
    JobApplicationId?: true
    FullName?: true
    Relationship?: true
    Company?: true
    Phone?: true
    Email?: true
    IsValid?: true
    _all?: true
  }

  export type WSJobApplicationReferenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WSJobApplicationReference to aggregate.
     */
    where?: WSJobApplicationReferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WSJobApplicationReferences to fetch.
     */
    orderBy?: WSJobApplicationReferenceOrderByWithRelationInput | WSJobApplicationReferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WSJobApplicationReferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WSJobApplicationReferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WSJobApplicationReferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WSJobApplicationReferences
    **/
    _count?: true | WSJobApplicationReferenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WSJobApplicationReferenceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WSJobApplicationReferenceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WSJobApplicationReferenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WSJobApplicationReferenceMaxAggregateInputType
  }

  export type GetWSJobApplicationReferenceAggregateType<T extends WSJobApplicationReferenceAggregateArgs> = {
        [P in keyof T & keyof AggregateWSJobApplicationReference]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWSJobApplicationReference[P]>
      : GetScalarType<T[P], AggregateWSJobApplicationReference[P]>
  }




  export type WSJobApplicationReferenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WSJobApplicationReferenceWhereInput
    orderBy?: WSJobApplicationReferenceOrderByWithAggregationInput | WSJobApplicationReferenceOrderByWithAggregationInput[]
    by: WSJobApplicationReferenceScalarFieldEnum[] | WSJobApplicationReferenceScalarFieldEnum
    having?: WSJobApplicationReferenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WSJobApplicationReferenceCountAggregateInputType | true
    _avg?: WSJobApplicationReferenceAvgAggregateInputType
    _sum?: WSJobApplicationReferenceSumAggregateInputType
    _min?: WSJobApplicationReferenceMinAggregateInputType
    _max?: WSJobApplicationReferenceMaxAggregateInputType
  }

  export type WSJobApplicationReferenceGroupByOutputType = {
    ID: number
    JobApplicationId: number | null
    FullName: string
    Relationship: string
    Company: string
    Phone: string
    Email: string
    IsValid: string | null
    _count: WSJobApplicationReferenceCountAggregateOutputType | null
    _avg: WSJobApplicationReferenceAvgAggregateOutputType | null
    _sum: WSJobApplicationReferenceSumAggregateOutputType | null
    _min: WSJobApplicationReferenceMinAggregateOutputType | null
    _max: WSJobApplicationReferenceMaxAggregateOutputType | null
  }

  type GetWSJobApplicationReferenceGroupByPayload<T extends WSJobApplicationReferenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WSJobApplicationReferenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WSJobApplicationReferenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WSJobApplicationReferenceGroupByOutputType[P]>
            : GetScalarType<T[P], WSJobApplicationReferenceGroupByOutputType[P]>
        }
      >
    >


  export type WSJobApplicationReferenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    JobApplicationId?: boolean
    FullName?: boolean
    Relationship?: boolean
    Company?: boolean
    Phone?: boolean
    Email?: boolean
    IsValid?: boolean
    WSJobApplication?: boolean | WSJobApplicationReference$WSJobApplicationArgs<ExtArgs>
  }, ExtArgs["result"]["wSJobApplicationReference"]>


  export type WSJobApplicationReferenceSelectScalar = {
    ID?: boolean
    JobApplicationId?: boolean
    FullName?: boolean
    Relationship?: boolean
    Company?: boolean
    Phone?: boolean
    Email?: boolean
    IsValid?: boolean
  }

  export type WSJobApplicationReferenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    WSJobApplication?: boolean | WSJobApplicationReference$WSJobApplicationArgs<ExtArgs>
  }

  export type $WSJobApplicationReferencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WSJobApplicationReference"
    objects: {
      WSJobApplication: Prisma.$WSJobApplicationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      JobApplicationId: number | null
      FullName: string
      Relationship: string
      Company: string
      Phone: string
      Email: string
      IsValid: string | null
    }, ExtArgs["result"]["wSJobApplicationReference"]>
    composites: {}
  }

  type WSJobApplicationReferenceGetPayload<S extends boolean | null | undefined | WSJobApplicationReferenceDefaultArgs> = $Result.GetResult<Prisma.$WSJobApplicationReferencePayload, S>

  type WSJobApplicationReferenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WSJobApplicationReferenceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WSJobApplicationReferenceCountAggregateInputType | true
    }

  export interface WSJobApplicationReferenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WSJobApplicationReference'], meta: { name: 'WSJobApplicationReference' } }
    /**
     * Find zero or one WSJobApplicationReference that matches the filter.
     * @param {WSJobApplicationReferenceFindUniqueArgs} args - Arguments to find a WSJobApplicationReference
     * @example
     * // Get one WSJobApplicationReference
     * const wSJobApplicationReference = await prisma.wSJobApplicationReference.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WSJobApplicationReferenceFindUniqueArgs>(args: SelectSubset<T, WSJobApplicationReferenceFindUniqueArgs<ExtArgs>>): Prisma__WSJobApplicationReferenceClient<$Result.GetResult<Prisma.$WSJobApplicationReferencePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WSJobApplicationReference that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WSJobApplicationReferenceFindUniqueOrThrowArgs} args - Arguments to find a WSJobApplicationReference
     * @example
     * // Get one WSJobApplicationReference
     * const wSJobApplicationReference = await prisma.wSJobApplicationReference.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WSJobApplicationReferenceFindUniqueOrThrowArgs>(args: SelectSubset<T, WSJobApplicationReferenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WSJobApplicationReferenceClient<$Result.GetResult<Prisma.$WSJobApplicationReferencePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WSJobApplicationReference that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSJobApplicationReferenceFindFirstArgs} args - Arguments to find a WSJobApplicationReference
     * @example
     * // Get one WSJobApplicationReference
     * const wSJobApplicationReference = await prisma.wSJobApplicationReference.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WSJobApplicationReferenceFindFirstArgs>(args?: SelectSubset<T, WSJobApplicationReferenceFindFirstArgs<ExtArgs>>): Prisma__WSJobApplicationReferenceClient<$Result.GetResult<Prisma.$WSJobApplicationReferencePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WSJobApplicationReference that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSJobApplicationReferenceFindFirstOrThrowArgs} args - Arguments to find a WSJobApplicationReference
     * @example
     * // Get one WSJobApplicationReference
     * const wSJobApplicationReference = await prisma.wSJobApplicationReference.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WSJobApplicationReferenceFindFirstOrThrowArgs>(args?: SelectSubset<T, WSJobApplicationReferenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__WSJobApplicationReferenceClient<$Result.GetResult<Prisma.$WSJobApplicationReferencePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WSJobApplicationReferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSJobApplicationReferenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WSJobApplicationReferences
     * const wSJobApplicationReferences = await prisma.wSJobApplicationReference.findMany()
     * 
     * // Get first 10 WSJobApplicationReferences
     * const wSJobApplicationReferences = await prisma.wSJobApplicationReference.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const wSJobApplicationReferenceWithIDOnly = await prisma.wSJobApplicationReference.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends WSJobApplicationReferenceFindManyArgs>(args?: SelectSubset<T, WSJobApplicationReferenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WSJobApplicationReferencePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WSJobApplicationReference.
     * @param {WSJobApplicationReferenceCreateArgs} args - Arguments to create a WSJobApplicationReference.
     * @example
     * // Create one WSJobApplicationReference
     * const WSJobApplicationReference = await prisma.wSJobApplicationReference.create({
     *   data: {
     *     // ... data to create a WSJobApplicationReference
     *   }
     * })
     * 
     */
    create<T extends WSJobApplicationReferenceCreateArgs>(args: SelectSubset<T, WSJobApplicationReferenceCreateArgs<ExtArgs>>): Prisma__WSJobApplicationReferenceClient<$Result.GetResult<Prisma.$WSJobApplicationReferencePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WSJobApplicationReferences.
     * @param {WSJobApplicationReferenceCreateManyArgs} args - Arguments to create many WSJobApplicationReferences.
     * @example
     * // Create many WSJobApplicationReferences
     * const wSJobApplicationReference = await prisma.wSJobApplicationReference.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WSJobApplicationReferenceCreateManyArgs>(args?: SelectSubset<T, WSJobApplicationReferenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WSJobApplicationReference.
     * @param {WSJobApplicationReferenceDeleteArgs} args - Arguments to delete one WSJobApplicationReference.
     * @example
     * // Delete one WSJobApplicationReference
     * const WSJobApplicationReference = await prisma.wSJobApplicationReference.delete({
     *   where: {
     *     // ... filter to delete one WSJobApplicationReference
     *   }
     * })
     * 
     */
    delete<T extends WSJobApplicationReferenceDeleteArgs>(args: SelectSubset<T, WSJobApplicationReferenceDeleteArgs<ExtArgs>>): Prisma__WSJobApplicationReferenceClient<$Result.GetResult<Prisma.$WSJobApplicationReferencePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WSJobApplicationReference.
     * @param {WSJobApplicationReferenceUpdateArgs} args - Arguments to update one WSJobApplicationReference.
     * @example
     * // Update one WSJobApplicationReference
     * const wSJobApplicationReference = await prisma.wSJobApplicationReference.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WSJobApplicationReferenceUpdateArgs>(args: SelectSubset<T, WSJobApplicationReferenceUpdateArgs<ExtArgs>>): Prisma__WSJobApplicationReferenceClient<$Result.GetResult<Prisma.$WSJobApplicationReferencePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WSJobApplicationReferences.
     * @param {WSJobApplicationReferenceDeleteManyArgs} args - Arguments to filter WSJobApplicationReferences to delete.
     * @example
     * // Delete a few WSJobApplicationReferences
     * const { count } = await prisma.wSJobApplicationReference.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WSJobApplicationReferenceDeleteManyArgs>(args?: SelectSubset<T, WSJobApplicationReferenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WSJobApplicationReferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSJobApplicationReferenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WSJobApplicationReferences
     * const wSJobApplicationReference = await prisma.wSJobApplicationReference.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WSJobApplicationReferenceUpdateManyArgs>(args: SelectSubset<T, WSJobApplicationReferenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WSJobApplicationReference.
     * @param {WSJobApplicationReferenceUpsertArgs} args - Arguments to update or create a WSJobApplicationReference.
     * @example
     * // Update or create a WSJobApplicationReference
     * const wSJobApplicationReference = await prisma.wSJobApplicationReference.upsert({
     *   create: {
     *     // ... data to create a WSJobApplicationReference
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WSJobApplicationReference we want to update
     *   }
     * })
     */
    upsert<T extends WSJobApplicationReferenceUpsertArgs>(args: SelectSubset<T, WSJobApplicationReferenceUpsertArgs<ExtArgs>>): Prisma__WSJobApplicationReferenceClient<$Result.GetResult<Prisma.$WSJobApplicationReferencePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WSJobApplicationReferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSJobApplicationReferenceCountArgs} args - Arguments to filter WSJobApplicationReferences to count.
     * @example
     * // Count the number of WSJobApplicationReferences
     * const count = await prisma.wSJobApplicationReference.count({
     *   where: {
     *     // ... the filter for the WSJobApplicationReferences we want to count
     *   }
     * })
    **/
    count<T extends WSJobApplicationReferenceCountArgs>(
      args?: Subset<T, WSJobApplicationReferenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WSJobApplicationReferenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WSJobApplicationReference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSJobApplicationReferenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WSJobApplicationReferenceAggregateArgs>(args: Subset<T, WSJobApplicationReferenceAggregateArgs>): Prisma.PrismaPromise<GetWSJobApplicationReferenceAggregateType<T>>

    /**
     * Group by WSJobApplicationReference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSJobApplicationReferenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WSJobApplicationReferenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WSJobApplicationReferenceGroupByArgs['orderBy'] }
        : { orderBy?: WSJobApplicationReferenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WSJobApplicationReferenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWSJobApplicationReferenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WSJobApplicationReference model
   */
  readonly fields: WSJobApplicationReferenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WSJobApplicationReference.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WSJobApplicationReferenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    WSJobApplication<T extends WSJobApplicationReference$WSJobApplicationArgs<ExtArgs> = {}>(args?: Subset<T, WSJobApplicationReference$WSJobApplicationArgs<ExtArgs>>): Prisma__WSJobApplicationClient<$Result.GetResult<Prisma.$WSJobApplicationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WSJobApplicationReference model
   */ 
  interface WSJobApplicationReferenceFieldRefs {
    readonly ID: FieldRef<"WSJobApplicationReference", 'Int'>
    readonly JobApplicationId: FieldRef<"WSJobApplicationReference", 'Int'>
    readonly FullName: FieldRef<"WSJobApplicationReference", 'String'>
    readonly Relationship: FieldRef<"WSJobApplicationReference", 'String'>
    readonly Company: FieldRef<"WSJobApplicationReference", 'String'>
    readonly Phone: FieldRef<"WSJobApplicationReference", 'String'>
    readonly Email: FieldRef<"WSJobApplicationReference", 'String'>
    readonly IsValid: FieldRef<"WSJobApplicationReference", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WSJobApplicationReference findUnique
   */
  export type WSJobApplicationReferenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJobApplicationReference
     */
    select?: WSJobApplicationReferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobApplicationReferenceInclude<ExtArgs> | null
    /**
     * Filter, which WSJobApplicationReference to fetch.
     */
    where: WSJobApplicationReferenceWhereUniqueInput
  }

  /**
   * WSJobApplicationReference findUniqueOrThrow
   */
  export type WSJobApplicationReferenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJobApplicationReference
     */
    select?: WSJobApplicationReferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobApplicationReferenceInclude<ExtArgs> | null
    /**
     * Filter, which WSJobApplicationReference to fetch.
     */
    where: WSJobApplicationReferenceWhereUniqueInput
  }

  /**
   * WSJobApplicationReference findFirst
   */
  export type WSJobApplicationReferenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJobApplicationReference
     */
    select?: WSJobApplicationReferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobApplicationReferenceInclude<ExtArgs> | null
    /**
     * Filter, which WSJobApplicationReference to fetch.
     */
    where?: WSJobApplicationReferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WSJobApplicationReferences to fetch.
     */
    orderBy?: WSJobApplicationReferenceOrderByWithRelationInput | WSJobApplicationReferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WSJobApplicationReferences.
     */
    cursor?: WSJobApplicationReferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WSJobApplicationReferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WSJobApplicationReferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WSJobApplicationReferences.
     */
    distinct?: WSJobApplicationReferenceScalarFieldEnum | WSJobApplicationReferenceScalarFieldEnum[]
  }

  /**
   * WSJobApplicationReference findFirstOrThrow
   */
  export type WSJobApplicationReferenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJobApplicationReference
     */
    select?: WSJobApplicationReferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobApplicationReferenceInclude<ExtArgs> | null
    /**
     * Filter, which WSJobApplicationReference to fetch.
     */
    where?: WSJobApplicationReferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WSJobApplicationReferences to fetch.
     */
    orderBy?: WSJobApplicationReferenceOrderByWithRelationInput | WSJobApplicationReferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WSJobApplicationReferences.
     */
    cursor?: WSJobApplicationReferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WSJobApplicationReferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WSJobApplicationReferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WSJobApplicationReferences.
     */
    distinct?: WSJobApplicationReferenceScalarFieldEnum | WSJobApplicationReferenceScalarFieldEnum[]
  }

  /**
   * WSJobApplicationReference findMany
   */
  export type WSJobApplicationReferenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJobApplicationReference
     */
    select?: WSJobApplicationReferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobApplicationReferenceInclude<ExtArgs> | null
    /**
     * Filter, which WSJobApplicationReferences to fetch.
     */
    where?: WSJobApplicationReferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WSJobApplicationReferences to fetch.
     */
    orderBy?: WSJobApplicationReferenceOrderByWithRelationInput | WSJobApplicationReferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WSJobApplicationReferences.
     */
    cursor?: WSJobApplicationReferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WSJobApplicationReferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WSJobApplicationReferences.
     */
    skip?: number
    distinct?: WSJobApplicationReferenceScalarFieldEnum | WSJobApplicationReferenceScalarFieldEnum[]
  }

  /**
   * WSJobApplicationReference create
   */
  export type WSJobApplicationReferenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJobApplicationReference
     */
    select?: WSJobApplicationReferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobApplicationReferenceInclude<ExtArgs> | null
    /**
     * The data needed to create a WSJobApplicationReference.
     */
    data: XOR<WSJobApplicationReferenceCreateInput, WSJobApplicationReferenceUncheckedCreateInput>
  }

  /**
   * WSJobApplicationReference createMany
   */
  export type WSJobApplicationReferenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WSJobApplicationReferences.
     */
    data: WSJobApplicationReferenceCreateManyInput | WSJobApplicationReferenceCreateManyInput[]
  }

  /**
   * WSJobApplicationReference update
   */
  export type WSJobApplicationReferenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJobApplicationReference
     */
    select?: WSJobApplicationReferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobApplicationReferenceInclude<ExtArgs> | null
    /**
     * The data needed to update a WSJobApplicationReference.
     */
    data: XOR<WSJobApplicationReferenceUpdateInput, WSJobApplicationReferenceUncheckedUpdateInput>
    /**
     * Choose, which WSJobApplicationReference to update.
     */
    where: WSJobApplicationReferenceWhereUniqueInput
  }

  /**
   * WSJobApplicationReference updateMany
   */
  export type WSJobApplicationReferenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WSJobApplicationReferences.
     */
    data: XOR<WSJobApplicationReferenceUpdateManyMutationInput, WSJobApplicationReferenceUncheckedUpdateManyInput>
    /**
     * Filter which WSJobApplicationReferences to update
     */
    where?: WSJobApplicationReferenceWhereInput
  }

  /**
   * WSJobApplicationReference upsert
   */
  export type WSJobApplicationReferenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJobApplicationReference
     */
    select?: WSJobApplicationReferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobApplicationReferenceInclude<ExtArgs> | null
    /**
     * The filter to search for the WSJobApplicationReference to update in case it exists.
     */
    where: WSJobApplicationReferenceWhereUniqueInput
    /**
     * In case the WSJobApplicationReference found by the `where` argument doesn't exist, create a new WSJobApplicationReference with this data.
     */
    create: XOR<WSJobApplicationReferenceCreateInput, WSJobApplicationReferenceUncheckedCreateInput>
    /**
     * In case the WSJobApplicationReference was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WSJobApplicationReferenceUpdateInput, WSJobApplicationReferenceUncheckedUpdateInput>
  }

  /**
   * WSJobApplicationReference delete
   */
  export type WSJobApplicationReferenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJobApplicationReference
     */
    select?: WSJobApplicationReferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobApplicationReferenceInclude<ExtArgs> | null
    /**
     * Filter which WSJobApplicationReference to delete.
     */
    where: WSJobApplicationReferenceWhereUniqueInput
  }

  /**
   * WSJobApplicationReference deleteMany
   */
  export type WSJobApplicationReferenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WSJobApplicationReferences to delete
     */
    where?: WSJobApplicationReferenceWhereInput
  }

  /**
   * WSJobApplicationReference.WSJobApplication
   */
  export type WSJobApplicationReference$WSJobApplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJobApplication
     */
    select?: WSJobApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobApplicationInclude<ExtArgs> | null
    where?: WSJobApplicationWhereInput
  }

  /**
   * WSJobApplicationReference without action
   */
  export type WSJobApplicationReferenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJobApplicationReference
     */
    select?: WSJobApplicationReferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobApplicationReferenceInclude<ExtArgs> | null
  }


  /**
   * Model WsJobApplicationReply
   */

  export type AggregateWsJobApplicationReply = {
    _count: WsJobApplicationReplyCountAggregateOutputType | null
    _avg: WsJobApplicationReplyAvgAggregateOutputType | null
    _sum: WsJobApplicationReplySumAggregateOutputType | null
    _min: WsJobApplicationReplyMinAggregateOutputType | null
    _max: WsJobApplicationReplyMaxAggregateOutputType | null
  }

  export type WsJobApplicationReplyAvgAggregateOutputType = {
    ID: number | null
    FeedbackID: number | null
  }

  export type WsJobApplicationReplySumAggregateOutputType = {
    ID: number | null
    FeedbackID: number | null
  }

  export type WsJobApplicationReplyMinAggregateOutputType = {
    ID: number | null
    FeedbackID: number | null
    Message: string | null
    CreatedBy: string | null
    CreatedOn: Date | null
    ModifiedOn: Date | null
  }

  export type WsJobApplicationReplyMaxAggregateOutputType = {
    ID: number | null
    FeedbackID: number | null
    Message: string | null
    CreatedBy: string | null
    CreatedOn: Date | null
    ModifiedOn: Date | null
  }

  export type WsJobApplicationReplyCountAggregateOutputType = {
    ID: number
    FeedbackID: number
    Message: number
    CreatedBy: number
    CreatedOn: number
    ModifiedOn: number
    _all: number
  }


  export type WsJobApplicationReplyAvgAggregateInputType = {
    ID?: true
    FeedbackID?: true
  }

  export type WsJobApplicationReplySumAggregateInputType = {
    ID?: true
    FeedbackID?: true
  }

  export type WsJobApplicationReplyMinAggregateInputType = {
    ID?: true
    FeedbackID?: true
    Message?: true
    CreatedBy?: true
    CreatedOn?: true
    ModifiedOn?: true
  }

  export type WsJobApplicationReplyMaxAggregateInputType = {
    ID?: true
    FeedbackID?: true
    Message?: true
    CreatedBy?: true
    CreatedOn?: true
    ModifiedOn?: true
  }

  export type WsJobApplicationReplyCountAggregateInputType = {
    ID?: true
    FeedbackID?: true
    Message?: true
    CreatedBy?: true
    CreatedOn?: true
    ModifiedOn?: true
    _all?: true
  }

  export type WsJobApplicationReplyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WsJobApplicationReply to aggregate.
     */
    where?: WsJobApplicationReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WsJobApplicationReplies to fetch.
     */
    orderBy?: WsJobApplicationReplyOrderByWithRelationInput | WsJobApplicationReplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WsJobApplicationReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WsJobApplicationReplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WsJobApplicationReplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WsJobApplicationReplies
    **/
    _count?: true | WsJobApplicationReplyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WsJobApplicationReplyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WsJobApplicationReplySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WsJobApplicationReplyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WsJobApplicationReplyMaxAggregateInputType
  }

  export type GetWsJobApplicationReplyAggregateType<T extends WsJobApplicationReplyAggregateArgs> = {
        [P in keyof T & keyof AggregateWsJobApplicationReply]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWsJobApplicationReply[P]>
      : GetScalarType<T[P], AggregateWsJobApplicationReply[P]>
  }




  export type WsJobApplicationReplyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WsJobApplicationReplyWhereInput
    orderBy?: WsJobApplicationReplyOrderByWithAggregationInput | WsJobApplicationReplyOrderByWithAggregationInput[]
    by: WsJobApplicationReplyScalarFieldEnum[] | WsJobApplicationReplyScalarFieldEnum
    having?: WsJobApplicationReplyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WsJobApplicationReplyCountAggregateInputType | true
    _avg?: WsJobApplicationReplyAvgAggregateInputType
    _sum?: WsJobApplicationReplySumAggregateInputType
    _min?: WsJobApplicationReplyMinAggregateInputType
    _max?: WsJobApplicationReplyMaxAggregateInputType
  }

  export type WsJobApplicationReplyGroupByOutputType = {
    ID: number
    FeedbackID: number
    Message: string
    CreatedBy: string
    CreatedOn: Date
    ModifiedOn: Date | null
    _count: WsJobApplicationReplyCountAggregateOutputType | null
    _avg: WsJobApplicationReplyAvgAggregateOutputType | null
    _sum: WsJobApplicationReplySumAggregateOutputType | null
    _min: WsJobApplicationReplyMinAggregateOutputType | null
    _max: WsJobApplicationReplyMaxAggregateOutputType | null
  }

  type GetWsJobApplicationReplyGroupByPayload<T extends WsJobApplicationReplyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WsJobApplicationReplyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WsJobApplicationReplyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WsJobApplicationReplyGroupByOutputType[P]>
            : GetScalarType<T[P], WsJobApplicationReplyGroupByOutputType[P]>
        }
      >
    >


  export type WsJobApplicationReplySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    FeedbackID?: boolean
    Message?: boolean
    CreatedBy?: boolean
    CreatedOn?: boolean
    ModifiedOn?: boolean
    WSJobApplicationFeedback?: boolean | WSJobApplicationFeedbackDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wsJobApplicationReply"]>


  export type WsJobApplicationReplySelectScalar = {
    ID?: boolean
    FeedbackID?: boolean
    Message?: boolean
    CreatedBy?: boolean
    CreatedOn?: boolean
    ModifiedOn?: boolean
  }

  export type WsJobApplicationReplyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    WSJobApplicationFeedback?: boolean | WSJobApplicationFeedbackDefaultArgs<ExtArgs>
  }

  export type $WsJobApplicationReplyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WsJobApplicationReply"
    objects: {
      WSJobApplicationFeedback: Prisma.$WSJobApplicationFeedbackPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      FeedbackID: number
      Message: string
      CreatedBy: string
      CreatedOn: Date
      ModifiedOn: Date | null
    }, ExtArgs["result"]["wsJobApplicationReply"]>
    composites: {}
  }

  type WsJobApplicationReplyGetPayload<S extends boolean | null | undefined | WsJobApplicationReplyDefaultArgs> = $Result.GetResult<Prisma.$WsJobApplicationReplyPayload, S>

  type WsJobApplicationReplyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WsJobApplicationReplyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WsJobApplicationReplyCountAggregateInputType | true
    }

  export interface WsJobApplicationReplyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WsJobApplicationReply'], meta: { name: 'WsJobApplicationReply' } }
    /**
     * Find zero or one WsJobApplicationReply that matches the filter.
     * @param {WsJobApplicationReplyFindUniqueArgs} args - Arguments to find a WsJobApplicationReply
     * @example
     * // Get one WsJobApplicationReply
     * const wsJobApplicationReply = await prisma.wsJobApplicationReply.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WsJobApplicationReplyFindUniqueArgs>(args: SelectSubset<T, WsJobApplicationReplyFindUniqueArgs<ExtArgs>>): Prisma__WsJobApplicationReplyClient<$Result.GetResult<Prisma.$WsJobApplicationReplyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WsJobApplicationReply that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WsJobApplicationReplyFindUniqueOrThrowArgs} args - Arguments to find a WsJobApplicationReply
     * @example
     * // Get one WsJobApplicationReply
     * const wsJobApplicationReply = await prisma.wsJobApplicationReply.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WsJobApplicationReplyFindUniqueOrThrowArgs>(args: SelectSubset<T, WsJobApplicationReplyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WsJobApplicationReplyClient<$Result.GetResult<Prisma.$WsJobApplicationReplyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WsJobApplicationReply that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsJobApplicationReplyFindFirstArgs} args - Arguments to find a WsJobApplicationReply
     * @example
     * // Get one WsJobApplicationReply
     * const wsJobApplicationReply = await prisma.wsJobApplicationReply.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WsJobApplicationReplyFindFirstArgs>(args?: SelectSubset<T, WsJobApplicationReplyFindFirstArgs<ExtArgs>>): Prisma__WsJobApplicationReplyClient<$Result.GetResult<Prisma.$WsJobApplicationReplyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WsJobApplicationReply that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsJobApplicationReplyFindFirstOrThrowArgs} args - Arguments to find a WsJobApplicationReply
     * @example
     * // Get one WsJobApplicationReply
     * const wsJobApplicationReply = await prisma.wsJobApplicationReply.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WsJobApplicationReplyFindFirstOrThrowArgs>(args?: SelectSubset<T, WsJobApplicationReplyFindFirstOrThrowArgs<ExtArgs>>): Prisma__WsJobApplicationReplyClient<$Result.GetResult<Prisma.$WsJobApplicationReplyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WsJobApplicationReplies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsJobApplicationReplyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WsJobApplicationReplies
     * const wsJobApplicationReplies = await prisma.wsJobApplicationReply.findMany()
     * 
     * // Get first 10 WsJobApplicationReplies
     * const wsJobApplicationReplies = await prisma.wsJobApplicationReply.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const wsJobApplicationReplyWithIDOnly = await prisma.wsJobApplicationReply.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends WsJobApplicationReplyFindManyArgs>(args?: SelectSubset<T, WsJobApplicationReplyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WsJobApplicationReplyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WsJobApplicationReply.
     * @param {WsJobApplicationReplyCreateArgs} args - Arguments to create a WsJobApplicationReply.
     * @example
     * // Create one WsJobApplicationReply
     * const WsJobApplicationReply = await prisma.wsJobApplicationReply.create({
     *   data: {
     *     // ... data to create a WsJobApplicationReply
     *   }
     * })
     * 
     */
    create<T extends WsJobApplicationReplyCreateArgs>(args: SelectSubset<T, WsJobApplicationReplyCreateArgs<ExtArgs>>): Prisma__WsJobApplicationReplyClient<$Result.GetResult<Prisma.$WsJobApplicationReplyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WsJobApplicationReplies.
     * @param {WsJobApplicationReplyCreateManyArgs} args - Arguments to create many WsJobApplicationReplies.
     * @example
     * // Create many WsJobApplicationReplies
     * const wsJobApplicationReply = await prisma.wsJobApplicationReply.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WsJobApplicationReplyCreateManyArgs>(args?: SelectSubset<T, WsJobApplicationReplyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WsJobApplicationReply.
     * @param {WsJobApplicationReplyDeleteArgs} args - Arguments to delete one WsJobApplicationReply.
     * @example
     * // Delete one WsJobApplicationReply
     * const WsJobApplicationReply = await prisma.wsJobApplicationReply.delete({
     *   where: {
     *     // ... filter to delete one WsJobApplicationReply
     *   }
     * })
     * 
     */
    delete<T extends WsJobApplicationReplyDeleteArgs>(args: SelectSubset<T, WsJobApplicationReplyDeleteArgs<ExtArgs>>): Prisma__WsJobApplicationReplyClient<$Result.GetResult<Prisma.$WsJobApplicationReplyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WsJobApplicationReply.
     * @param {WsJobApplicationReplyUpdateArgs} args - Arguments to update one WsJobApplicationReply.
     * @example
     * // Update one WsJobApplicationReply
     * const wsJobApplicationReply = await prisma.wsJobApplicationReply.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WsJobApplicationReplyUpdateArgs>(args: SelectSubset<T, WsJobApplicationReplyUpdateArgs<ExtArgs>>): Prisma__WsJobApplicationReplyClient<$Result.GetResult<Prisma.$WsJobApplicationReplyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WsJobApplicationReplies.
     * @param {WsJobApplicationReplyDeleteManyArgs} args - Arguments to filter WsJobApplicationReplies to delete.
     * @example
     * // Delete a few WsJobApplicationReplies
     * const { count } = await prisma.wsJobApplicationReply.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WsJobApplicationReplyDeleteManyArgs>(args?: SelectSubset<T, WsJobApplicationReplyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WsJobApplicationReplies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsJobApplicationReplyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WsJobApplicationReplies
     * const wsJobApplicationReply = await prisma.wsJobApplicationReply.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WsJobApplicationReplyUpdateManyArgs>(args: SelectSubset<T, WsJobApplicationReplyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WsJobApplicationReply.
     * @param {WsJobApplicationReplyUpsertArgs} args - Arguments to update or create a WsJobApplicationReply.
     * @example
     * // Update or create a WsJobApplicationReply
     * const wsJobApplicationReply = await prisma.wsJobApplicationReply.upsert({
     *   create: {
     *     // ... data to create a WsJobApplicationReply
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WsJobApplicationReply we want to update
     *   }
     * })
     */
    upsert<T extends WsJobApplicationReplyUpsertArgs>(args: SelectSubset<T, WsJobApplicationReplyUpsertArgs<ExtArgs>>): Prisma__WsJobApplicationReplyClient<$Result.GetResult<Prisma.$WsJobApplicationReplyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WsJobApplicationReplies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsJobApplicationReplyCountArgs} args - Arguments to filter WsJobApplicationReplies to count.
     * @example
     * // Count the number of WsJobApplicationReplies
     * const count = await prisma.wsJobApplicationReply.count({
     *   where: {
     *     // ... the filter for the WsJobApplicationReplies we want to count
     *   }
     * })
    **/
    count<T extends WsJobApplicationReplyCountArgs>(
      args?: Subset<T, WsJobApplicationReplyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WsJobApplicationReplyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WsJobApplicationReply.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsJobApplicationReplyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WsJobApplicationReplyAggregateArgs>(args: Subset<T, WsJobApplicationReplyAggregateArgs>): Prisma.PrismaPromise<GetWsJobApplicationReplyAggregateType<T>>

    /**
     * Group by WsJobApplicationReply.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsJobApplicationReplyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WsJobApplicationReplyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WsJobApplicationReplyGroupByArgs['orderBy'] }
        : { orderBy?: WsJobApplicationReplyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WsJobApplicationReplyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWsJobApplicationReplyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WsJobApplicationReply model
   */
  readonly fields: WsJobApplicationReplyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WsJobApplicationReply.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WsJobApplicationReplyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    WSJobApplicationFeedback<T extends WSJobApplicationFeedbackDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WSJobApplicationFeedbackDefaultArgs<ExtArgs>>): Prisma__WSJobApplicationFeedbackClient<$Result.GetResult<Prisma.$WSJobApplicationFeedbackPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WsJobApplicationReply model
   */ 
  interface WsJobApplicationReplyFieldRefs {
    readonly ID: FieldRef<"WsJobApplicationReply", 'Int'>
    readonly FeedbackID: FieldRef<"WsJobApplicationReply", 'Int'>
    readonly Message: FieldRef<"WsJobApplicationReply", 'String'>
    readonly CreatedBy: FieldRef<"WsJobApplicationReply", 'String'>
    readonly CreatedOn: FieldRef<"WsJobApplicationReply", 'DateTime'>
    readonly ModifiedOn: FieldRef<"WsJobApplicationReply", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WsJobApplicationReply findUnique
   */
  export type WsJobApplicationReplyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsJobApplicationReply
     */
    select?: WsJobApplicationReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WsJobApplicationReplyInclude<ExtArgs> | null
    /**
     * Filter, which WsJobApplicationReply to fetch.
     */
    where: WsJobApplicationReplyWhereUniqueInput
  }

  /**
   * WsJobApplicationReply findUniqueOrThrow
   */
  export type WsJobApplicationReplyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsJobApplicationReply
     */
    select?: WsJobApplicationReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WsJobApplicationReplyInclude<ExtArgs> | null
    /**
     * Filter, which WsJobApplicationReply to fetch.
     */
    where: WsJobApplicationReplyWhereUniqueInput
  }

  /**
   * WsJobApplicationReply findFirst
   */
  export type WsJobApplicationReplyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsJobApplicationReply
     */
    select?: WsJobApplicationReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WsJobApplicationReplyInclude<ExtArgs> | null
    /**
     * Filter, which WsJobApplicationReply to fetch.
     */
    where?: WsJobApplicationReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WsJobApplicationReplies to fetch.
     */
    orderBy?: WsJobApplicationReplyOrderByWithRelationInput | WsJobApplicationReplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WsJobApplicationReplies.
     */
    cursor?: WsJobApplicationReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WsJobApplicationReplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WsJobApplicationReplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WsJobApplicationReplies.
     */
    distinct?: WsJobApplicationReplyScalarFieldEnum | WsJobApplicationReplyScalarFieldEnum[]
  }

  /**
   * WsJobApplicationReply findFirstOrThrow
   */
  export type WsJobApplicationReplyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsJobApplicationReply
     */
    select?: WsJobApplicationReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WsJobApplicationReplyInclude<ExtArgs> | null
    /**
     * Filter, which WsJobApplicationReply to fetch.
     */
    where?: WsJobApplicationReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WsJobApplicationReplies to fetch.
     */
    orderBy?: WsJobApplicationReplyOrderByWithRelationInput | WsJobApplicationReplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WsJobApplicationReplies.
     */
    cursor?: WsJobApplicationReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WsJobApplicationReplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WsJobApplicationReplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WsJobApplicationReplies.
     */
    distinct?: WsJobApplicationReplyScalarFieldEnum | WsJobApplicationReplyScalarFieldEnum[]
  }

  /**
   * WsJobApplicationReply findMany
   */
  export type WsJobApplicationReplyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsJobApplicationReply
     */
    select?: WsJobApplicationReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WsJobApplicationReplyInclude<ExtArgs> | null
    /**
     * Filter, which WsJobApplicationReplies to fetch.
     */
    where?: WsJobApplicationReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WsJobApplicationReplies to fetch.
     */
    orderBy?: WsJobApplicationReplyOrderByWithRelationInput | WsJobApplicationReplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WsJobApplicationReplies.
     */
    cursor?: WsJobApplicationReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WsJobApplicationReplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WsJobApplicationReplies.
     */
    skip?: number
    distinct?: WsJobApplicationReplyScalarFieldEnum | WsJobApplicationReplyScalarFieldEnum[]
  }

  /**
   * WsJobApplicationReply create
   */
  export type WsJobApplicationReplyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsJobApplicationReply
     */
    select?: WsJobApplicationReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WsJobApplicationReplyInclude<ExtArgs> | null
    /**
     * The data needed to create a WsJobApplicationReply.
     */
    data: XOR<WsJobApplicationReplyCreateInput, WsJobApplicationReplyUncheckedCreateInput>
  }

  /**
   * WsJobApplicationReply createMany
   */
  export type WsJobApplicationReplyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WsJobApplicationReplies.
     */
    data: WsJobApplicationReplyCreateManyInput | WsJobApplicationReplyCreateManyInput[]
  }

  /**
   * WsJobApplicationReply update
   */
  export type WsJobApplicationReplyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsJobApplicationReply
     */
    select?: WsJobApplicationReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WsJobApplicationReplyInclude<ExtArgs> | null
    /**
     * The data needed to update a WsJobApplicationReply.
     */
    data: XOR<WsJobApplicationReplyUpdateInput, WsJobApplicationReplyUncheckedUpdateInput>
    /**
     * Choose, which WsJobApplicationReply to update.
     */
    where: WsJobApplicationReplyWhereUniqueInput
  }

  /**
   * WsJobApplicationReply updateMany
   */
  export type WsJobApplicationReplyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WsJobApplicationReplies.
     */
    data: XOR<WsJobApplicationReplyUpdateManyMutationInput, WsJobApplicationReplyUncheckedUpdateManyInput>
    /**
     * Filter which WsJobApplicationReplies to update
     */
    where?: WsJobApplicationReplyWhereInput
  }

  /**
   * WsJobApplicationReply upsert
   */
  export type WsJobApplicationReplyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsJobApplicationReply
     */
    select?: WsJobApplicationReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WsJobApplicationReplyInclude<ExtArgs> | null
    /**
     * The filter to search for the WsJobApplicationReply to update in case it exists.
     */
    where: WsJobApplicationReplyWhereUniqueInput
    /**
     * In case the WsJobApplicationReply found by the `where` argument doesn't exist, create a new WsJobApplicationReply with this data.
     */
    create: XOR<WsJobApplicationReplyCreateInput, WsJobApplicationReplyUncheckedCreateInput>
    /**
     * In case the WsJobApplicationReply was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WsJobApplicationReplyUpdateInput, WsJobApplicationReplyUncheckedUpdateInput>
  }

  /**
   * WsJobApplicationReply delete
   */
  export type WsJobApplicationReplyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsJobApplicationReply
     */
    select?: WsJobApplicationReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WsJobApplicationReplyInclude<ExtArgs> | null
    /**
     * Filter which WsJobApplicationReply to delete.
     */
    where: WsJobApplicationReplyWhereUniqueInput
  }

  /**
   * WsJobApplicationReply deleteMany
   */
  export type WsJobApplicationReplyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WsJobApplicationReplies to delete
     */
    where?: WsJobApplicationReplyWhereInput
  }

  /**
   * WsJobApplicationReply without action
   */
  export type WsJobApplicationReplyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsJobApplicationReply
     */
    select?: WsJobApplicationReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WsJobApplicationReplyInclude<ExtArgs> | null
  }


  /**
   * Model WsProducts
   */

  export type AggregateWsProducts = {
    _count: WsProductsCountAggregateOutputType | null
    _avg: WsProductsAvgAggregateOutputType | null
    _sum: WsProductsSumAggregateOutputType | null
    _min: WsProductsMinAggregateOutputType | null
    _max: WsProductsMaxAggregateOutputType | null
  }

  export type WsProductsAvgAggregateOutputType = {
    vendor_id: number | null
    top_sold: number | null
  }

  export type WsProductsSumAggregateOutputType = {
    vendor_id: number | null
    top_sold: number | null
  }

  export type WsProductsMinAggregateOutputType = {
    vendor_id: number | null
    item_number: string | null
    description: string | null
    ai_description: string | null
    ai_name: string | null
    dep: string | null
    bucket: string | null
    original_img_url: string | null
    final_img_url: string | null
    top_sold: number | null
    is_home: boolean | null
    is_new_arrival: boolean | null
    status: string | null
    created_on: Date | null
    created_by: string | null
  }

  export type WsProductsMaxAggregateOutputType = {
    vendor_id: number | null
    item_number: string | null
    description: string | null
    ai_description: string | null
    ai_name: string | null
    dep: string | null
    bucket: string | null
    original_img_url: string | null
    final_img_url: string | null
    top_sold: number | null
    is_home: boolean | null
    is_new_arrival: boolean | null
    status: string | null
    created_on: Date | null
    created_by: string | null
  }

  export type WsProductsCountAggregateOutputType = {
    vendor_id: number
    item_number: number
    description: number
    ai_description: number
    ai_name: number
    dep: number
    bucket: number
    original_img_url: number
    final_img_url: number
    top_sold: number
    is_home: number
    is_new_arrival: number
    status: number
    created_on: number
    created_by: number
    _all: number
  }


  export type WsProductsAvgAggregateInputType = {
    vendor_id?: true
    top_sold?: true
  }

  export type WsProductsSumAggregateInputType = {
    vendor_id?: true
    top_sold?: true
  }

  export type WsProductsMinAggregateInputType = {
    vendor_id?: true
    item_number?: true
    description?: true
    ai_description?: true
    ai_name?: true
    dep?: true
    bucket?: true
    original_img_url?: true
    final_img_url?: true
    top_sold?: true
    is_home?: true
    is_new_arrival?: true
    status?: true
    created_on?: true
    created_by?: true
  }

  export type WsProductsMaxAggregateInputType = {
    vendor_id?: true
    item_number?: true
    description?: true
    ai_description?: true
    ai_name?: true
    dep?: true
    bucket?: true
    original_img_url?: true
    final_img_url?: true
    top_sold?: true
    is_home?: true
    is_new_arrival?: true
    status?: true
    created_on?: true
    created_by?: true
  }

  export type WsProductsCountAggregateInputType = {
    vendor_id?: true
    item_number?: true
    description?: true
    ai_description?: true
    ai_name?: true
    dep?: true
    bucket?: true
    original_img_url?: true
    final_img_url?: true
    top_sold?: true
    is_home?: true
    is_new_arrival?: true
    status?: true
    created_on?: true
    created_by?: true
    _all?: true
  }

  export type WsProductsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WsProducts to aggregate.
     */
    where?: WsProductsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WsProducts to fetch.
     */
    orderBy?: WsProductsOrderByWithRelationInput | WsProductsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WsProductsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WsProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WsProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WsProducts
    **/
    _count?: true | WsProductsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WsProductsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WsProductsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WsProductsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WsProductsMaxAggregateInputType
  }

  export type GetWsProductsAggregateType<T extends WsProductsAggregateArgs> = {
        [P in keyof T & keyof AggregateWsProducts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWsProducts[P]>
      : GetScalarType<T[P], AggregateWsProducts[P]>
  }




  export type WsProductsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WsProductsWhereInput
    orderBy?: WsProductsOrderByWithAggregationInput | WsProductsOrderByWithAggregationInput[]
    by: WsProductsScalarFieldEnum[] | WsProductsScalarFieldEnum
    having?: WsProductsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WsProductsCountAggregateInputType | true
    _avg?: WsProductsAvgAggregateInputType
    _sum?: WsProductsSumAggregateInputType
    _min?: WsProductsMinAggregateInputType
    _max?: WsProductsMaxAggregateInputType
  }

  export type WsProductsGroupByOutputType = {
    vendor_id: number
    item_number: string
    description: string | null
    ai_description: string | null
    ai_name: string | null
    dep: string
    bucket: string
    original_img_url: string
    final_img_url: string | null
    top_sold: number | null
    is_home: boolean | null
    is_new_arrival: boolean | null
    status: string | null
    created_on: Date | null
    created_by: string | null
    _count: WsProductsCountAggregateOutputType | null
    _avg: WsProductsAvgAggregateOutputType | null
    _sum: WsProductsSumAggregateOutputType | null
    _min: WsProductsMinAggregateOutputType | null
    _max: WsProductsMaxAggregateOutputType | null
  }

  type GetWsProductsGroupByPayload<T extends WsProductsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WsProductsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WsProductsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WsProductsGroupByOutputType[P]>
            : GetScalarType<T[P], WsProductsGroupByOutputType[P]>
        }
      >
    >


  export type WsProductsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    vendor_id?: boolean
    item_number?: boolean
    description?: boolean
    ai_description?: boolean
    ai_name?: boolean
    dep?: boolean
    bucket?: boolean
    original_img_url?: boolean
    final_img_url?: boolean
    top_sold?: boolean
    is_home?: boolean
    is_new_arrival?: boolean
    status?: boolean
    created_on?: boolean
    created_by?: boolean
    WsDepartments?: boolean | WsDepartmentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wsProducts"]>


  export type WsProductsSelectScalar = {
    vendor_id?: boolean
    item_number?: boolean
    description?: boolean
    ai_description?: boolean
    ai_name?: boolean
    dep?: boolean
    bucket?: boolean
    original_img_url?: boolean
    final_img_url?: boolean
    top_sold?: boolean
    is_home?: boolean
    is_new_arrival?: boolean
    status?: boolean
    created_on?: boolean
    created_by?: boolean
  }

  export type WsProductsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    WsDepartments?: boolean | WsDepartmentsDefaultArgs<ExtArgs>
  }

  export type $WsProductsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WsProducts"
    objects: {
      WsDepartments: Prisma.$WsDepartmentsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      vendor_id: number
      item_number: string
      description: string | null
      ai_description: string | null
      ai_name: string | null
      dep: string
      bucket: string
      original_img_url: string
      final_img_url: string | null
      top_sold: number | null
      is_home: boolean | null
      is_new_arrival: boolean | null
      status: string | null
      created_on: Date | null
      created_by: string | null
    }, ExtArgs["result"]["wsProducts"]>
    composites: {}
  }

  type WsProductsGetPayload<S extends boolean | null | undefined | WsProductsDefaultArgs> = $Result.GetResult<Prisma.$WsProductsPayload, S>

  type WsProductsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WsProductsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WsProductsCountAggregateInputType | true
    }

  export interface WsProductsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WsProducts'], meta: { name: 'WsProducts' } }
    /**
     * Find zero or one WsProducts that matches the filter.
     * @param {WsProductsFindUniqueArgs} args - Arguments to find a WsProducts
     * @example
     * // Get one WsProducts
     * const wsProducts = await prisma.wsProducts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WsProductsFindUniqueArgs>(args: SelectSubset<T, WsProductsFindUniqueArgs<ExtArgs>>): Prisma__WsProductsClient<$Result.GetResult<Prisma.$WsProductsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WsProducts that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WsProductsFindUniqueOrThrowArgs} args - Arguments to find a WsProducts
     * @example
     * // Get one WsProducts
     * const wsProducts = await prisma.wsProducts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WsProductsFindUniqueOrThrowArgs>(args: SelectSubset<T, WsProductsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WsProductsClient<$Result.GetResult<Prisma.$WsProductsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WsProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsProductsFindFirstArgs} args - Arguments to find a WsProducts
     * @example
     * // Get one WsProducts
     * const wsProducts = await prisma.wsProducts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WsProductsFindFirstArgs>(args?: SelectSubset<T, WsProductsFindFirstArgs<ExtArgs>>): Prisma__WsProductsClient<$Result.GetResult<Prisma.$WsProductsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WsProducts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsProductsFindFirstOrThrowArgs} args - Arguments to find a WsProducts
     * @example
     * // Get one WsProducts
     * const wsProducts = await prisma.wsProducts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WsProductsFindFirstOrThrowArgs>(args?: SelectSubset<T, WsProductsFindFirstOrThrowArgs<ExtArgs>>): Prisma__WsProductsClient<$Result.GetResult<Prisma.$WsProductsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WsProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsProductsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WsProducts
     * const wsProducts = await prisma.wsProducts.findMany()
     * 
     * // Get first 10 WsProducts
     * const wsProducts = await prisma.wsProducts.findMany({ take: 10 })
     * 
     * // Only select the `vendor_id`
     * const wsProductsWithVendor_idOnly = await prisma.wsProducts.findMany({ select: { vendor_id: true } })
     * 
     */
    findMany<T extends WsProductsFindManyArgs>(args?: SelectSubset<T, WsProductsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WsProductsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WsProducts.
     * @param {WsProductsCreateArgs} args - Arguments to create a WsProducts.
     * @example
     * // Create one WsProducts
     * const WsProducts = await prisma.wsProducts.create({
     *   data: {
     *     // ... data to create a WsProducts
     *   }
     * })
     * 
     */
    create<T extends WsProductsCreateArgs>(args: SelectSubset<T, WsProductsCreateArgs<ExtArgs>>): Prisma__WsProductsClient<$Result.GetResult<Prisma.$WsProductsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WsProducts.
     * @param {WsProductsCreateManyArgs} args - Arguments to create many WsProducts.
     * @example
     * // Create many WsProducts
     * const wsProducts = await prisma.wsProducts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WsProductsCreateManyArgs>(args?: SelectSubset<T, WsProductsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WsProducts.
     * @param {WsProductsDeleteArgs} args - Arguments to delete one WsProducts.
     * @example
     * // Delete one WsProducts
     * const WsProducts = await prisma.wsProducts.delete({
     *   where: {
     *     // ... filter to delete one WsProducts
     *   }
     * })
     * 
     */
    delete<T extends WsProductsDeleteArgs>(args: SelectSubset<T, WsProductsDeleteArgs<ExtArgs>>): Prisma__WsProductsClient<$Result.GetResult<Prisma.$WsProductsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WsProducts.
     * @param {WsProductsUpdateArgs} args - Arguments to update one WsProducts.
     * @example
     * // Update one WsProducts
     * const wsProducts = await prisma.wsProducts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WsProductsUpdateArgs>(args: SelectSubset<T, WsProductsUpdateArgs<ExtArgs>>): Prisma__WsProductsClient<$Result.GetResult<Prisma.$WsProductsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WsProducts.
     * @param {WsProductsDeleteManyArgs} args - Arguments to filter WsProducts to delete.
     * @example
     * // Delete a few WsProducts
     * const { count } = await prisma.wsProducts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WsProductsDeleteManyArgs>(args?: SelectSubset<T, WsProductsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WsProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsProductsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WsProducts
     * const wsProducts = await prisma.wsProducts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WsProductsUpdateManyArgs>(args: SelectSubset<T, WsProductsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WsProducts.
     * @param {WsProductsUpsertArgs} args - Arguments to update or create a WsProducts.
     * @example
     * // Update or create a WsProducts
     * const wsProducts = await prisma.wsProducts.upsert({
     *   create: {
     *     // ... data to create a WsProducts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WsProducts we want to update
     *   }
     * })
     */
    upsert<T extends WsProductsUpsertArgs>(args: SelectSubset<T, WsProductsUpsertArgs<ExtArgs>>): Prisma__WsProductsClient<$Result.GetResult<Prisma.$WsProductsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WsProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsProductsCountArgs} args - Arguments to filter WsProducts to count.
     * @example
     * // Count the number of WsProducts
     * const count = await prisma.wsProducts.count({
     *   where: {
     *     // ... the filter for the WsProducts we want to count
     *   }
     * })
    **/
    count<T extends WsProductsCountArgs>(
      args?: Subset<T, WsProductsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WsProductsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WsProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsProductsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WsProductsAggregateArgs>(args: Subset<T, WsProductsAggregateArgs>): Prisma.PrismaPromise<GetWsProductsAggregateType<T>>

    /**
     * Group by WsProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsProductsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WsProductsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WsProductsGroupByArgs['orderBy'] }
        : { orderBy?: WsProductsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WsProductsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWsProductsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WsProducts model
   */
  readonly fields: WsProductsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WsProducts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WsProductsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    WsDepartments<T extends WsDepartmentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WsDepartmentsDefaultArgs<ExtArgs>>): Prisma__WsDepartmentsClient<$Result.GetResult<Prisma.$WsDepartmentsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WsProducts model
   */ 
  interface WsProductsFieldRefs {
    readonly vendor_id: FieldRef<"WsProducts", 'Int'>
    readonly item_number: FieldRef<"WsProducts", 'String'>
    readonly description: FieldRef<"WsProducts", 'String'>
    readonly ai_description: FieldRef<"WsProducts", 'String'>
    readonly ai_name: FieldRef<"WsProducts", 'String'>
    readonly dep: FieldRef<"WsProducts", 'String'>
    readonly bucket: FieldRef<"WsProducts", 'String'>
    readonly original_img_url: FieldRef<"WsProducts", 'String'>
    readonly final_img_url: FieldRef<"WsProducts", 'String'>
    readonly top_sold: FieldRef<"WsProducts", 'Int'>
    readonly is_home: FieldRef<"WsProducts", 'Boolean'>
    readonly is_new_arrival: FieldRef<"WsProducts", 'Boolean'>
    readonly status: FieldRef<"WsProducts", 'String'>
    readonly created_on: FieldRef<"WsProducts", 'DateTime'>
    readonly created_by: FieldRef<"WsProducts", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WsProducts findUnique
   */
  export type WsProductsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsProducts
     */
    select?: WsProductsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WsProductsInclude<ExtArgs> | null
    /**
     * Filter, which WsProducts to fetch.
     */
    where: WsProductsWhereUniqueInput
  }

  /**
   * WsProducts findUniqueOrThrow
   */
  export type WsProductsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsProducts
     */
    select?: WsProductsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WsProductsInclude<ExtArgs> | null
    /**
     * Filter, which WsProducts to fetch.
     */
    where: WsProductsWhereUniqueInput
  }

  /**
   * WsProducts findFirst
   */
  export type WsProductsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsProducts
     */
    select?: WsProductsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WsProductsInclude<ExtArgs> | null
    /**
     * Filter, which WsProducts to fetch.
     */
    where?: WsProductsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WsProducts to fetch.
     */
    orderBy?: WsProductsOrderByWithRelationInput | WsProductsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WsProducts.
     */
    cursor?: WsProductsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WsProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WsProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WsProducts.
     */
    distinct?: WsProductsScalarFieldEnum | WsProductsScalarFieldEnum[]
  }

  /**
   * WsProducts findFirstOrThrow
   */
  export type WsProductsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsProducts
     */
    select?: WsProductsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WsProductsInclude<ExtArgs> | null
    /**
     * Filter, which WsProducts to fetch.
     */
    where?: WsProductsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WsProducts to fetch.
     */
    orderBy?: WsProductsOrderByWithRelationInput | WsProductsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WsProducts.
     */
    cursor?: WsProductsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WsProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WsProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WsProducts.
     */
    distinct?: WsProductsScalarFieldEnum | WsProductsScalarFieldEnum[]
  }

  /**
   * WsProducts findMany
   */
  export type WsProductsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsProducts
     */
    select?: WsProductsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WsProductsInclude<ExtArgs> | null
    /**
     * Filter, which WsProducts to fetch.
     */
    where?: WsProductsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WsProducts to fetch.
     */
    orderBy?: WsProductsOrderByWithRelationInput | WsProductsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WsProducts.
     */
    cursor?: WsProductsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WsProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WsProducts.
     */
    skip?: number
    distinct?: WsProductsScalarFieldEnum | WsProductsScalarFieldEnum[]
  }

  /**
   * WsProducts create
   */
  export type WsProductsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsProducts
     */
    select?: WsProductsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WsProductsInclude<ExtArgs> | null
    /**
     * The data needed to create a WsProducts.
     */
    data: XOR<WsProductsCreateInput, WsProductsUncheckedCreateInput>
  }

  /**
   * WsProducts createMany
   */
  export type WsProductsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WsProducts.
     */
    data: WsProductsCreateManyInput | WsProductsCreateManyInput[]
  }

  /**
   * WsProducts update
   */
  export type WsProductsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsProducts
     */
    select?: WsProductsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WsProductsInclude<ExtArgs> | null
    /**
     * The data needed to update a WsProducts.
     */
    data: XOR<WsProductsUpdateInput, WsProductsUncheckedUpdateInput>
    /**
     * Choose, which WsProducts to update.
     */
    where: WsProductsWhereUniqueInput
  }

  /**
   * WsProducts updateMany
   */
  export type WsProductsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WsProducts.
     */
    data: XOR<WsProductsUpdateManyMutationInput, WsProductsUncheckedUpdateManyInput>
    /**
     * Filter which WsProducts to update
     */
    where?: WsProductsWhereInput
  }

  /**
   * WsProducts upsert
   */
  export type WsProductsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsProducts
     */
    select?: WsProductsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WsProductsInclude<ExtArgs> | null
    /**
     * The filter to search for the WsProducts to update in case it exists.
     */
    where: WsProductsWhereUniqueInput
    /**
     * In case the WsProducts found by the `where` argument doesn't exist, create a new WsProducts with this data.
     */
    create: XOR<WsProductsCreateInput, WsProductsUncheckedCreateInput>
    /**
     * In case the WsProducts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WsProductsUpdateInput, WsProductsUncheckedUpdateInput>
  }

  /**
   * WsProducts delete
   */
  export type WsProductsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsProducts
     */
    select?: WsProductsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WsProductsInclude<ExtArgs> | null
    /**
     * Filter which WsProducts to delete.
     */
    where: WsProductsWhereUniqueInput
  }

  /**
   * WsProducts deleteMany
   */
  export type WsProductsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WsProducts to delete
     */
    where?: WsProductsWhereInput
  }

  /**
   * WsProducts without action
   */
  export type WsProductsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsProducts
     */
    select?: WsProductsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WsProductsInclude<ExtArgs> | null
  }


  /**
   * Model WsProfile
   */

  export type AggregateWsProfile = {
    _count: WsProfileCountAggregateOutputType | null
    _avg: WsProfileAvgAggregateOutputType | null
    _sum: WsProfileSumAggregateOutputType | null
    _min: WsProfileMinAggregateOutputType | null
    _max: WsProfileMaxAggregateOutputType | null
  }

  export type WsProfileAvgAggregateOutputType = {
    ID: number | null
    Age: number | null
  }

  export type WsProfileSumAggregateOutputType = {
    ID: number | null
    Age: number | null
  }

  export type WsProfileMinAggregateOutputType = {
    ID: number | null
    FirstName: string | null
    MiddleName: string | null
    LastName: string | null
    Gender: string | null
    Age: number | null
    Email: string | null
    Auth0Id: string | null
  }

  export type WsProfileMaxAggregateOutputType = {
    ID: number | null
    FirstName: string | null
    MiddleName: string | null
    LastName: string | null
    Gender: string | null
    Age: number | null
    Email: string | null
    Auth0Id: string | null
  }

  export type WsProfileCountAggregateOutputType = {
    ID: number
    FirstName: number
    MiddleName: number
    LastName: number
    Gender: number
    Age: number
    Email: number
    Auth0Id: number
    _all: number
  }


  export type WsProfileAvgAggregateInputType = {
    ID?: true
    Age?: true
  }

  export type WsProfileSumAggregateInputType = {
    ID?: true
    Age?: true
  }

  export type WsProfileMinAggregateInputType = {
    ID?: true
    FirstName?: true
    MiddleName?: true
    LastName?: true
    Gender?: true
    Age?: true
    Email?: true
    Auth0Id?: true
  }

  export type WsProfileMaxAggregateInputType = {
    ID?: true
    FirstName?: true
    MiddleName?: true
    LastName?: true
    Gender?: true
    Age?: true
    Email?: true
    Auth0Id?: true
  }

  export type WsProfileCountAggregateInputType = {
    ID?: true
    FirstName?: true
    MiddleName?: true
    LastName?: true
    Gender?: true
    Age?: true
    Email?: true
    Auth0Id?: true
    _all?: true
  }

  export type WsProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WsProfile to aggregate.
     */
    where?: WsProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WsProfiles to fetch.
     */
    orderBy?: WsProfileOrderByWithRelationInput | WsProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WsProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WsProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WsProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WsProfiles
    **/
    _count?: true | WsProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WsProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WsProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WsProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WsProfileMaxAggregateInputType
  }

  export type GetWsProfileAggregateType<T extends WsProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateWsProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWsProfile[P]>
      : GetScalarType<T[P], AggregateWsProfile[P]>
  }




  export type WsProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WsProfileWhereInput
    orderBy?: WsProfileOrderByWithAggregationInput | WsProfileOrderByWithAggregationInput[]
    by: WsProfileScalarFieldEnum[] | WsProfileScalarFieldEnum
    having?: WsProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WsProfileCountAggregateInputType | true
    _avg?: WsProfileAvgAggregateInputType
    _sum?: WsProfileSumAggregateInputType
    _min?: WsProfileMinAggregateInputType
    _max?: WsProfileMaxAggregateInputType
  }

  export type WsProfileGroupByOutputType = {
    ID: number
    FirstName: string
    MiddleName: string | null
    LastName: string
    Gender: string
    Age: number
    Email: string
    Auth0Id: string
    _count: WsProfileCountAggregateOutputType | null
    _avg: WsProfileAvgAggregateOutputType | null
    _sum: WsProfileSumAggregateOutputType | null
    _min: WsProfileMinAggregateOutputType | null
    _max: WsProfileMaxAggregateOutputType | null
  }

  type GetWsProfileGroupByPayload<T extends WsProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WsProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WsProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WsProfileGroupByOutputType[P]>
            : GetScalarType<T[P], WsProfileGroupByOutputType[P]>
        }
      >
    >


  export type WsProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    FirstName?: boolean
    MiddleName?: boolean
    LastName?: boolean
    Gender?: boolean
    Age?: boolean
    Email?: boolean
    Auth0Id?: boolean
  }, ExtArgs["result"]["wsProfile"]>


  export type WsProfileSelectScalar = {
    ID?: boolean
    FirstName?: boolean
    MiddleName?: boolean
    LastName?: boolean
    Gender?: boolean
    Age?: boolean
    Email?: boolean
    Auth0Id?: boolean
  }


  export type $WsProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WsProfile"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      FirstName: string
      MiddleName: string | null
      LastName: string
      Gender: string
      Age: number
      Email: string
      Auth0Id: string
    }, ExtArgs["result"]["wsProfile"]>
    composites: {}
  }

  type WsProfileGetPayload<S extends boolean | null | undefined | WsProfileDefaultArgs> = $Result.GetResult<Prisma.$WsProfilePayload, S>

  type WsProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WsProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WsProfileCountAggregateInputType | true
    }

  export interface WsProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WsProfile'], meta: { name: 'WsProfile' } }
    /**
     * Find zero or one WsProfile that matches the filter.
     * @param {WsProfileFindUniqueArgs} args - Arguments to find a WsProfile
     * @example
     * // Get one WsProfile
     * const wsProfile = await prisma.wsProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WsProfileFindUniqueArgs>(args: SelectSubset<T, WsProfileFindUniqueArgs<ExtArgs>>): Prisma__WsProfileClient<$Result.GetResult<Prisma.$WsProfilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WsProfile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WsProfileFindUniqueOrThrowArgs} args - Arguments to find a WsProfile
     * @example
     * // Get one WsProfile
     * const wsProfile = await prisma.wsProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WsProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, WsProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WsProfileClient<$Result.GetResult<Prisma.$WsProfilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WsProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsProfileFindFirstArgs} args - Arguments to find a WsProfile
     * @example
     * // Get one WsProfile
     * const wsProfile = await prisma.wsProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WsProfileFindFirstArgs>(args?: SelectSubset<T, WsProfileFindFirstArgs<ExtArgs>>): Prisma__WsProfileClient<$Result.GetResult<Prisma.$WsProfilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WsProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsProfileFindFirstOrThrowArgs} args - Arguments to find a WsProfile
     * @example
     * // Get one WsProfile
     * const wsProfile = await prisma.wsProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WsProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, WsProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__WsProfileClient<$Result.GetResult<Prisma.$WsProfilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WsProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WsProfiles
     * const wsProfiles = await prisma.wsProfile.findMany()
     * 
     * // Get first 10 WsProfiles
     * const wsProfiles = await prisma.wsProfile.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const wsProfileWithIDOnly = await prisma.wsProfile.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends WsProfileFindManyArgs>(args?: SelectSubset<T, WsProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WsProfilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WsProfile.
     * @param {WsProfileCreateArgs} args - Arguments to create a WsProfile.
     * @example
     * // Create one WsProfile
     * const WsProfile = await prisma.wsProfile.create({
     *   data: {
     *     // ... data to create a WsProfile
     *   }
     * })
     * 
     */
    create<T extends WsProfileCreateArgs>(args: SelectSubset<T, WsProfileCreateArgs<ExtArgs>>): Prisma__WsProfileClient<$Result.GetResult<Prisma.$WsProfilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WsProfiles.
     * @param {WsProfileCreateManyArgs} args - Arguments to create many WsProfiles.
     * @example
     * // Create many WsProfiles
     * const wsProfile = await prisma.wsProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WsProfileCreateManyArgs>(args?: SelectSubset<T, WsProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WsProfile.
     * @param {WsProfileDeleteArgs} args - Arguments to delete one WsProfile.
     * @example
     * // Delete one WsProfile
     * const WsProfile = await prisma.wsProfile.delete({
     *   where: {
     *     // ... filter to delete one WsProfile
     *   }
     * })
     * 
     */
    delete<T extends WsProfileDeleteArgs>(args: SelectSubset<T, WsProfileDeleteArgs<ExtArgs>>): Prisma__WsProfileClient<$Result.GetResult<Prisma.$WsProfilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WsProfile.
     * @param {WsProfileUpdateArgs} args - Arguments to update one WsProfile.
     * @example
     * // Update one WsProfile
     * const wsProfile = await prisma.wsProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WsProfileUpdateArgs>(args: SelectSubset<T, WsProfileUpdateArgs<ExtArgs>>): Prisma__WsProfileClient<$Result.GetResult<Prisma.$WsProfilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WsProfiles.
     * @param {WsProfileDeleteManyArgs} args - Arguments to filter WsProfiles to delete.
     * @example
     * // Delete a few WsProfiles
     * const { count } = await prisma.wsProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WsProfileDeleteManyArgs>(args?: SelectSubset<T, WsProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WsProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WsProfiles
     * const wsProfile = await prisma.wsProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WsProfileUpdateManyArgs>(args: SelectSubset<T, WsProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WsProfile.
     * @param {WsProfileUpsertArgs} args - Arguments to update or create a WsProfile.
     * @example
     * // Update or create a WsProfile
     * const wsProfile = await prisma.wsProfile.upsert({
     *   create: {
     *     // ... data to create a WsProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WsProfile we want to update
     *   }
     * })
     */
    upsert<T extends WsProfileUpsertArgs>(args: SelectSubset<T, WsProfileUpsertArgs<ExtArgs>>): Prisma__WsProfileClient<$Result.GetResult<Prisma.$WsProfilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WsProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsProfileCountArgs} args - Arguments to filter WsProfiles to count.
     * @example
     * // Count the number of WsProfiles
     * const count = await prisma.wsProfile.count({
     *   where: {
     *     // ... the filter for the WsProfiles we want to count
     *   }
     * })
    **/
    count<T extends WsProfileCountArgs>(
      args?: Subset<T, WsProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WsProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WsProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WsProfileAggregateArgs>(args: Subset<T, WsProfileAggregateArgs>): Prisma.PrismaPromise<GetWsProfileAggregateType<T>>

    /**
     * Group by WsProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WsProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WsProfileGroupByArgs['orderBy'] }
        : { orderBy?: WsProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WsProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWsProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WsProfile model
   */
  readonly fields: WsProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WsProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WsProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WsProfile model
   */ 
  interface WsProfileFieldRefs {
    readonly ID: FieldRef<"WsProfile", 'Int'>
    readonly FirstName: FieldRef<"WsProfile", 'String'>
    readonly MiddleName: FieldRef<"WsProfile", 'String'>
    readonly LastName: FieldRef<"WsProfile", 'String'>
    readonly Gender: FieldRef<"WsProfile", 'String'>
    readonly Age: FieldRef<"WsProfile", 'Int'>
    readonly Email: FieldRef<"WsProfile", 'String'>
    readonly Auth0Id: FieldRef<"WsProfile", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WsProfile findUnique
   */
  export type WsProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsProfile
     */
    select?: WsProfileSelect<ExtArgs> | null
    /**
     * Filter, which WsProfile to fetch.
     */
    where: WsProfileWhereUniqueInput
  }

  /**
   * WsProfile findUniqueOrThrow
   */
  export type WsProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsProfile
     */
    select?: WsProfileSelect<ExtArgs> | null
    /**
     * Filter, which WsProfile to fetch.
     */
    where: WsProfileWhereUniqueInput
  }

  /**
   * WsProfile findFirst
   */
  export type WsProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsProfile
     */
    select?: WsProfileSelect<ExtArgs> | null
    /**
     * Filter, which WsProfile to fetch.
     */
    where?: WsProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WsProfiles to fetch.
     */
    orderBy?: WsProfileOrderByWithRelationInput | WsProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WsProfiles.
     */
    cursor?: WsProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WsProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WsProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WsProfiles.
     */
    distinct?: WsProfileScalarFieldEnum | WsProfileScalarFieldEnum[]
  }

  /**
   * WsProfile findFirstOrThrow
   */
  export type WsProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsProfile
     */
    select?: WsProfileSelect<ExtArgs> | null
    /**
     * Filter, which WsProfile to fetch.
     */
    where?: WsProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WsProfiles to fetch.
     */
    orderBy?: WsProfileOrderByWithRelationInput | WsProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WsProfiles.
     */
    cursor?: WsProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WsProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WsProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WsProfiles.
     */
    distinct?: WsProfileScalarFieldEnum | WsProfileScalarFieldEnum[]
  }

  /**
   * WsProfile findMany
   */
  export type WsProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsProfile
     */
    select?: WsProfileSelect<ExtArgs> | null
    /**
     * Filter, which WsProfiles to fetch.
     */
    where?: WsProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WsProfiles to fetch.
     */
    orderBy?: WsProfileOrderByWithRelationInput | WsProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WsProfiles.
     */
    cursor?: WsProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WsProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WsProfiles.
     */
    skip?: number
    distinct?: WsProfileScalarFieldEnum | WsProfileScalarFieldEnum[]
  }

  /**
   * WsProfile create
   */
  export type WsProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsProfile
     */
    select?: WsProfileSelect<ExtArgs> | null
    /**
     * The data needed to create a WsProfile.
     */
    data: XOR<WsProfileCreateInput, WsProfileUncheckedCreateInput>
  }

  /**
   * WsProfile createMany
   */
  export type WsProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WsProfiles.
     */
    data: WsProfileCreateManyInput | WsProfileCreateManyInput[]
  }

  /**
   * WsProfile update
   */
  export type WsProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsProfile
     */
    select?: WsProfileSelect<ExtArgs> | null
    /**
     * The data needed to update a WsProfile.
     */
    data: XOR<WsProfileUpdateInput, WsProfileUncheckedUpdateInput>
    /**
     * Choose, which WsProfile to update.
     */
    where: WsProfileWhereUniqueInput
  }

  /**
   * WsProfile updateMany
   */
  export type WsProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WsProfiles.
     */
    data: XOR<WsProfileUpdateManyMutationInput, WsProfileUncheckedUpdateManyInput>
    /**
     * Filter which WsProfiles to update
     */
    where?: WsProfileWhereInput
  }

  /**
   * WsProfile upsert
   */
  export type WsProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsProfile
     */
    select?: WsProfileSelect<ExtArgs> | null
    /**
     * The filter to search for the WsProfile to update in case it exists.
     */
    where: WsProfileWhereUniqueInput
    /**
     * In case the WsProfile found by the `where` argument doesn't exist, create a new WsProfile with this data.
     */
    create: XOR<WsProfileCreateInput, WsProfileUncheckedCreateInput>
    /**
     * In case the WsProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WsProfileUpdateInput, WsProfileUncheckedUpdateInput>
  }

  /**
   * WsProfile delete
   */
  export type WsProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsProfile
     */
    select?: WsProfileSelect<ExtArgs> | null
    /**
     * Filter which WsProfile to delete.
     */
    where: WsProfileWhereUniqueInput
  }

  /**
   * WsProfile deleteMany
   */
  export type WsProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WsProfiles to delete
     */
    where?: WsProfileWhereInput
  }

  /**
   * WsProfile without action
   */
  export type WsProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsProfile
     */
    select?: WsProfileSelect<ExtArgs> | null
  }


  /**
   * Model WSState
   */

  export type AggregateWSState = {
    _count: WSStateCountAggregateOutputType | null
    _avg: WSStateAvgAggregateOutputType | null
    _sum: WSStateSumAggregateOutputType | null
    _min: WSStateMinAggregateOutputType | null
    _max: WSStateMaxAggregateOutputType | null
  }

  export type WSStateAvgAggregateOutputType = {
    ID: number | null
    taxExemptId: number | null
  }

  export type WSStateSumAggregateOutputType = {
    ID: number | null
    taxExemptId: number | null
  }

  export type WSStateMinAggregateOutputType = {
    ID: number | null
    state: string | null
    st_licenseNumber: string | null
    st_expiryDate: Date | null
    st_fileUrl: string | null
    ll_licenseNumber: string | null
    ll_expiryDate: Date | null
    ll_fileUrl: string | null
    taxExemptId: number | null
  }

  export type WSStateMaxAggregateOutputType = {
    ID: number | null
    state: string | null
    st_licenseNumber: string | null
    st_expiryDate: Date | null
    st_fileUrl: string | null
    ll_licenseNumber: string | null
    ll_expiryDate: Date | null
    ll_fileUrl: string | null
    taxExemptId: number | null
  }

  export type WSStateCountAggregateOutputType = {
    ID: number
    state: number
    st_licenseNumber: number
    st_expiryDate: number
    st_fileUrl: number
    ll_licenseNumber: number
    ll_expiryDate: number
    ll_fileUrl: number
    taxExemptId: number
    _all: number
  }


  export type WSStateAvgAggregateInputType = {
    ID?: true
    taxExemptId?: true
  }

  export type WSStateSumAggregateInputType = {
    ID?: true
    taxExemptId?: true
  }

  export type WSStateMinAggregateInputType = {
    ID?: true
    state?: true
    st_licenseNumber?: true
    st_expiryDate?: true
    st_fileUrl?: true
    ll_licenseNumber?: true
    ll_expiryDate?: true
    ll_fileUrl?: true
    taxExemptId?: true
  }

  export type WSStateMaxAggregateInputType = {
    ID?: true
    state?: true
    st_licenseNumber?: true
    st_expiryDate?: true
    st_fileUrl?: true
    ll_licenseNumber?: true
    ll_expiryDate?: true
    ll_fileUrl?: true
    taxExemptId?: true
  }

  export type WSStateCountAggregateInputType = {
    ID?: true
    state?: true
    st_licenseNumber?: true
    st_expiryDate?: true
    st_fileUrl?: true
    ll_licenseNumber?: true
    ll_expiryDate?: true
    ll_fileUrl?: true
    taxExemptId?: true
    _all?: true
  }

  export type WSStateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WSState to aggregate.
     */
    where?: WSStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WSStates to fetch.
     */
    orderBy?: WSStateOrderByWithRelationInput | WSStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WSStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WSStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WSStates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WSStates
    **/
    _count?: true | WSStateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WSStateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WSStateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WSStateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WSStateMaxAggregateInputType
  }

  export type GetWSStateAggregateType<T extends WSStateAggregateArgs> = {
        [P in keyof T & keyof AggregateWSState]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWSState[P]>
      : GetScalarType<T[P], AggregateWSState[P]>
  }




  export type WSStateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WSStateWhereInput
    orderBy?: WSStateOrderByWithAggregationInput | WSStateOrderByWithAggregationInput[]
    by: WSStateScalarFieldEnum[] | WSStateScalarFieldEnum
    having?: WSStateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WSStateCountAggregateInputType | true
    _avg?: WSStateAvgAggregateInputType
    _sum?: WSStateSumAggregateInputType
    _min?: WSStateMinAggregateInputType
    _max?: WSStateMaxAggregateInputType
  }

  export type WSStateGroupByOutputType = {
    ID: number
    state: string | null
    st_licenseNumber: string | null
    st_expiryDate: Date | null
    st_fileUrl: string | null
    ll_licenseNumber: string | null
    ll_expiryDate: Date | null
    ll_fileUrl: string | null
    taxExemptId: number | null
    _count: WSStateCountAggregateOutputType | null
    _avg: WSStateAvgAggregateOutputType | null
    _sum: WSStateSumAggregateOutputType | null
    _min: WSStateMinAggregateOutputType | null
    _max: WSStateMaxAggregateOutputType | null
  }

  type GetWSStateGroupByPayload<T extends WSStateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WSStateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WSStateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WSStateGroupByOutputType[P]>
            : GetScalarType<T[P], WSStateGroupByOutputType[P]>
        }
      >
    >


  export type WSStateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    state?: boolean
    st_licenseNumber?: boolean
    st_expiryDate?: boolean
    st_fileUrl?: boolean
    ll_licenseNumber?: boolean
    ll_expiryDate?: boolean
    ll_fileUrl?: boolean
    taxExemptId?: boolean
    WSTaxExempt?: boolean | WSState$WSTaxExemptArgs<ExtArgs>
  }, ExtArgs["result"]["wSState"]>


  export type WSStateSelectScalar = {
    ID?: boolean
    state?: boolean
    st_licenseNumber?: boolean
    st_expiryDate?: boolean
    st_fileUrl?: boolean
    ll_licenseNumber?: boolean
    ll_expiryDate?: boolean
    ll_fileUrl?: boolean
    taxExemptId?: boolean
  }

  export type WSStateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    WSTaxExempt?: boolean | WSState$WSTaxExemptArgs<ExtArgs>
  }

  export type $WSStatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WSState"
    objects: {
      WSTaxExempt: Prisma.$WSTaxExemptPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      state: string | null
      st_licenseNumber: string | null
      st_expiryDate: Date | null
      st_fileUrl: string | null
      ll_licenseNumber: string | null
      ll_expiryDate: Date | null
      ll_fileUrl: string | null
      taxExemptId: number | null
    }, ExtArgs["result"]["wSState"]>
    composites: {}
  }

  type WSStateGetPayload<S extends boolean | null | undefined | WSStateDefaultArgs> = $Result.GetResult<Prisma.$WSStatePayload, S>

  type WSStateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WSStateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WSStateCountAggregateInputType | true
    }

  export interface WSStateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WSState'], meta: { name: 'WSState' } }
    /**
     * Find zero or one WSState that matches the filter.
     * @param {WSStateFindUniqueArgs} args - Arguments to find a WSState
     * @example
     * // Get one WSState
     * const wSState = await prisma.wSState.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WSStateFindUniqueArgs>(args: SelectSubset<T, WSStateFindUniqueArgs<ExtArgs>>): Prisma__WSStateClient<$Result.GetResult<Prisma.$WSStatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WSState that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WSStateFindUniqueOrThrowArgs} args - Arguments to find a WSState
     * @example
     * // Get one WSState
     * const wSState = await prisma.wSState.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WSStateFindUniqueOrThrowArgs>(args: SelectSubset<T, WSStateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WSStateClient<$Result.GetResult<Prisma.$WSStatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WSState that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSStateFindFirstArgs} args - Arguments to find a WSState
     * @example
     * // Get one WSState
     * const wSState = await prisma.wSState.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WSStateFindFirstArgs>(args?: SelectSubset<T, WSStateFindFirstArgs<ExtArgs>>): Prisma__WSStateClient<$Result.GetResult<Prisma.$WSStatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WSState that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSStateFindFirstOrThrowArgs} args - Arguments to find a WSState
     * @example
     * // Get one WSState
     * const wSState = await prisma.wSState.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WSStateFindFirstOrThrowArgs>(args?: SelectSubset<T, WSStateFindFirstOrThrowArgs<ExtArgs>>): Prisma__WSStateClient<$Result.GetResult<Prisma.$WSStatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WSStates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSStateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WSStates
     * const wSStates = await prisma.wSState.findMany()
     * 
     * // Get first 10 WSStates
     * const wSStates = await prisma.wSState.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const wSStateWithIDOnly = await prisma.wSState.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends WSStateFindManyArgs>(args?: SelectSubset<T, WSStateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WSStatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WSState.
     * @param {WSStateCreateArgs} args - Arguments to create a WSState.
     * @example
     * // Create one WSState
     * const WSState = await prisma.wSState.create({
     *   data: {
     *     // ... data to create a WSState
     *   }
     * })
     * 
     */
    create<T extends WSStateCreateArgs>(args: SelectSubset<T, WSStateCreateArgs<ExtArgs>>): Prisma__WSStateClient<$Result.GetResult<Prisma.$WSStatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WSStates.
     * @param {WSStateCreateManyArgs} args - Arguments to create many WSStates.
     * @example
     * // Create many WSStates
     * const wSState = await prisma.wSState.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WSStateCreateManyArgs>(args?: SelectSubset<T, WSStateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WSState.
     * @param {WSStateDeleteArgs} args - Arguments to delete one WSState.
     * @example
     * // Delete one WSState
     * const WSState = await prisma.wSState.delete({
     *   where: {
     *     // ... filter to delete one WSState
     *   }
     * })
     * 
     */
    delete<T extends WSStateDeleteArgs>(args: SelectSubset<T, WSStateDeleteArgs<ExtArgs>>): Prisma__WSStateClient<$Result.GetResult<Prisma.$WSStatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WSState.
     * @param {WSStateUpdateArgs} args - Arguments to update one WSState.
     * @example
     * // Update one WSState
     * const wSState = await prisma.wSState.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WSStateUpdateArgs>(args: SelectSubset<T, WSStateUpdateArgs<ExtArgs>>): Prisma__WSStateClient<$Result.GetResult<Prisma.$WSStatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WSStates.
     * @param {WSStateDeleteManyArgs} args - Arguments to filter WSStates to delete.
     * @example
     * // Delete a few WSStates
     * const { count } = await prisma.wSState.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WSStateDeleteManyArgs>(args?: SelectSubset<T, WSStateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WSStates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSStateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WSStates
     * const wSState = await prisma.wSState.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WSStateUpdateManyArgs>(args: SelectSubset<T, WSStateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WSState.
     * @param {WSStateUpsertArgs} args - Arguments to update or create a WSState.
     * @example
     * // Update or create a WSState
     * const wSState = await prisma.wSState.upsert({
     *   create: {
     *     // ... data to create a WSState
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WSState we want to update
     *   }
     * })
     */
    upsert<T extends WSStateUpsertArgs>(args: SelectSubset<T, WSStateUpsertArgs<ExtArgs>>): Prisma__WSStateClient<$Result.GetResult<Prisma.$WSStatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WSStates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSStateCountArgs} args - Arguments to filter WSStates to count.
     * @example
     * // Count the number of WSStates
     * const count = await prisma.wSState.count({
     *   where: {
     *     // ... the filter for the WSStates we want to count
     *   }
     * })
    **/
    count<T extends WSStateCountArgs>(
      args?: Subset<T, WSStateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WSStateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WSState.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSStateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WSStateAggregateArgs>(args: Subset<T, WSStateAggregateArgs>): Prisma.PrismaPromise<GetWSStateAggregateType<T>>

    /**
     * Group by WSState.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSStateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WSStateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WSStateGroupByArgs['orderBy'] }
        : { orderBy?: WSStateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WSStateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWSStateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WSState model
   */
  readonly fields: WSStateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WSState.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WSStateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    WSTaxExempt<T extends WSState$WSTaxExemptArgs<ExtArgs> = {}>(args?: Subset<T, WSState$WSTaxExemptArgs<ExtArgs>>): Prisma__WSTaxExemptClient<$Result.GetResult<Prisma.$WSTaxExemptPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WSState model
   */ 
  interface WSStateFieldRefs {
    readonly ID: FieldRef<"WSState", 'Int'>
    readonly state: FieldRef<"WSState", 'String'>
    readonly st_licenseNumber: FieldRef<"WSState", 'String'>
    readonly st_expiryDate: FieldRef<"WSState", 'DateTime'>
    readonly st_fileUrl: FieldRef<"WSState", 'String'>
    readonly ll_licenseNumber: FieldRef<"WSState", 'String'>
    readonly ll_expiryDate: FieldRef<"WSState", 'DateTime'>
    readonly ll_fileUrl: FieldRef<"WSState", 'String'>
    readonly taxExemptId: FieldRef<"WSState", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * WSState findUnique
   */
  export type WSStateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSState
     */
    select?: WSStateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSStateInclude<ExtArgs> | null
    /**
     * Filter, which WSState to fetch.
     */
    where: WSStateWhereUniqueInput
  }

  /**
   * WSState findUniqueOrThrow
   */
  export type WSStateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSState
     */
    select?: WSStateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSStateInclude<ExtArgs> | null
    /**
     * Filter, which WSState to fetch.
     */
    where: WSStateWhereUniqueInput
  }

  /**
   * WSState findFirst
   */
  export type WSStateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSState
     */
    select?: WSStateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSStateInclude<ExtArgs> | null
    /**
     * Filter, which WSState to fetch.
     */
    where?: WSStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WSStates to fetch.
     */
    orderBy?: WSStateOrderByWithRelationInput | WSStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WSStates.
     */
    cursor?: WSStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WSStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WSStates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WSStates.
     */
    distinct?: WSStateScalarFieldEnum | WSStateScalarFieldEnum[]
  }

  /**
   * WSState findFirstOrThrow
   */
  export type WSStateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSState
     */
    select?: WSStateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSStateInclude<ExtArgs> | null
    /**
     * Filter, which WSState to fetch.
     */
    where?: WSStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WSStates to fetch.
     */
    orderBy?: WSStateOrderByWithRelationInput | WSStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WSStates.
     */
    cursor?: WSStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WSStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WSStates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WSStates.
     */
    distinct?: WSStateScalarFieldEnum | WSStateScalarFieldEnum[]
  }

  /**
   * WSState findMany
   */
  export type WSStateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSState
     */
    select?: WSStateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSStateInclude<ExtArgs> | null
    /**
     * Filter, which WSStates to fetch.
     */
    where?: WSStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WSStates to fetch.
     */
    orderBy?: WSStateOrderByWithRelationInput | WSStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WSStates.
     */
    cursor?: WSStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WSStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WSStates.
     */
    skip?: number
    distinct?: WSStateScalarFieldEnum | WSStateScalarFieldEnum[]
  }

  /**
   * WSState create
   */
  export type WSStateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSState
     */
    select?: WSStateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSStateInclude<ExtArgs> | null
    /**
     * The data needed to create a WSState.
     */
    data?: XOR<WSStateCreateInput, WSStateUncheckedCreateInput>
  }

  /**
   * WSState createMany
   */
  export type WSStateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WSStates.
     */
    data: WSStateCreateManyInput | WSStateCreateManyInput[]
  }

  /**
   * WSState update
   */
  export type WSStateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSState
     */
    select?: WSStateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSStateInclude<ExtArgs> | null
    /**
     * The data needed to update a WSState.
     */
    data: XOR<WSStateUpdateInput, WSStateUncheckedUpdateInput>
    /**
     * Choose, which WSState to update.
     */
    where: WSStateWhereUniqueInput
  }

  /**
   * WSState updateMany
   */
  export type WSStateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WSStates.
     */
    data: XOR<WSStateUpdateManyMutationInput, WSStateUncheckedUpdateManyInput>
    /**
     * Filter which WSStates to update
     */
    where?: WSStateWhereInput
  }

  /**
   * WSState upsert
   */
  export type WSStateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSState
     */
    select?: WSStateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSStateInclude<ExtArgs> | null
    /**
     * The filter to search for the WSState to update in case it exists.
     */
    where: WSStateWhereUniqueInput
    /**
     * In case the WSState found by the `where` argument doesn't exist, create a new WSState with this data.
     */
    create: XOR<WSStateCreateInput, WSStateUncheckedCreateInput>
    /**
     * In case the WSState was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WSStateUpdateInput, WSStateUncheckedUpdateInput>
  }

  /**
   * WSState delete
   */
  export type WSStateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSState
     */
    select?: WSStateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSStateInclude<ExtArgs> | null
    /**
     * Filter which WSState to delete.
     */
    where: WSStateWhereUniqueInput
  }

  /**
   * WSState deleteMany
   */
  export type WSStateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WSStates to delete
     */
    where?: WSStateWhereInput
  }

  /**
   * WSState.WSTaxExempt
   */
  export type WSState$WSTaxExemptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSTaxExempt
     */
    select?: WSTaxExemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSTaxExemptInclude<ExtArgs> | null
    where?: WSTaxExemptWhereInput
  }

  /**
   * WSState without action
   */
  export type WSStateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSState
     */
    select?: WSStateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSStateInclude<ExtArgs> | null
  }


  /**
   * Model WsStore
   */

  export type AggregateWsStore = {
    _count: WsStoreCountAggregateOutputType | null
    _avg: WsStoreAvgAggregateOutputType | null
    _sum: WsStoreSumAggregateOutputType | null
    _min: WsStoreMinAggregateOutputType | null
    _max: WsStoreMaxAggregateOutputType | null
  }

  export type WsStoreAvgAggregateOutputType = {
    ID: number | null
    Latitude: number | null
    Longitude: number | null
  }

  export type WsStoreSumAggregateOutputType = {
    ID: number | null
    Latitude: number | null
    Longitude: number | null
  }

  export type WsStoreMinAggregateOutputType = {
    ID: number | null
    Name: string | null
    Address: string | null
    Email: string | null
    BookingUrl: string | null
    Latitude: number | null
    Longitude: number | null
    PlaceID: string | null
  }

  export type WsStoreMaxAggregateOutputType = {
    ID: number | null
    Name: string | null
    Address: string | null
    Email: string | null
    BookingUrl: string | null
    Latitude: number | null
    Longitude: number | null
    PlaceID: string | null
  }

  export type WsStoreCountAggregateOutputType = {
    ID: number
    Name: number
    Address: number
    Email: number
    BookingUrl: number
    Latitude: number
    Longitude: number
    PlaceID: number
    _all: number
  }


  export type WsStoreAvgAggregateInputType = {
    ID?: true
    Latitude?: true
    Longitude?: true
  }

  export type WsStoreSumAggregateInputType = {
    ID?: true
    Latitude?: true
    Longitude?: true
  }

  export type WsStoreMinAggregateInputType = {
    ID?: true
    Name?: true
    Address?: true
    Email?: true
    BookingUrl?: true
    Latitude?: true
    Longitude?: true
    PlaceID?: true
  }

  export type WsStoreMaxAggregateInputType = {
    ID?: true
    Name?: true
    Address?: true
    Email?: true
    BookingUrl?: true
    Latitude?: true
    Longitude?: true
    PlaceID?: true
  }

  export type WsStoreCountAggregateInputType = {
    ID?: true
    Name?: true
    Address?: true
    Email?: true
    BookingUrl?: true
    Latitude?: true
    Longitude?: true
    PlaceID?: true
    _all?: true
  }

  export type WsStoreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WsStore to aggregate.
     */
    where?: WsStoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WsStores to fetch.
     */
    orderBy?: WsStoreOrderByWithRelationInput | WsStoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WsStoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WsStores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WsStores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WsStores
    **/
    _count?: true | WsStoreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WsStoreAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WsStoreSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WsStoreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WsStoreMaxAggregateInputType
  }

  export type GetWsStoreAggregateType<T extends WsStoreAggregateArgs> = {
        [P in keyof T & keyof AggregateWsStore]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWsStore[P]>
      : GetScalarType<T[P], AggregateWsStore[P]>
  }




  export type WsStoreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WsStoreWhereInput
    orderBy?: WsStoreOrderByWithAggregationInput | WsStoreOrderByWithAggregationInput[]
    by: WsStoreScalarFieldEnum[] | WsStoreScalarFieldEnum
    having?: WsStoreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WsStoreCountAggregateInputType | true
    _avg?: WsStoreAvgAggregateInputType
    _sum?: WsStoreSumAggregateInputType
    _min?: WsStoreMinAggregateInputType
    _max?: WsStoreMaxAggregateInputType
  }

  export type WsStoreGroupByOutputType = {
    ID: number
    Name: string
    Address: string | null
    Email: string | null
    BookingUrl: string | null
    Latitude: number
    Longitude: number
    PlaceID: string
    _count: WsStoreCountAggregateOutputType | null
    _avg: WsStoreAvgAggregateOutputType | null
    _sum: WsStoreSumAggregateOutputType | null
    _min: WsStoreMinAggregateOutputType | null
    _max: WsStoreMaxAggregateOutputType | null
  }

  type GetWsStoreGroupByPayload<T extends WsStoreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WsStoreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WsStoreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WsStoreGroupByOutputType[P]>
            : GetScalarType<T[P], WsStoreGroupByOutputType[P]>
        }
      >
    >


  export type WsStoreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    Name?: boolean
    Address?: boolean
    Email?: boolean
    BookingUrl?: boolean
    Latitude?: boolean
    Longitude?: boolean
    PlaceID?: boolean
    WSJob?: boolean | WsStore$WSJobArgs<ExtArgs>
    _count?: boolean | WsStoreCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wsStore"]>


  export type WsStoreSelectScalar = {
    ID?: boolean
    Name?: boolean
    Address?: boolean
    Email?: boolean
    BookingUrl?: boolean
    Latitude?: boolean
    Longitude?: boolean
    PlaceID?: boolean
  }

  export type WsStoreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    WSJob?: boolean | WsStore$WSJobArgs<ExtArgs>
    _count?: boolean | WsStoreCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $WsStorePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WsStore"
    objects: {
      WSJob: Prisma.$WSJobPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      Name: string
      Address: string | null
      Email: string | null
      BookingUrl: string | null
      Latitude: number
      Longitude: number
      PlaceID: string
    }, ExtArgs["result"]["wsStore"]>
    composites: {}
  }

  type WsStoreGetPayload<S extends boolean | null | undefined | WsStoreDefaultArgs> = $Result.GetResult<Prisma.$WsStorePayload, S>

  type WsStoreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WsStoreFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WsStoreCountAggregateInputType | true
    }

  export interface WsStoreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WsStore'], meta: { name: 'WsStore' } }
    /**
     * Find zero or one WsStore that matches the filter.
     * @param {WsStoreFindUniqueArgs} args - Arguments to find a WsStore
     * @example
     * // Get one WsStore
     * const wsStore = await prisma.wsStore.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WsStoreFindUniqueArgs>(args: SelectSubset<T, WsStoreFindUniqueArgs<ExtArgs>>): Prisma__WsStoreClient<$Result.GetResult<Prisma.$WsStorePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WsStore that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WsStoreFindUniqueOrThrowArgs} args - Arguments to find a WsStore
     * @example
     * // Get one WsStore
     * const wsStore = await prisma.wsStore.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WsStoreFindUniqueOrThrowArgs>(args: SelectSubset<T, WsStoreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WsStoreClient<$Result.GetResult<Prisma.$WsStorePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WsStore that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsStoreFindFirstArgs} args - Arguments to find a WsStore
     * @example
     * // Get one WsStore
     * const wsStore = await prisma.wsStore.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WsStoreFindFirstArgs>(args?: SelectSubset<T, WsStoreFindFirstArgs<ExtArgs>>): Prisma__WsStoreClient<$Result.GetResult<Prisma.$WsStorePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WsStore that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsStoreFindFirstOrThrowArgs} args - Arguments to find a WsStore
     * @example
     * // Get one WsStore
     * const wsStore = await prisma.wsStore.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WsStoreFindFirstOrThrowArgs>(args?: SelectSubset<T, WsStoreFindFirstOrThrowArgs<ExtArgs>>): Prisma__WsStoreClient<$Result.GetResult<Prisma.$WsStorePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WsStores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsStoreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WsStores
     * const wsStores = await prisma.wsStore.findMany()
     * 
     * // Get first 10 WsStores
     * const wsStores = await prisma.wsStore.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const wsStoreWithIDOnly = await prisma.wsStore.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends WsStoreFindManyArgs>(args?: SelectSubset<T, WsStoreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WsStorePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WsStore.
     * @param {WsStoreCreateArgs} args - Arguments to create a WsStore.
     * @example
     * // Create one WsStore
     * const WsStore = await prisma.wsStore.create({
     *   data: {
     *     // ... data to create a WsStore
     *   }
     * })
     * 
     */
    create<T extends WsStoreCreateArgs>(args: SelectSubset<T, WsStoreCreateArgs<ExtArgs>>): Prisma__WsStoreClient<$Result.GetResult<Prisma.$WsStorePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WsStores.
     * @param {WsStoreCreateManyArgs} args - Arguments to create many WsStores.
     * @example
     * // Create many WsStores
     * const wsStore = await prisma.wsStore.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WsStoreCreateManyArgs>(args?: SelectSubset<T, WsStoreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WsStore.
     * @param {WsStoreDeleteArgs} args - Arguments to delete one WsStore.
     * @example
     * // Delete one WsStore
     * const WsStore = await prisma.wsStore.delete({
     *   where: {
     *     // ... filter to delete one WsStore
     *   }
     * })
     * 
     */
    delete<T extends WsStoreDeleteArgs>(args: SelectSubset<T, WsStoreDeleteArgs<ExtArgs>>): Prisma__WsStoreClient<$Result.GetResult<Prisma.$WsStorePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WsStore.
     * @param {WsStoreUpdateArgs} args - Arguments to update one WsStore.
     * @example
     * // Update one WsStore
     * const wsStore = await prisma.wsStore.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WsStoreUpdateArgs>(args: SelectSubset<T, WsStoreUpdateArgs<ExtArgs>>): Prisma__WsStoreClient<$Result.GetResult<Prisma.$WsStorePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WsStores.
     * @param {WsStoreDeleteManyArgs} args - Arguments to filter WsStores to delete.
     * @example
     * // Delete a few WsStores
     * const { count } = await prisma.wsStore.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WsStoreDeleteManyArgs>(args?: SelectSubset<T, WsStoreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WsStores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsStoreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WsStores
     * const wsStore = await prisma.wsStore.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WsStoreUpdateManyArgs>(args: SelectSubset<T, WsStoreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WsStore.
     * @param {WsStoreUpsertArgs} args - Arguments to update or create a WsStore.
     * @example
     * // Update or create a WsStore
     * const wsStore = await prisma.wsStore.upsert({
     *   create: {
     *     // ... data to create a WsStore
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WsStore we want to update
     *   }
     * })
     */
    upsert<T extends WsStoreUpsertArgs>(args: SelectSubset<T, WsStoreUpsertArgs<ExtArgs>>): Prisma__WsStoreClient<$Result.GetResult<Prisma.$WsStorePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WsStores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsStoreCountArgs} args - Arguments to filter WsStores to count.
     * @example
     * // Count the number of WsStores
     * const count = await prisma.wsStore.count({
     *   where: {
     *     // ... the filter for the WsStores we want to count
     *   }
     * })
    **/
    count<T extends WsStoreCountArgs>(
      args?: Subset<T, WsStoreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WsStoreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WsStore.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsStoreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WsStoreAggregateArgs>(args: Subset<T, WsStoreAggregateArgs>): Prisma.PrismaPromise<GetWsStoreAggregateType<T>>

    /**
     * Group by WsStore.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsStoreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WsStoreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WsStoreGroupByArgs['orderBy'] }
        : { orderBy?: WsStoreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WsStoreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWsStoreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WsStore model
   */
  readonly fields: WsStoreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WsStore.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WsStoreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    WSJob<T extends WsStore$WSJobArgs<ExtArgs> = {}>(args?: Subset<T, WsStore$WSJobArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WSJobPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WsStore model
   */ 
  interface WsStoreFieldRefs {
    readonly ID: FieldRef<"WsStore", 'Int'>
    readonly Name: FieldRef<"WsStore", 'String'>
    readonly Address: FieldRef<"WsStore", 'String'>
    readonly Email: FieldRef<"WsStore", 'String'>
    readonly BookingUrl: FieldRef<"WsStore", 'String'>
    readonly Latitude: FieldRef<"WsStore", 'Float'>
    readonly Longitude: FieldRef<"WsStore", 'Float'>
    readonly PlaceID: FieldRef<"WsStore", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WsStore findUnique
   */
  export type WsStoreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsStore
     */
    select?: WsStoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WsStoreInclude<ExtArgs> | null
    /**
     * Filter, which WsStore to fetch.
     */
    where: WsStoreWhereUniqueInput
  }

  /**
   * WsStore findUniqueOrThrow
   */
  export type WsStoreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsStore
     */
    select?: WsStoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WsStoreInclude<ExtArgs> | null
    /**
     * Filter, which WsStore to fetch.
     */
    where: WsStoreWhereUniqueInput
  }

  /**
   * WsStore findFirst
   */
  export type WsStoreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsStore
     */
    select?: WsStoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WsStoreInclude<ExtArgs> | null
    /**
     * Filter, which WsStore to fetch.
     */
    where?: WsStoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WsStores to fetch.
     */
    orderBy?: WsStoreOrderByWithRelationInput | WsStoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WsStores.
     */
    cursor?: WsStoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WsStores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WsStores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WsStores.
     */
    distinct?: WsStoreScalarFieldEnum | WsStoreScalarFieldEnum[]
  }

  /**
   * WsStore findFirstOrThrow
   */
  export type WsStoreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsStore
     */
    select?: WsStoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WsStoreInclude<ExtArgs> | null
    /**
     * Filter, which WsStore to fetch.
     */
    where?: WsStoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WsStores to fetch.
     */
    orderBy?: WsStoreOrderByWithRelationInput | WsStoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WsStores.
     */
    cursor?: WsStoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WsStores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WsStores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WsStores.
     */
    distinct?: WsStoreScalarFieldEnum | WsStoreScalarFieldEnum[]
  }

  /**
   * WsStore findMany
   */
  export type WsStoreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsStore
     */
    select?: WsStoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WsStoreInclude<ExtArgs> | null
    /**
     * Filter, which WsStores to fetch.
     */
    where?: WsStoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WsStores to fetch.
     */
    orderBy?: WsStoreOrderByWithRelationInput | WsStoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WsStores.
     */
    cursor?: WsStoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WsStores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WsStores.
     */
    skip?: number
    distinct?: WsStoreScalarFieldEnum | WsStoreScalarFieldEnum[]
  }

  /**
   * WsStore create
   */
  export type WsStoreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsStore
     */
    select?: WsStoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WsStoreInclude<ExtArgs> | null
    /**
     * The data needed to create a WsStore.
     */
    data: XOR<WsStoreCreateInput, WsStoreUncheckedCreateInput>
  }

  /**
   * WsStore createMany
   */
  export type WsStoreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WsStores.
     */
    data: WsStoreCreateManyInput | WsStoreCreateManyInput[]
  }

  /**
   * WsStore update
   */
  export type WsStoreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsStore
     */
    select?: WsStoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WsStoreInclude<ExtArgs> | null
    /**
     * The data needed to update a WsStore.
     */
    data: XOR<WsStoreUpdateInput, WsStoreUncheckedUpdateInput>
    /**
     * Choose, which WsStore to update.
     */
    where: WsStoreWhereUniqueInput
  }

  /**
   * WsStore updateMany
   */
  export type WsStoreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WsStores.
     */
    data: XOR<WsStoreUpdateManyMutationInput, WsStoreUncheckedUpdateManyInput>
    /**
     * Filter which WsStores to update
     */
    where?: WsStoreWhereInput
  }

  /**
   * WsStore upsert
   */
  export type WsStoreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsStore
     */
    select?: WsStoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WsStoreInclude<ExtArgs> | null
    /**
     * The filter to search for the WsStore to update in case it exists.
     */
    where: WsStoreWhereUniqueInput
    /**
     * In case the WsStore found by the `where` argument doesn't exist, create a new WsStore with this data.
     */
    create: XOR<WsStoreCreateInput, WsStoreUncheckedCreateInput>
    /**
     * In case the WsStore was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WsStoreUpdateInput, WsStoreUncheckedUpdateInput>
  }

  /**
   * WsStore delete
   */
  export type WsStoreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsStore
     */
    select?: WsStoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WsStoreInclude<ExtArgs> | null
    /**
     * Filter which WsStore to delete.
     */
    where: WsStoreWhereUniqueInput
  }

  /**
   * WsStore deleteMany
   */
  export type WsStoreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WsStores to delete
     */
    where?: WsStoreWhereInput
  }

  /**
   * WsStore.WSJob
   */
  export type WsStore$WSJobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJob
     */
    select?: WSJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobInclude<ExtArgs> | null
    where?: WSJobWhereInput
    orderBy?: WSJobOrderByWithRelationInput | WSJobOrderByWithRelationInput[]
    cursor?: WSJobWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WSJobScalarFieldEnum | WSJobScalarFieldEnum[]
  }

  /**
   * WsStore without action
   */
  export type WsStoreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsStore
     */
    select?: WsStoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WsStoreInclude<ExtArgs> | null
  }


  /**
   * Model WSTaxExempt
   */

  export type AggregateWSTaxExempt = {
    _count: WSTaxExemptCountAggregateOutputType | null
    _avg: WSTaxExemptAvgAggregateOutputType | null
    _sum: WSTaxExemptSumAggregateOutputType | null
    _min: WSTaxExemptMinAggregateOutputType | null
    _max: WSTaxExemptMaxAggregateOutputType | null
  }

  export type WSTaxExemptAvgAggregateOutputType = {
    ID: number | null
  }

  export type WSTaxExemptSumAggregateOutputType = {
    ID: number | null
  }

  export type WSTaxExemptMinAggregateOutputType = {
    ID: number | null
    organization: string | null
    organizationDescription: string | null
    number: string | null
    country: string | null
    streetAddress: string | null
    city: string | null
    state: string | null
    zip: string | null
    mobileNumber: string | null
    apartment: string | null
    purpose: string | null
    organizationType: string | null
    name: string | null
    email: string | null
    status: string | null
    states: string | null
    signerName: string | null
    signerTitle: string | null
    signature: string | null
    certificateType: string | null
  }

  export type WSTaxExemptMaxAggregateOutputType = {
    ID: number | null
    organization: string | null
    organizationDescription: string | null
    number: string | null
    country: string | null
    streetAddress: string | null
    city: string | null
    state: string | null
    zip: string | null
    mobileNumber: string | null
    apartment: string | null
    purpose: string | null
    organizationType: string | null
    name: string | null
    email: string | null
    status: string | null
    states: string | null
    signerName: string | null
    signerTitle: string | null
    signature: string | null
    certificateType: string | null
  }

  export type WSTaxExemptCountAggregateOutputType = {
    ID: number
    organization: number
    organizationDescription: number
    number: number
    country: number
    streetAddress: number
    city: number
    state: number
    zip: number
    mobileNumber: number
    apartment: number
    purpose: number
    organizationType: number
    name: number
    email: number
    status: number
    states: number
    signerName: number
    signerTitle: number
    signature: number
    certificateType: number
    _all: number
  }


  export type WSTaxExemptAvgAggregateInputType = {
    ID?: true
  }

  export type WSTaxExemptSumAggregateInputType = {
    ID?: true
  }

  export type WSTaxExemptMinAggregateInputType = {
    ID?: true
    organization?: true
    organizationDescription?: true
    number?: true
    country?: true
    streetAddress?: true
    city?: true
    state?: true
    zip?: true
    mobileNumber?: true
    apartment?: true
    purpose?: true
    organizationType?: true
    name?: true
    email?: true
    status?: true
    states?: true
    signerName?: true
    signerTitle?: true
    signature?: true
    certificateType?: true
  }

  export type WSTaxExemptMaxAggregateInputType = {
    ID?: true
    organization?: true
    organizationDescription?: true
    number?: true
    country?: true
    streetAddress?: true
    city?: true
    state?: true
    zip?: true
    mobileNumber?: true
    apartment?: true
    purpose?: true
    organizationType?: true
    name?: true
    email?: true
    status?: true
    states?: true
    signerName?: true
    signerTitle?: true
    signature?: true
    certificateType?: true
  }

  export type WSTaxExemptCountAggregateInputType = {
    ID?: true
    organization?: true
    organizationDescription?: true
    number?: true
    country?: true
    streetAddress?: true
    city?: true
    state?: true
    zip?: true
    mobileNumber?: true
    apartment?: true
    purpose?: true
    organizationType?: true
    name?: true
    email?: true
    status?: true
    states?: true
    signerName?: true
    signerTitle?: true
    signature?: true
    certificateType?: true
    _all?: true
  }

  export type WSTaxExemptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WSTaxExempt to aggregate.
     */
    where?: WSTaxExemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WSTaxExempts to fetch.
     */
    orderBy?: WSTaxExemptOrderByWithRelationInput | WSTaxExemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WSTaxExemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WSTaxExempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WSTaxExempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WSTaxExempts
    **/
    _count?: true | WSTaxExemptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WSTaxExemptAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WSTaxExemptSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WSTaxExemptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WSTaxExemptMaxAggregateInputType
  }

  export type GetWSTaxExemptAggregateType<T extends WSTaxExemptAggregateArgs> = {
        [P in keyof T & keyof AggregateWSTaxExempt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWSTaxExempt[P]>
      : GetScalarType<T[P], AggregateWSTaxExempt[P]>
  }




  export type WSTaxExemptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WSTaxExemptWhereInput
    orderBy?: WSTaxExemptOrderByWithAggregationInput | WSTaxExemptOrderByWithAggregationInput[]
    by: WSTaxExemptScalarFieldEnum[] | WSTaxExemptScalarFieldEnum
    having?: WSTaxExemptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WSTaxExemptCountAggregateInputType | true
    _avg?: WSTaxExemptAvgAggregateInputType
    _sum?: WSTaxExemptSumAggregateInputType
    _min?: WSTaxExemptMinAggregateInputType
    _max?: WSTaxExemptMaxAggregateInputType
  }

  export type WSTaxExemptGroupByOutputType = {
    ID: number
    organization: string | null
    organizationDescription: string | null
    number: string | null
    country: string | null
    streetAddress: string | null
    city: string | null
    state: string | null
    zip: string | null
    mobileNumber: string | null
    apartment: string | null
    purpose: string | null
    organizationType: string | null
    name: string | null
    email: string | null
    status: string | null
    states: string | null
    signerName: string | null
    signerTitle: string | null
    signature: string | null
    certificateType: string | null
    _count: WSTaxExemptCountAggregateOutputType | null
    _avg: WSTaxExemptAvgAggregateOutputType | null
    _sum: WSTaxExemptSumAggregateOutputType | null
    _min: WSTaxExemptMinAggregateOutputType | null
    _max: WSTaxExemptMaxAggregateOutputType | null
  }

  type GetWSTaxExemptGroupByPayload<T extends WSTaxExemptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WSTaxExemptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WSTaxExemptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WSTaxExemptGroupByOutputType[P]>
            : GetScalarType<T[P], WSTaxExemptGroupByOutputType[P]>
        }
      >
    >


  export type WSTaxExemptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    organization?: boolean
    organizationDescription?: boolean
    number?: boolean
    country?: boolean
    streetAddress?: boolean
    city?: boolean
    state?: boolean
    zip?: boolean
    mobileNumber?: boolean
    apartment?: boolean
    purpose?: boolean
    organizationType?: boolean
    name?: boolean
    email?: boolean
    status?: boolean
    states?: boolean
    signerName?: boolean
    signerTitle?: boolean
    signature?: boolean
    certificateType?: boolean
    WSState?: boolean | WSTaxExempt$WSStateArgs<ExtArgs>
    _count?: boolean | WSTaxExemptCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wSTaxExempt"]>


  export type WSTaxExemptSelectScalar = {
    ID?: boolean
    organization?: boolean
    organizationDescription?: boolean
    number?: boolean
    country?: boolean
    streetAddress?: boolean
    city?: boolean
    state?: boolean
    zip?: boolean
    mobileNumber?: boolean
    apartment?: boolean
    purpose?: boolean
    organizationType?: boolean
    name?: boolean
    email?: boolean
    status?: boolean
    states?: boolean
    signerName?: boolean
    signerTitle?: boolean
    signature?: boolean
    certificateType?: boolean
  }

  export type WSTaxExemptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    WSState?: boolean | WSTaxExempt$WSStateArgs<ExtArgs>
    _count?: boolean | WSTaxExemptCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $WSTaxExemptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WSTaxExempt"
    objects: {
      WSState: Prisma.$WSStatePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      organization: string | null
      organizationDescription: string | null
      number: string | null
      country: string | null
      streetAddress: string | null
      city: string | null
      state: string | null
      zip: string | null
      mobileNumber: string | null
      apartment: string | null
      purpose: string | null
      organizationType: string | null
      name: string | null
      email: string | null
      status: string | null
      states: string | null
      signerName: string | null
      signerTitle: string | null
      signature: string | null
      certificateType: string | null
    }, ExtArgs["result"]["wSTaxExempt"]>
    composites: {}
  }

  type WSTaxExemptGetPayload<S extends boolean | null | undefined | WSTaxExemptDefaultArgs> = $Result.GetResult<Prisma.$WSTaxExemptPayload, S>

  type WSTaxExemptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WSTaxExemptFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WSTaxExemptCountAggregateInputType | true
    }

  export interface WSTaxExemptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WSTaxExempt'], meta: { name: 'WSTaxExempt' } }
    /**
     * Find zero or one WSTaxExempt that matches the filter.
     * @param {WSTaxExemptFindUniqueArgs} args - Arguments to find a WSTaxExempt
     * @example
     * // Get one WSTaxExempt
     * const wSTaxExempt = await prisma.wSTaxExempt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WSTaxExemptFindUniqueArgs>(args: SelectSubset<T, WSTaxExemptFindUniqueArgs<ExtArgs>>): Prisma__WSTaxExemptClient<$Result.GetResult<Prisma.$WSTaxExemptPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WSTaxExempt that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WSTaxExemptFindUniqueOrThrowArgs} args - Arguments to find a WSTaxExempt
     * @example
     * // Get one WSTaxExempt
     * const wSTaxExempt = await prisma.wSTaxExempt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WSTaxExemptFindUniqueOrThrowArgs>(args: SelectSubset<T, WSTaxExemptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WSTaxExemptClient<$Result.GetResult<Prisma.$WSTaxExemptPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WSTaxExempt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSTaxExemptFindFirstArgs} args - Arguments to find a WSTaxExempt
     * @example
     * // Get one WSTaxExempt
     * const wSTaxExempt = await prisma.wSTaxExempt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WSTaxExemptFindFirstArgs>(args?: SelectSubset<T, WSTaxExemptFindFirstArgs<ExtArgs>>): Prisma__WSTaxExemptClient<$Result.GetResult<Prisma.$WSTaxExemptPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WSTaxExempt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSTaxExemptFindFirstOrThrowArgs} args - Arguments to find a WSTaxExempt
     * @example
     * // Get one WSTaxExempt
     * const wSTaxExempt = await prisma.wSTaxExempt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WSTaxExemptFindFirstOrThrowArgs>(args?: SelectSubset<T, WSTaxExemptFindFirstOrThrowArgs<ExtArgs>>): Prisma__WSTaxExemptClient<$Result.GetResult<Prisma.$WSTaxExemptPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WSTaxExempts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSTaxExemptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WSTaxExempts
     * const wSTaxExempts = await prisma.wSTaxExempt.findMany()
     * 
     * // Get first 10 WSTaxExempts
     * const wSTaxExempts = await prisma.wSTaxExempt.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const wSTaxExemptWithIDOnly = await prisma.wSTaxExempt.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends WSTaxExemptFindManyArgs>(args?: SelectSubset<T, WSTaxExemptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WSTaxExemptPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WSTaxExempt.
     * @param {WSTaxExemptCreateArgs} args - Arguments to create a WSTaxExempt.
     * @example
     * // Create one WSTaxExempt
     * const WSTaxExempt = await prisma.wSTaxExempt.create({
     *   data: {
     *     // ... data to create a WSTaxExempt
     *   }
     * })
     * 
     */
    create<T extends WSTaxExemptCreateArgs>(args: SelectSubset<T, WSTaxExemptCreateArgs<ExtArgs>>): Prisma__WSTaxExemptClient<$Result.GetResult<Prisma.$WSTaxExemptPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WSTaxExempts.
     * @param {WSTaxExemptCreateManyArgs} args - Arguments to create many WSTaxExempts.
     * @example
     * // Create many WSTaxExempts
     * const wSTaxExempt = await prisma.wSTaxExempt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WSTaxExemptCreateManyArgs>(args?: SelectSubset<T, WSTaxExemptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WSTaxExempt.
     * @param {WSTaxExemptDeleteArgs} args - Arguments to delete one WSTaxExempt.
     * @example
     * // Delete one WSTaxExempt
     * const WSTaxExempt = await prisma.wSTaxExempt.delete({
     *   where: {
     *     // ... filter to delete one WSTaxExempt
     *   }
     * })
     * 
     */
    delete<T extends WSTaxExemptDeleteArgs>(args: SelectSubset<T, WSTaxExemptDeleteArgs<ExtArgs>>): Prisma__WSTaxExemptClient<$Result.GetResult<Prisma.$WSTaxExemptPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WSTaxExempt.
     * @param {WSTaxExemptUpdateArgs} args - Arguments to update one WSTaxExempt.
     * @example
     * // Update one WSTaxExempt
     * const wSTaxExempt = await prisma.wSTaxExempt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WSTaxExemptUpdateArgs>(args: SelectSubset<T, WSTaxExemptUpdateArgs<ExtArgs>>): Prisma__WSTaxExemptClient<$Result.GetResult<Prisma.$WSTaxExemptPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WSTaxExempts.
     * @param {WSTaxExemptDeleteManyArgs} args - Arguments to filter WSTaxExempts to delete.
     * @example
     * // Delete a few WSTaxExempts
     * const { count } = await prisma.wSTaxExempt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WSTaxExemptDeleteManyArgs>(args?: SelectSubset<T, WSTaxExemptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WSTaxExempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSTaxExemptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WSTaxExempts
     * const wSTaxExempt = await prisma.wSTaxExempt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WSTaxExemptUpdateManyArgs>(args: SelectSubset<T, WSTaxExemptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WSTaxExempt.
     * @param {WSTaxExemptUpsertArgs} args - Arguments to update or create a WSTaxExempt.
     * @example
     * // Update or create a WSTaxExempt
     * const wSTaxExempt = await prisma.wSTaxExempt.upsert({
     *   create: {
     *     // ... data to create a WSTaxExempt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WSTaxExempt we want to update
     *   }
     * })
     */
    upsert<T extends WSTaxExemptUpsertArgs>(args: SelectSubset<T, WSTaxExemptUpsertArgs<ExtArgs>>): Prisma__WSTaxExemptClient<$Result.GetResult<Prisma.$WSTaxExemptPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WSTaxExempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSTaxExemptCountArgs} args - Arguments to filter WSTaxExempts to count.
     * @example
     * // Count the number of WSTaxExempts
     * const count = await prisma.wSTaxExempt.count({
     *   where: {
     *     // ... the filter for the WSTaxExempts we want to count
     *   }
     * })
    **/
    count<T extends WSTaxExemptCountArgs>(
      args?: Subset<T, WSTaxExemptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WSTaxExemptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WSTaxExempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSTaxExemptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WSTaxExemptAggregateArgs>(args: Subset<T, WSTaxExemptAggregateArgs>): Prisma.PrismaPromise<GetWSTaxExemptAggregateType<T>>

    /**
     * Group by WSTaxExempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WSTaxExemptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WSTaxExemptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WSTaxExemptGroupByArgs['orderBy'] }
        : { orderBy?: WSTaxExemptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WSTaxExemptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWSTaxExemptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WSTaxExempt model
   */
  readonly fields: WSTaxExemptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WSTaxExempt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WSTaxExemptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    WSState<T extends WSTaxExempt$WSStateArgs<ExtArgs> = {}>(args?: Subset<T, WSTaxExempt$WSStateArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WSStatePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WSTaxExempt model
   */ 
  interface WSTaxExemptFieldRefs {
    readonly ID: FieldRef<"WSTaxExempt", 'Int'>
    readonly organization: FieldRef<"WSTaxExempt", 'String'>
    readonly organizationDescription: FieldRef<"WSTaxExempt", 'String'>
    readonly number: FieldRef<"WSTaxExempt", 'String'>
    readonly country: FieldRef<"WSTaxExempt", 'String'>
    readonly streetAddress: FieldRef<"WSTaxExempt", 'String'>
    readonly city: FieldRef<"WSTaxExempt", 'String'>
    readonly state: FieldRef<"WSTaxExempt", 'String'>
    readonly zip: FieldRef<"WSTaxExempt", 'String'>
    readonly mobileNumber: FieldRef<"WSTaxExempt", 'String'>
    readonly apartment: FieldRef<"WSTaxExempt", 'String'>
    readonly purpose: FieldRef<"WSTaxExempt", 'String'>
    readonly organizationType: FieldRef<"WSTaxExempt", 'String'>
    readonly name: FieldRef<"WSTaxExempt", 'String'>
    readonly email: FieldRef<"WSTaxExempt", 'String'>
    readonly status: FieldRef<"WSTaxExempt", 'String'>
    readonly states: FieldRef<"WSTaxExempt", 'String'>
    readonly signerName: FieldRef<"WSTaxExempt", 'String'>
    readonly signerTitle: FieldRef<"WSTaxExempt", 'String'>
    readonly signature: FieldRef<"WSTaxExempt", 'String'>
    readonly certificateType: FieldRef<"WSTaxExempt", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WSTaxExempt findUnique
   */
  export type WSTaxExemptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSTaxExempt
     */
    select?: WSTaxExemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSTaxExemptInclude<ExtArgs> | null
    /**
     * Filter, which WSTaxExempt to fetch.
     */
    where: WSTaxExemptWhereUniqueInput
  }

  /**
   * WSTaxExempt findUniqueOrThrow
   */
  export type WSTaxExemptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSTaxExempt
     */
    select?: WSTaxExemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSTaxExemptInclude<ExtArgs> | null
    /**
     * Filter, which WSTaxExempt to fetch.
     */
    where: WSTaxExemptWhereUniqueInput
  }

  /**
   * WSTaxExempt findFirst
   */
  export type WSTaxExemptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSTaxExempt
     */
    select?: WSTaxExemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSTaxExemptInclude<ExtArgs> | null
    /**
     * Filter, which WSTaxExempt to fetch.
     */
    where?: WSTaxExemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WSTaxExempts to fetch.
     */
    orderBy?: WSTaxExemptOrderByWithRelationInput | WSTaxExemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WSTaxExempts.
     */
    cursor?: WSTaxExemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WSTaxExempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WSTaxExempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WSTaxExempts.
     */
    distinct?: WSTaxExemptScalarFieldEnum | WSTaxExemptScalarFieldEnum[]
  }

  /**
   * WSTaxExempt findFirstOrThrow
   */
  export type WSTaxExemptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSTaxExempt
     */
    select?: WSTaxExemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSTaxExemptInclude<ExtArgs> | null
    /**
     * Filter, which WSTaxExempt to fetch.
     */
    where?: WSTaxExemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WSTaxExempts to fetch.
     */
    orderBy?: WSTaxExemptOrderByWithRelationInput | WSTaxExemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WSTaxExempts.
     */
    cursor?: WSTaxExemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WSTaxExempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WSTaxExempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WSTaxExempts.
     */
    distinct?: WSTaxExemptScalarFieldEnum | WSTaxExemptScalarFieldEnum[]
  }

  /**
   * WSTaxExempt findMany
   */
  export type WSTaxExemptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSTaxExempt
     */
    select?: WSTaxExemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSTaxExemptInclude<ExtArgs> | null
    /**
     * Filter, which WSTaxExempts to fetch.
     */
    where?: WSTaxExemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WSTaxExempts to fetch.
     */
    orderBy?: WSTaxExemptOrderByWithRelationInput | WSTaxExemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WSTaxExempts.
     */
    cursor?: WSTaxExemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WSTaxExempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WSTaxExempts.
     */
    skip?: number
    distinct?: WSTaxExemptScalarFieldEnum | WSTaxExemptScalarFieldEnum[]
  }

  /**
   * WSTaxExempt create
   */
  export type WSTaxExemptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSTaxExempt
     */
    select?: WSTaxExemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSTaxExemptInclude<ExtArgs> | null
    /**
     * The data needed to create a WSTaxExempt.
     */
    data?: XOR<WSTaxExemptCreateInput, WSTaxExemptUncheckedCreateInput>
  }

  /**
   * WSTaxExempt createMany
   */
  export type WSTaxExemptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WSTaxExempts.
     */
    data: WSTaxExemptCreateManyInput | WSTaxExemptCreateManyInput[]
  }

  /**
   * WSTaxExempt update
   */
  export type WSTaxExemptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSTaxExempt
     */
    select?: WSTaxExemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSTaxExemptInclude<ExtArgs> | null
    /**
     * The data needed to update a WSTaxExempt.
     */
    data: XOR<WSTaxExemptUpdateInput, WSTaxExemptUncheckedUpdateInput>
    /**
     * Choose, which WSTaxExempt to update.
     */
    where: WSTaxExemptWhereUniqueInput
  }

  /**
   * WSTaxExempt updateMany
   */
  export type WSTaxExemptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WSTaxExempts.
     */
    data: XOR<WSTaxExemptUpdateManyMutationInput, WSTaxExemptUncheckedUpdateManyInput>
    /**
     * Filter which WSTaxExempts to update
     */
    where?: WSTaxExemptWhereInput
  }

  /**
   * WSTaxExempt upsert
   */
  export type WSTaxExemptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSTaxExempt
     */
    select?: WSTaxExemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSTaxExemptInclude<ExtArgs> | null
    /**
     * The filter to search for the WSTaxExempt to update in case it exists.
     */
    where: WSTaxExemptWhereUniqueInput
    /**
     * In case the WSTaxExempt found by the `where` argument doesn't exist, create a new WSTaxExempt with this data.
     */
    create: XOR<WSTaxExemptCreateInput, WSTaxExemptUncheckedCreateInput>
    /**
     * In case the WSTaxExempt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WSTaxExemptUpdateInput, WSTaxExemptUncheckedUpdateInput>
  }

  /**
   * WSTaxExempt delete
   */
  export type WSTaxExemptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSTaxExempt
     */
    select?: WSTaxExemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSTaxExemptInclude<ExtArgs> | null
    /**
     * Filter which WSTaxExempt to delete.
     */
    where: WSTaxExemptWhereUniqueInput
  }

  /**
   * WSTaxExempt deleteMany
   */
  export type WSTaxExemptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WSTaxExempts to delete
     */
    where?: WSTaxExemptWhereInput
  }

  /**
   * WSTaxExempt.WSState
   */
  export type WSTaxExempt$WSStateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSState
     */
    select?: WSStateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSStateInclude<ExtArgs> | null
    where?: WSStateWhereInput
    orderBy?: WSStateOrderByWithRelationInput | WSStateOrderByWithRelationInput[]
    cursor?: WSStateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WSStateScalarFieldEnum | WSStateScalarFieldEnum[]
  }

  /**
   * WSTaxExempt without action
   */
  export type WSTaxExemptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSTaxExempt
     */
    select?: WSTaxExemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSTaxExemptInclude<ExtArgs> | null
  }


  /**
   * Model WsUser
   */

  export type AggregateWsUser = {
    _count: WsUserCountAggregateOutputType | null
    _avg: WsUserAvgAggregateOutputType | null
    _sum: WsUserSumAggregateOutputType | null
    _min: WsUserMinAggregateOutputType | null
    _max: WsUserMaxAggregateOutputType | null
  }

  export type WsUserAvgAggregateOutputType = {
    ID: number | null
  }

  export type WsUserSumAggregateOutputType = {
    ID: number | null
  }

  export type WsUserMinAggregateOutputType = {
    ID: number | null
    Name: string | null
    MiddleName: string | null
    LastName: string | null
    Street: string | null
    Apartment: string | null
    City: string | null
    State: string | null
    Zip: string | null
    Phone: string | null
    SocialSecurity: string | null
    CanWorkInUs: string | null
    IsLegalAge: string | null
    ServedInMilitary: string | null
    MilitaryBranch: string | null
    MilitaryRank: string | null
    MilitaryTypeOfDischarge: string | null
    ResumeUrl: string | null
    Email: string | null
    Auth0Id: string | null
  }

  export type WsUserMaxAggregateOutputType = {
    ID: number | null
    Name: string | null
    MiddleName: string | null
    LastName: string | null
    Street: string | null
    Apartment: string | null
    City: string | null
    State: string | null
    Zip: string | null
    Phone: string | null
    SocialSecurity: string | null
    CanWorkInUs: string | null
    IsLegalAge: string | null
    ServedInMilitary: string | null
    MilitaryBranch: string | null
    MilitaryRank: string | null
    MilitaryTypeOfDischarge: string | null
    ResumeUrl: string | null
    Email: string | null
    Auth0Id: string | null
  }

  export type WsUserCountAggregateOutputType = {
    ID: number
    Name: number
    MiddleName: number
    LastName: number
    Street: number
    Apartment: number
    City: number
    State: number
    Zip: number
    Phone: number
    SocialSecurity: number
    CanWorkInUs: number
    IsLegalAge: number
    ServedInMilitary: number
    MilitaryBranch: number
    MilitaryRank: number
    MilitaryTypeOfDischarge: number
    ResumeUrl: number
    Email: number
    Auth0Id: number
    _all: number
  }


  export type WsUserAvgAggregateInputType = {
    ID?: true
  }

  export type WsUserSumAggregateInputType = {
    ID?: true
  }

  export type WsUserMinAggregateInputType = {
    ID?: true
    Name?: true
    MiddleName?: true
    LastName?: true
    Street?: true
    Apartment?: true
    City?: true
    State?: true
    Zip?: true
    Phone?: true
    SocialSecurity?: true
    CanWorkInUs?: true
    IsLegalAge?: true
    ServedInMilitary?: true
    MilitaryBranch?: true
    MilitaryRank?: true
    MilitaryTypeOfDischarge?: true
    ResumeUrl?: true
    Email?: true
    Auth0Id?: true
  }

  export type WsUserMaxAggregateInputType = {
    ID?: true
    Name?: true
    MiddleName?: true
    LastName?: true
    Street?: true
    Apartment?: true
    City?: true
    State?: true
    Zip?: true
    Phone?: true
    SocialSecurity?: true
    CanWorkInUs?: true
    IsLegalAge?: true
    ServedInMilitary?: true
    MilitaryBranch?: true
    MilitaryRank?: true
    MilitaryTypeOfDischarge?: true
    ResumeUrl?: true
    Email?: true
    Auth0Id?: true
  }

  export type WsUserCountAggregateInputType = {
    ID?: true
    Name?: true
    MiddleName?: true
    LastName?: true
    Street?: true
    Apartment?: true
    City?: true
    State?: true
    Zip?: true
    Phone?: true
    SocialSecurity?: true
    CanWorkInUs?: true
    IsLegalAge?: true
    ServedInMilitary?: true
    MilitaryBranch?: true
    MilitaryRank?: true
    MilitaryTypeOfDischarge?: true
    ResumeUrl?: true
    Email?: true
    Auth0Id?: true
    _all?: true
  }

  export type WsUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WsUser to aggregate.
     */
    where?: WsUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WsUsers to fetch.
     */
    orderBy?: WsUserOrderByWithRelationInput | WsUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WsUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WsUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WsUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WsUsers
    **/
    _count?: true | WsUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WsUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WsUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WsUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WsUserMaxAggregateInputType
  }

  export type GetWsUserAggregateType<T extends WsUserAggregateArgs> = {
        [P in keyof T & keyof AggregateWsUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWsUser[P]>
      : GetScalarType<T[P], AggregateWsUser[P]>
  }




  export type WsUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WsUserWhereInput
    orderBy?: WsUserOrderByWithAggregationInput | WsUserOrderByWithAggregationInput[]
    by: WsUserScalarFieldEnum[] | WsUserScalarFieldEnum
    having?: WsUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WsUserCountAggregateInputType | true
    _avg?: WsUserAvgAggregateInputType
    _sum?: WsUserSumAggregateInputType
    _min?: WsUserMinAggregateInputType
    _max?: WsUserMaxAggregateInputType
  }

  export type WsUserGroupByOutputType = {
    ID: number
    Name: string
    MiddleName: string | null
    LastName: string
    Street: string
    Apartment: string | null
    City: string
    State: string
    Zip: string
    Phone: string
    SocialSecurity: string
    CanWorkInUs: string
    IsLegalAge: string
    ServedInMilitary: string | null
    MilitaryBranch: string | null
    MilitaryRank: string | null
    MilitaryTypeOfDischarge: string | null
    ResumeUrl: string | null
    Email: string
    Auth0Id: string
    _count: WsUserCountAggregateOutputType | null
    _avg: WsUserAvgAggregateOutputType | null
    _sum: WsUserSumAggregateOutputType | null
    _min: WsUserMinAggregateOutputType | null
    _max: WsUserMaxAggregateOutputType | null
  }

  type GetWsUserGroupByPayload<T extends WsUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WsUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WsUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WsUserGroupByOutputType[P]>
            : GetScalarType<T[P], WsUserGroupByOutputType[P]>
        }
      >
    >


  export type WsUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    Name?: boolean
    MiddleName?: boolean
    LastName?: boolean
    Street?: boolean
    Apartment?: boolean
    City?: boolean
    State?: boolean
    Zip?: boolean
    Phone?: boolean
    SocialSecurity?: boolean
    CanWorkInUs?: boolean
    IsLegalAge?: boolean
    ServedInMilitary?: boolean
    MilitaryBranch?: boolean
    MilitaryRank?: boolean
    MilitaryTypeOfDischarge?: boolean
    ResumeUrl?: boolean
    Email?: boolean
    Auth0Id?: boolean
    WSJobApplication?: boolean | WsUser$WSJobApplicationArgs<ExtArgs>
    _count?: boolean | WsUserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wsUser"]>


  export type WsUserSelectScalar = {
    ID?: boolean
    Name?: boolean
    MiddleName?: boolean
    LastName?: boolean
    Street?: boolean
    Apartment?: boolean
    City?: boolean
    State?: boolean
    Zip?: boolean
    Phone?: boolean
    SocialSecurity?: boolean
    CanWorkInUs?: boolean
    IsLegalAge?: boolean
    ServedInMilitary?: boolean
    MilitaryBranch?: boolean
    MilitaryRank?: boolean
    MilitaryTypeOfDischarge?: boolean
    ResumeUrl?: boolean
    Email?: boolean
    Auth0Id?: boolean
  }

  export type WsUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    WSJobApplication?: boolean | WsUser$WSJobApplicationArgs<ExtArgs>
    _count?: boolean | WsUserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $WsUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WsUser"
    objects: {
      WSJobApplication: Prisma.$WSJobApplicationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      Name: string
      MiddleName: string | null
      LastName: string
      Street: string
      Apartment: string | null
      City: string
      State: string
      Zip: string
      Phone: string
      SocialSecurity: string
      CanWorkInUs: string
      IsLegalAge: string
      ServedInMilitary: string | null
      MilitaryBranch: string | null
      MilitaryRank: string | null
      MilitaryTypeOfDischarge: string | null
      ResumeUrl: string | null
      Email: string
      Auth0Id: string
    }, ExtArgs["result"]["wsUser"]>
    composites: {}
  }

  type WsUserGetPayload<S extends boolean | null | undefined | WsUserDefaultArgs> = $Result.GetResult<Prisma.$WsUserPayload, S>

  type WsUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WsUserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WsUserCountAggregateInputType | true
    }

  export interface WsUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WsUser'], meta: { name: 'WsUser' } }
    /**
     * Find zero or one WsUser that matches the filter.
     * @param {WsUserFindUniqueArgs} args - Arguments to find a WsUser
     * @example
     * // Get one WsUser
     * const wsUser = await prisma.wsUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WsUserFindUniqueArgs>(args: SelectSubset<T, WsUserFindUniqueArgs<ExtArgs>>): Prisma__WsUserClient<$Result.GetResult<Prisma.$WsUserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WsUser that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WsUserFindUniqueOrThrowArgs} args - Arguments to find a WsUser
     * @example
     * // Get one WsUser
     * const wsUser = await prisma.wsUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WsUserFindUniqueOrThrowArgs>(args: SelectSubset<T, WsUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WsUserClient<$Result.GetResult<Prisma.$WsUserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WsUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsUserFindFirstArgs} args - Arguments to find a WsUser
     * @example
     * // Get one WsUser
     * const wsUser = await prisma.wsUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WsUserFindFirstArgs>(args?: SelectSubset<T, WsUserFindFirstArgs<ExtArgs>>): Prisma__WsUserClient<$Result.GetResult<Prisma.$WsUserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WsUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsUserFindFirstOrThrowArgs} args - Arguments to find a WsUser
     * @example
     * // Get one WsUser
     * const wsUser = await prisma.wsUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WsUserFindFirstOrThrowArgs>(args?: SelectSubset<T, WsUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__WsUserClient<$Result.GetResult<Prisma.$WsUserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WsUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WsUsers
     * const wsUsers = await prisma.wsUser.findMany()
     * 
     * // Get first 10 WsUsers
     * const wsUsers = await prisma.wsUser.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const wsUserWithIDOnly = await prisma.wsUser.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends WsUserFindManyArgs>(args?: SelectSubset<T, WsUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WsUserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WsUser.
     * @param {WsUserCreateArgs} args - Arguments to create a WsUser.
     * @example
     * // Create one WsUser
     * const WsUser = await prisma.wsUser.create({
     *   data: {
     *     // ... data to create a WsUser
     *   }
     * })
     * 
     */
    create<T extends WsUserCreateArgs>(args: SelectSubset<T, WsUserCreateArgs<ExtArgs>>): Prisma__WsUserClient<$Result.GetResult<Prisma.$WsUserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WsUsers.
     * @param {WsUserCreateManyArgs} args - Arguments to create many WsUsers.
     * @example
     * // Create many WsUsers
     * const wsUser = await prisma.wsUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WsUserCreateManyArgs>(args?: SelectSubset<T, WsUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WsUser.
     * @param {WsUserDeleteArgs} args - Arguments to delete one WsUser.
     * @example
     * // Delete one WsUser
     * const WsUser = await prisma.wsUser.delete({
     *   where: {
     *     // ... filter to delete one WsUser
     *   }
     * })
     * 
     */
    delete<T extends WsUserDeleteArgs>(args: SelectSubset<T, WsUserDeleteArgs<ExtArgs>>): Prisma__WsUserClient<$Result.GetResult<Prisma.$WsUserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WsUser.
     * @param {WsUserUpdateArgs} args - Arguments to update one WsUser.
     * @example
     * // Update one WsUser
     * const wsUser = await prisma.wsUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WsUserUpdateArgs>(args: SelectSubset<T, WsUserUpdateArgs<ExtArgs>>): Prisma__WsUserClient<$Result.GetResult<Prisma.$WsUserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WsUsers.
     * @param {WsUserDeleteManyArgs} args - Arguments to filter WsUsers to delete.
     * @example
     * // Delete a few WsUsers
     * const { count } = await prisma.wsUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WsUserDeleteManyArgs>(args?: SelectSubset<T, WsUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WsUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WsUsers
     * const wsUser = await prisma.wsUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WsUserUpdateManyArgs>(args: SelectSubset<T, WsUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WsUser.
     * @param {WsUserUpsertArgs} args - Arguments to update or create a WsUser.
     * @example
     * // Update or create a WsUser
     * const wsUser = await prisma.wsUser.upsert({
     *   create: {
     *     // ... data to create a WsUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WsUser we want to update
     *   }
     * })
     */
    upsert<T extends WsUserUpsertArgs>(args: SelectSubset<T, WsUserUpsertArgs<ExtArgs>>): Prisma__WsUserClient<$Result.GetResult<Prisma.$WsUserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WsUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsUserCountArgs} args - Arguments to filter WsUsers to count.
     * @example
     * // Count the number of WsUsers
     * const count = await prisma.wsUser.count({
     *   where: {
     *     // ... the filter for the WsUsers we want to count
     *   }
     * })
    **/
    count<T extends WsUserCountArgs>(
      args?: Subset<T, WsUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WsUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WsUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WsUserAggregateArgs>(args: Subset<T, WsUserAggregateArgs>): Prisma.PrismaPromise<GetWsUserAggregateType<T>>

    /**
     * Group by WsUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WsUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WsUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WsUserGroupByArgs['orderBy'] }
        : { orderBy?: WsUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WsUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWsUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WsUser model
   */
  readonly fields: WsUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WsUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WsUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    WSJobApplication<T extends WsUser$WSJobApplicationArgs<ExtArgs> = {}>(args?: Subset<T, WsUser$WSJobApplicationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WSJobApplicationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WsUser model
   */ 
  interface WsUserFieldRefs {
    readonly ID: FieldRef<"WsUser", 'Int'>
    readonly Name: FieldRef<"WsUser", 'String'>
    readonly MiddleName: FieldRef<"WsUser", 'String'>
    readonly LastName: FieldRef<"WsUser", 'String'>
    readonly Street: FieldRef<"WsUser", 'String'>
    readonly Apartment: FieldRef<"WsUser", 'String'>
    readonly City: FieldRef<"WsUser", 'String'>
    readonly State: FieldRef<"WsUser", 'String'>
    readonly Zip: FieldRef<"WsUser", 'String'>
    readonly Phone: FieldRef<"WsUser", 'String'>
    readonly SocialSecurity: FieldRef<"WsUser", 'String'>
    readonly CanWorkInUs: FieldRef<"WsUser", 'String'>
    readonly IsLegalAge: FieldRef<"WsUser", 'String'>
    readonly ServedInMilitary: FieldRef<"WsUser", 'String'>
    readonly MilitaryBranch: FieldRef<"WsUser", 'String'>
    readonly MilitaryRank: FieldRef<"WsUser", 'String'>
    readonly MilitaryTypeOfDischarge: FieldRef<"WsUser", 'String'>
    readonly ResumeUrl: FieldRef<"WsUser", 'String'>
    readonly Email: FieldRef<"WsUser", 'String'>
    readonly Auth0Id: FieldRef<"WsUser", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WsUser findUnique
   */
  export type WsUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsUser
     */
    select?: WsUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WsUserInclude<ExtArgs> | null
    /**
     * Filter, which WsUser to fetch.
     */
    where: WsUserWhereUniqueInput
  }

  /**
   * WsUser findUniqueOrThrow
   */
  export type WsUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsUser
     */
    select?: WsUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WsUserInclude<ExtArgs> | null
    /**
     * Filter, which WsUser to fetch.
     */
    where: WsUserWhereUniqueInput
  }

  /**
   * WsUser findFirst
   */
  export type WsUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsUser
     */
    select?: WsUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WsUserInclude<ExtArgs> | null
    /**
     * Filter, which WsUser to fetch.
     */
    where?: WsUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WsUsers to fetch.
     */
    orderBy?: WsUserOrderByWithRelationInput | WsUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WsUsers.
     */
    cursor?: WsUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WsUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WsUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WsUsers.
     */
    distinct?: WsUserScalarFieldEnum | WsUserScalarFieldEnum[]
  }

  /**
   * WsUser findFirstOrThrow
   */
  export type WsUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsUser
     */
    select?: WsUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WsUserInclude<ExtArgs> | null
    /**
     * Filter, which WsUser to fetch.
     */
    where?: WsUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WsUsers to fetch.
     */
    orderBy?: WsUserOrderByWithRelationInput | WsUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WsUsers.
     */
    cursor?: WsUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WsUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WsUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WsUsers.
     */
    distinct?: WsUserScalarFieldEnum | WsUserScalarFieldEnum[]
  }

  /**
   * WsUser findMany
   */
  export type WsUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsUser
     */
    select?: WsUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WsUserInclude<ExtArgs> | null
    /**
     * Filter, which WsUsers to fetch.
     */
    where?: WsUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WsUsers to fetch.
     */
    orderBy?: WsUserOrderByWithRelationInput | WsUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WsUsers.
     */
    cursor?: WsUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WsUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WsUsers.
     */
    skip?: number
    distinct?: WsUserScalarFieldEnum | WsUserScalarFieldEnum[]
  }

  /**
   * WsUser create
   */
  export type WsUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsUser
     */
    select?: WsUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WsUserInclude<ExtArgs> | null
    /**
     * The data needed to create a WsUser.
     */
    data: XOR<WsUserCreateInput, WsUserUncheckedCreateInput>
  }

  /**
   * WsUser createMany
   */
  export type WsUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WsUsers.
     */
    data: WsUserCreateManyInput | WsUserCreateManyInput[]
  }

  /**
   * WsUser update
   */
  export type WsUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsUser
     */
    select?: WsUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WsUserInclude<ExtArgs> | null
    /**
     * The data needed to update a WsUser.
     */
    data: XOR<WsUserUpdateInput, WsUserUncheckedUpdateInput>
    /**
     * Choose, which WsUser to update.
     */
    where: WsUserWhereUniqueInput
  }

  /**
   * WsUser updateMany
   */
  export type WsUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WsUsers.
     */
    data: XOR<WsUserUpdateManyMutationInput, WsUserUncheckedUpdateManyInput>
    /**
     * Filter which WsUsers to update
     */
    where?: WsUserWhereInput
  }

  /**
   * WsUser upsert
   */
  export type WsUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsUser
     */
    select?: WsUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WsUserInclude<ExtArgs> | null
    /**
     * The filter to search for the WsUser to update in case it exists.
     */
    where: WsUserWhereUniqueInput
    /**
     * In case the WsUser found by the `where` argument doesn't exist, create a new WsUser with this data.
     */
    create: XOR<WsUserCreateInput, WsUserUncheckedCreateInput>
    /**
     * In case the WsUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WsUserUpdateInput, WsUserUncheckedUpdateInput>
  }

  /**
   * WsUser delete
   */
  export type WsUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsUser
     */
    select?: WsUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WsUserInclude<ExtArgs> | null
    /**
     * Filter which WsUser to delete.
     */
    where: WsUserWhereUniqueInput
  }

  /**
   * WsUser deleteMany
   */
  export type WsUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WsUsers to delete
     */
    where?: WsUserWhereInput
  }

  /**
   * WsUser.WSJobApplication
   */
  export type WsUser$WSJobApplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WSJobApplication
     */
    select?: WSJobApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WSJobApplicationInclude<ExtArgs> | null
    where?: WSJobApplicationWhereInput
    orderBy?: WSJobApplicationOrderByWithRelationInput | WSJobApplicationOrderByWithRelationInput[]
    cursor?: WSJobApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WSJobApplicationScalarFieldEnum | WSJobApplicationScalarFieldEnum[]
  }

  /**
   * WsUser without action
   */
  export type WsUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WsUser
     */
    select?: WsUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WsUserInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable',
    Snapshot: 'Snapshot'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const WsBillboardsScalarFieldEnum: {
    ID: 'ID',
    alias: 'alias',
    description: 'description',
    order: 'order',
    is_enabled: 'is_enabled',
    banner_url: 'banner_url',
    created_on: 'created_on',
    created_by: 'created_by'
  };

  export type WsBillboardsScalarFieldEnum = (typeof WsBillboardsScalarFieldEnum)[keyof typeof WsBillboardsScalarFieldEnum]


  export const WsCategoriesScalarFieldEnum: {
    ID: 'ID',
    Category: 'Category',
    Type: 'Type'
  };

  export type WsCategoriesScalarFieldEnum = (typeof WsCategoriesScalarFieldEnum)[keyof typeof WsCategoriesScalarFieldEnum]


  export const WsDepartmentsScalarFieldEnum: {
    dep: 'dep',
    alias: 'alias',
    order: 'order',
    app_bar: 'app_bar',
    banner_url: 'banner_url',
    created_on: 'created_on',
    created_by: 'created_by'
  };

  export type WsDepartmentsScalarFieldEnum = (typeof WsDepartmentsScalarFieldEnum)[keyof typeof WsDepartmentsScalarFieldEnum]


  export const WsHomeBannersScalarFieldEnum: {
    ID: 'ID',
    dep: 'dep',
    image_url: 'image_url'
  };

  export type WsHomeBannersScalarFieldEnum = (typeof WsHomeBannersScalarFieldEnum)[keyof typeof WsHomeBannersScalarFieldEnum]


  export const WsImagesScalarFieldEnum: {
    vendor_id: 'vendor_id',
    item_number: 'item_number',
    image_url: 'image_url',
    created_on: 'created_on',
    created_by: 'created_by'
  };

  export type WsImagesScalarFieldEnum = (typeof WsImagesScalarFieldEnum)[keyof typeof WsImagesScalarFieldEnum]


  export const WSJobScalarFieldEnum: {
    ID: 'ID',
    Name: 'Name',
    Description: 'Description',
    Type: 'Type',
    Category: 'Category',
    CreatedOn: 'CreatedOn',
    Active: 'Active',
    StoreId: 'StoreId',
    Status: 'Status',
    CreatedBy: 'CreatedBy',
    MaxSalary: 'MaxSalary',
    MinSalary: 'MinSalary',
    SalaryType: 'SalaryType'
  };

  export type WSJobScalarFieldEnum = (typeof WSJobScalarFieldEnum)[keyof typeof WSJobScalarFieldEnum]


  export const WSJobApplicationScalarFieldEnum: {
    ID: 'ID',
    JobId: 'JobId',
    UserId: 'UserId',
    IsValid: 'IsValid',
    Status: 'Status',
    Active: 'Active',
    CreatedBy: 'CreatedBy',
    CreatedOn: 'CreatedOn',
    IsDenied: 'IsDenied'
  };

  export type WSJobApplicationScalarFieldEnum = (typeof WSJobApplicationScalarFieldEnum)[keyof typeof WSJobApplicationScalarFieldEnum]


  export const WSJobApplicationEducationScalarFieldEnum: {
    ID: 'ID',
    JobApplicationId: 'JobApplicationId',
    EducationLevel: 'EducationLevel',
    Name: 'Name',
    Address: 'Address',
    FromDate: 'FromDate',
    ToDate: 'ToDate',
    IsGraduated: 'IsGraduated',
    IsValid: 'IsValid'
  };

  export type WSJobApplicationEducationScalarFieldEnum = (typeof WSJobApplicationEducationScalarFieldEnum)[keyof typeof WSJobApplicationEducationScalarFieldEnum]


  export const WSJobApplicationFeedbackScalarFieldEnum: {
    ID: 'ID',
    JobApplicationID: 'JobApplicationID',
    Feedback: 'Feedback',
    CreatedBy: 'CreatedBy',
    CreatedOn: 'CreatedOn'
  };

  export type WSJobApplicationFeedbackScalarFieldEnum = (typeof WSJobApplicationFeedbackScalarFieldEnum)[keyof typeof WSJobApplicationFeedbackScalarFieldEnum]


  export const WSJobApplicationPreviousEmploymentScalarFieldEnum: {
    ID: 'ID',
    JobApplicationId: 'JobApplicationId',
    Company: 'Company',
    Supervisor: 'Supervisor',
    Address: 'Address',
    FromDate: 'FromDate',
    ToDate: 'ToDate',
    JobTitle: 'JobTitle',
    EndingSalary: 'EndingSalary',
    IsHourlyRate: 'IsHourlyRate',
    LeavingReason: 'LeavingReason',
    IsValid: 'IsValid'
  };

  export type WSJobApplicationPreviousEmploymentScalarFieldEnum = (typeof WSJobApplicationPreviousEmploymentScalarFieldEnum)[keyof typeof WSJobApplicationPreviousEmploymentScalarFieldEnum]


  export const WSJobApplicationReferenceScalarFieldEnum: {
    ID: 'ID',
    JobApplicationId: 'JobApplicationId',
    FullName: 'FullName',
    Relationship: 'Relationship',
    Company: 'Company',
    Phone: 'Phone',
    Email: 'Email',
    IsValid: 'IsValid'
  };

  export type WSJobApplicationReferenceScalarFieldEnum = (typeof WSJobApplicationReferenceScalarFieldEnum)[keyof typeof WSJobApplicationReferenceScalarFieldEnum]


  export const WsJobApplicationReplyScalarFieldEnum: {
    ID: 'ID',
    FeedbackID: 'FeedbackID',
    Message: 'Message',
    CreatedBy: 'CreatedBy',
    CreatedOn: 'CreatedOn',
    ModifiedOn: 'ModifiedOn'
  };

  export type WsJobApplicationReplyScalarFieldEnum = (typeof WsJobApplicationReplyScalarFieldEnum)[keyof typeof WsJobApplicationReplyScalarFieldEnum]


  export const WsProductsScalarFieldEnum: {
    vendor_id: 'vendor_id',
    item_number: 'item_number',
    description: 'description',
    ai_description: 'ai_description',
    ai_name: 'ai_name',
    dep: 'dep',
    bucket: 'bucket',
    original_img_url: 'original_img_url',
    final_img_url: 'final_img_url',
    top_sold: 'top_sold',
    is_home: 'is_home',
    is_new_arrival: 'is_new_arrival',
    status: 'status',
    created_on: 'created_on',
    created_by: 'created_by'
  };

  export type WsProductsScalarFieldEnum = (typeof WsProductsScalarFieldEnum)[keyof typeof WsProductsScalarFieldEnum]


  export const WsProfileScalarFieldEnum: {
    ID: 'ID',
    FirstName: 'FirstName',
    MiddleName: 'MiddleName',
    LastName: 'LastName',
    Gender: 'Gender',
    Age: 'Age',
    Email: 'Email',
    Auth0Id: 'Auth0Id'
  };

  export type WsProfileScalarFieldEnum = (typeof WsProfileScalarFieldEnum)[keyof typeof WsProfileScalarFieldEnum]


  export const WSStateScalarFieldEnum: {
    ID: 'ID',
    state: 'state',
    st_licenseNumber: 'st_licenseNumber',
    st_expiryDate: 'st_expiryDate',
    st_fileUrl: 'st_fileUrl',
    ll_licenseNumber: 'll_licenseNumber',
    ll_expiryDate: 'll_expiryDate',
    ll_fileUrl: 'll_fileUrl',
    taxExemptId: 'taxExemptId'
  };

  export type WSStateScalarFieldEnum = (typeof WSStateScalarFieldEnum)[keyof typeof WSStateScalarFieldEnum]


  export const WsStoreScalarFieldEnum: {
    ID: 'ID',
    Name: 'Name',
    Address: 'Address',
    Email: 'Email',
    BookingUrl: 'BookingUrl',
    Latitude: 'Latitude',
    Longitude: 'Longitude',
    PlaceID: 'PlaceID'
  };

  export type WsStoreScalarFieldEnum = (typeof WsStoreScalarFieldEnum)[keyof typeof WsStoreScalarFieldEnum]


  export const WSTaxExemptScalarFieldEnum: {
    ID: 'ID',
    organization: 'organization',
    organizationDescription: 'organizationDescription',
    number: 'number',
    country: 'country',
    streetAddress: 'streetAddress',
    city: 'city',
    state: 'state',
    zip: 'zip',
    mobileNumber: 'mobileNumber',
    apartment: 'apartment',
    purpose: 'purpose',
    organizationType: 'organizationType',
    name: 'name',
    email: 'email',
    status: 'status',
    states: 'states',
    signerName: 'signerName',
    signerTitle: 'signerTitle',
    signature: 'signature',
    certificateType: 'certificateType'
  };

  export type WSTaxExemptScalarFieldEnum = (typeof WSTaxExemptScalarFieldEnum)[keyof typeof WSTaxExemptScalarFieldEnum]


  export const WsUserScalarFieldEnum: {
    ID: 'ID',
    Name: 'Name',
    MiddleName: 'MiddleName',
    LastName: 'LastName',
    Street: 'Street',
    Apartment: 'Apartment',
    City: 'City',
    State: 'State',
    Zip: 'Zip',
    Phone: 'Phone',
    SocialSecurity: 'SocialSecurity',
    CanWorkInUs: 'CanWorkInUs',
    IsLegalAge: 'IsLegalAge',
    ServedInMilitary: 'ServedInMilitary',
    MilitaryBranch: 'MilitaryBranch',
    MilitaryRank: 'MilitaryRank',
    MilitaryTypeOfDischarge: 'MilitaryTypeOfDischarge',
    ResumeUrl: 'ResumeUrl',
    Email: 'Email',
    Auth0Id: 'Auth0Id'
  };

  export type WsUserScalarFieldEnum = (typeof WsUserScalarFieldEnum)[keyof typeof WsUserScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type WsBillboardsWhereInput = {
    AND?: WsBillboardsWhereInput | WsBillboardsWhereInput[]
    OR?: WsBillboardsWhereInput[]
    NOT?: WsBillboardsWhereInput | WsBillboardsWhereInput[]
    ID?: IntFilter<"WsBillboards"> | number
    alias?: StringNullableFilter<"WsBillboards"> | string | null
    description?: StringNullableFilter<"WsBillboards"> | string | null
    order?: IntNullableFilter<"WsBillboards"> | number | null
    is_enabled?: BoolNullableFilter<"WsBillboards"> | boolean | null
    banner_url?: StringNullableFilter<"WsBillboards"> | string | null
    created_on?: DateTimeNullableFilter<"WsBillboards"> | Date | string | null
    created_by?: StringNullableFilter<"WsBillboards"> | string | null
  }

  export type WsBillboardsOrderByWithRelationInput = {
    ID?: SortOrder
    alias?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    order?: SortOrderInput | SortOrder
    is_enabled?: SortOrderInput | SortOrder
    banner_url?: SortOrderInput | SortOrder
    created_on?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
  }

  export type WsBillboardsWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: WsBillboardsWhereInput | WsBillboardsWhereInput[]
    OR?: WsBillboardsWhereInput[]
    NOT?: WsBillboardsWhereInput | WsBillboardsWhereInput[]
    alias?: StringNullableFilter<"WsBillboards"> | string | null
    description?: StringNullableFilter<"WsBillboards"> | string | null
    order?: IntNullableFilter<"WsBillboards"> | number | null
    is_enabled?: BoolNullableFilter<"WsBillboards"> | boolean | null
    banner_url?: StringNullableFilter<"WsBillboards"> | string | null
    created_on?: DateTimeNullableFilter<"WsBillboards"> | Date | string | null
    created_by?: StringNullableFilter<"WsBillboards"> | string | null
  }, "ID">

  export type WsBillboardsOrderByWithAggregationInput = {
    ID?: SortOrder
    alias?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    order?: SortOrderInput | SortOrder
    is_enabled?: SortOrderInput | SortOrder
    banner_url?: SortOrderInput | SortOrder
    created_on?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    _count?: WsBillboardsCountOrderByAggregateInput
    _avg?: WsBillboardsAvgOrderByAggregateInput
    _max?: WsBillboardsMaxOrderByAggregateInput
    _min?: WsBillboardsMinOrderByAggregateInput
    _sum?: WsBillboardsSumOrderByAggregateInput
  }

  export type WsBillboardsScalarWhereWithAggregatesInput = {
    AND?: WsBillboardsScalarWhereWithAggregatesInput | WsBillboardsScalarWhereWithAggregatesInput[]
    OR?: WsBillboardsScalarWhereWithAggregatesInput[]
    NOT?: WsBillboardsScalarWhereWithAggregatesInput | WsBillboardsScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"WsBillboards"> | number
    alias?: StringNullableWithAggregatesFilter<"WsBillboards"> | string | null
    description?: StringNullableWithAggregatesFilter<"WsBillboards"> | string | null
    order?: IntNullableWithAggregatesFilter<"WsBillboards"> | number | null
    is_enabled?: BoolNullableWithAggregatesFilter<"WsBillboards"> | boolean | null
    banner_url?: StringNullableWithAggregatesFilter<"WsBillboards"> | string | null
    created_on?: DateTimeNullableWithAggregatesFilter<"WsBillboards"> | Date | string | null
    created_by?: StringNullableWithAggregatesFilter<"WsBillboards"> | string | null
  }

  export type WsCategoriesWhereInput = {
    AND?: WsCategoriesWhereInput | WsCategoriesWhereInput[]
    OR?: WsCategoriesWhereInput[]
    NOT?: WsCategoriesWhereInput | WsCategoriesWhereInput[]
    ID?: IntFilter<"WsCategories"> | number
    Category?: StringFilter<"WsCategories"> | string
    Type?: StringFilter<"WsCategories"> | string
  }

  export type WsCategoriesOrderByWithRelationInput = {
    ID?: SortOrder
    Category?: SortOrder
    Type?: SortOrder
  }

  export type WsCategoriesWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: WsCategoriesWhereInput | WsCategoriesWhereInput[]
    OR?: WsCategoriesWhereInput[]
    NOT?: WsCategoriesWhereInput | WsCategoriesWhereInput[]
    Category?: StringFilter<"WsCategories"> | string
    Type?: StringFilter<"WsCategories"> | string
  }, "ID">

  export type WsCategoriesOrderByWithAggregationInput = {
    ID?: SortOrder
    Category?: SortOrder
    Type?: SortOrder
    _count?: WsCategoriesCountOrderByAggregateInput
    _avg?: WsCategoriesAvgOrderByAggregateInput
    _max?: WsCategoriesMaxOrderByAggregateInput
    _min?: WsCategoriesMinOrderByAggregateInput
    _sum?: WsCategoriesSumOrderByAggregateInput
  }

  export type WsCategoriesScalarWhereWithAggregatesInput = {
    AND?: WsCategoriesScalarWhereWithAggregatesInput | WsCategoriesScalarWhereWithAggregatesInput[]
    OR?: WsCategoriesScalarWhereWithAggregatesInput[]
    NOT?: WsCategoriesScalarWhereWithAggregatesInput | WsCategoriesScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"WsCategories"> | number
    Category?: StringWithAggregatesFilter<"WsCategories"> | string
    Type?: StringWithAggregatesFilter<"WsCategories"> | string
  }

  export type WsDepartmentsWhereInput = {
    AND?: WsDepartmentsWhereInput | WsDepartmentsWhereInput[]
    OR?: WsDepartmentsWhereInput[]
    NOT?: WsDepartmentsWhereInput | WsDepartmentsWhereInput[]
    dep?: StringFilter<"WsDepartments"> | string
    alias?: StringNullableFilter<"WsDepartments"> | string | null
    order?: IntNullableFilter<"WsDepartments"> | number | null
    app_bar?: BoolNullableFilter<"WsDepartments"> | boolean | null
    banner_url?: StringNullableFilter<"WsDepartments"> | string | null
    created_on?: DateTimeNullableFilter<"WsDepartments"> | Date | string | null
    created_by?: StringNullableFilter<"WsDepartments"> | string | null
    WsProducts?: WsProductsListRelationFilter
  }

  export type WsDepartmentsOrderByWithRelationInput = {
    dep?: SortOrder
    alias?: SortOrderInput | SortOrder
    order?: SortOrderInput | SortOrder
    app_bar?: SortOrderInput | SortOrder
    banner_url?: SortOrderInput | SortOrder
    created_on?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    WsProducts?: WsProductsOrderByRelationAggregateInput
  }

  export type WsDepartmentsWhereUniqueInput = Prisma.AtLeast<{
    dep?: string
    AND?: WsDepartmentsWhereInput | WsDepartmentsWhereInput[]
    OR?: WsDepartmentsWhereInput[]
    NOT?: WsDepartmentsWhereInput | WsDepartmentsWhereInput[]
    alias?: StringNullableFilter<"WsDepartments"> | string | null
    order?: IntNullableFilter<"WsDepartments"> | number | null
    app_bar?: BoolNullableFilter<"WsDepartments"> | boolean | null
    banner_url?: StringNullableFilter<"WsDepartments"> | string | null
    created_on?: DateTimeNullableFilter<"WsDepartments"> | Date | string | null
    created_by?: StringNullableFilter<"WsDepartments"> | string | null
    WsProducts?: WsProductsListRelationFilter
  }, "dep">

  export type WsDepartmentsOrderByWithAggregationInput = {
    dep?: SortOrder
    alias?: SortOrderInput | SortOrder
    order?: SortOrderInput | SortOrder
    app_bar?: SortOrderInput | SortOrder
    banner_url?: SortOrderInput | SortOrder
    created_on?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    _count?: WsDepartmentsCountOrderByAggregateInput
    _avg?: WsDepartmentsAvgOrderByAggregateInput
    _max?: WsDepartmentsMaxOrderByAggregateInput
    _min?: WsDepartmentsMinOrderByAggregateInput
    _sum?: WsDepartmentsSumOrderByAggregateInput
  }

  export type WsDepartmentsScalarWhereWithAggregatesInput = {
    AND?: WsDepartmentsScalarWhereWithAggregatesInput | WsDepartmentsScalarWhereWithAggregatesInput[]
    OR?: WsDepartmentsScalarWhereWithAggregatesInput[]
    NOT?: WsDepartmentsScalarWhereWithAggregatesInput | WsDepartmentsScalarWhereWithAggregatesInput[]
    dep?: StringWithAggregatesFilter<"WsDepartments"> | string
    alias?: StringNullableWithAggregatesFilter<"WsDepartments"> | string | null
    order?: IntNullableWithAggregatesFilter<"WsDepartments"> | number | null
    app_bar?: BoolNullableWithAggregatesFilter<"WsDepartments"> | boolean | null
    banner_url?: StringNullableWithAggregatesFilter<"WsDepartments"> | string | null
    created_on?: DateTimeNullableWithAggregatesFilter<"WsDepartments"> | Date | string | null
    created_by?: StringNullableWithAggregatesFilter<"WsDepartments"> | string | null
  }

  export type WsHomeBannersWhereInput = {
    AND?: WsHomeBannersWhereInput | WsHomeBannersWhereInput[]
    OR?: WsHomeBannersWhereInput[]
    NOT?: WsHomeBannersWhereInput | WsHomeBannersWhereInput[]
    ID?: IntFilter<"WsHomeBanners"> | number
    dep?: StringFilter<"WsHomeBanners"> | string
    image_url?: StringFilter<"WsHomeBanners"> | string
  }

  export type WsHomeBannersOrderByWithRelationInput = {
    ID?: SortOrder
    dep?: SortOrder
    image_url?: SortOrder
  }

  export type WsHomeBannersWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: WsHomeBannersWhereInput | WsHomeBannersWhereInput[]
    OR?: WsHomeBannersWhereInput[]
    NOT?: WsHomeBannersWhereInput | WsHomeBannersWhereInput[]
    dep?: StringFilter<"WsHomeBanners"> | string
    image_url?: StringFilter<"WsHomeBanners"> | string
  }, "ID">

  export type WsHomeBannersOrderByWithAggregationInput = {
    ID?: SortOrder
    dep?: SortOrder
    image_url?: SortOrder
    _count?: WsHomeBannersCountOrderByAggregateInput
    _avg?: WsHomeBannersAvgOrderByAggregateInput
    _max?: WsHomeBannersMaxOrderByAggregateInput
    _min?: WsHomeBannersMinOrderByAggregateInput
    _sum?: WsHomeBannersSumOrderByAggregateInput
  }

  export type WsHomeBannersScalarWhereWithAggregatesInput = {
    AND?: WsHomeBannersScalarWhereWithAggregatesInput | WsHomeBannersScalarWhereWithAggregatesInput[]
    OR?: WsHomeBannersScalarWhereWithAggregatesInput[]
    NOT?: WsHomeBannersScalarWhereWithAggregatesInput | WsHomeBannersScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"WsHomeBanners"> | number
    dep?: StringWithAggregatesFilter<"WsHomeBanners"> | string
    image_url?: StringWithAggregatesFilter<"WsHomeBanners"> | string
  }

  export type WsImagesWhereInput = {
    AND?: WsImagesWhereInput | WsImagesWhereInput[]
    OR?: WsImagesWhereInput[]
    NOT?: WsImagesWhereInput | WsImagesWhereInput[]
    vendor_id?: IntFilter<"WsImages"> | number
    item_number?: StringFilter<"WsImages"> | string
    image_url?: StringNullableFilter<"WsImages"> | string | null
    created_on?: DateTimeNullableFilter<"WsImages"> | Date | string | null
    created_by?: StringNullableFilter<"WsImages"> | string | null
  }

  export type WsImagesOrderByWithRelationInput = {
    vendor_id?: SortOrder
    item_number?: SortOrder
    image_url?: SortOrderInput | SortOrder
    created_on?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
  }

  export type WsImagesWhereUniqueInput = Prisma.AtLeast<{
    vendor_id_item_number?: WsImagesVendor_idItem_numberCompoundUniqueInput
    AND?: WsImagesWhereInput | WsImagesWhereInput[]
    OR?: WsImagesWhereInput[]
    NOT?: WsImagesWhereInput | WsImagesWhereInput[]
    vendor_id?: IntFilter<"WsImages"> | number
    item_number?: StringFilter<"WsImages"> | string
    image_url?: StringNullableFilter<"WsImages"> | string | null
    created_on?: DateTimeNullableFilter<"WsImages"> | Date | string | null
    created_by?: StringNullableFilter<"WsImages"> | string | null
  }, "vendor_id_item_number">

  export type WsImagesOrderByWithAggregationInput = {
    vendor_id?: SortOrder
    item_number?: SortOrder
    image_url?: SortOrderInput | SortOrder
    created_on?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    _count?: WsImagesCountOrderByAggregateInput
    _avg?: WsImagesAvgOrderByAggregateInput
    _max?: WsImagesMaxOrderByAggregateInput
    _min?: WsImagesMinOrderByAggregateInput
    _sum?: WsImagesSumOrderByAggregateInput
  }

  export type WsImagesScalarWhereWithAggregatesInput = {
    AND?: WsImagesScalarWhereWithAggregatesInput | WsImagesScalarWhereWithAggregatesInput[]
    OR?: WsImagesScalarWhereWithAggregatesInput[]
    NOT?: WsImagesScalarWhereWithAggregatesInput | WsImagesScalarWhereWithAggregatesInput[]
    vendor_id?: IntWithAggregatesFilter<"WsImages"> | number
    item_number?: StringWithAggregatesFilter<"WsImages"> | string
    image_url?: StringNullableWithAggregatesFilter<"WsImages"> | string | null
    created_on?: DateTimeNullableWithAggregatesFilter<"WsImages"> | Date | string | null
    created_by?: StringNullableWithAggregatesFilter<"WsImages"> | string | null
  }

  export type WSJobWhereInput = {
    AND?: WSJobWhereInput | WSJobWhereInput[]
    OR?: WSJobWhereInput[]
    NOT?: WSJobWhereInput | WSJobWhereInput[]
    ID?: IntFilter<"WSJob"> | number
    Name?: StringFilter<"WSJob"> | string
    Description?: StringNullableFilter<"WSJob"> | string | null
    Type?: StringNullableFilter<"WSJob"> | string | null
    Category?: StringNullableFilter<"WSJob"> | string | null
    CreatedOn?: DateTimeNullableFilter<"WSJob"> | Date | string | null
    Active?: BoolFilter<"WSJob"> | boolean
    StoreId?: IntFilter<"WSJob"> | number
    Status?: StringNullableFilter<"WSJob"> | string | null
    CreatedBy?: StringFilter<"WSJob"> | string
    MaxSalary?: FloatFilter<"WSJob"> | number
    MinSalary?: FloatFilter<"WSJob"> | number
    SalaryType?: StringFilter<"WSJob"> | string
    WsStore?: XOR<WsStoreRelationFilter, WsStoreWhereInput>
    WSJobApplication?: WSJobApplicationListRelationFilter
  }

  export type WSJobOrderByWithRelationInput = {
    ID?: SortOrder
    Name?: SortOrder
    Description?: SortOrderInput | SortOrder
    Type?: SortOrderInput | SortOrder
    Category?: SortOrderInput | SortOrder
    CreatedOn?: SortOrderInput | SortOrder
    Active?: SortOrder
    StoreId?: SortOrder
    Status?: SortOrderInput | SortOrder
    CreatedBy?: SortOrder
    MaxSalary?: SortOrder
    MinSalary?: SortOrder
    SalaryType?: SortOrder
    WsStore?: WsStoreOrderByWithRelationInput
    WSJobApplication?: WSJobApplicationOrderByRelationAggregateInput
  }

  export type WSJobWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: WSJobWhereInput | WSJobWhereInput[]
    OR?: WSJobWhereInput[]
    NOT?: WSJobWhereInput | WSJobWhereInput[]
    Name?: StringFilter<"WSJob"> | string
    Description?: StringNullableFilter<"WSJob"> | string | null
    Type?: StringNullableFilter<"WSJob"> | string | null
    Category?: StringNullableFilter<"WSJob"> | string | null
    CreatedOn?: DateTimeNullableFilter<"WSJob"> | Date | string | null
    Active?: BoolFilter<"WSJob"> | boolean
    StoreId?: IntFilter<"WSJob"> | number
    Status?: StringNullableFilter<"WSJob"> | string | null
    CreatedBy?: StringFilter<"WSJob"> | string
    MaxSalary?: FloatFilter<"WSJob"> | number
    MinSalary?: FloatFilter<"WSJob"> | number
    SalaryType?: StringFilter<"WSJob"> | string
    WsStore?: XOR<WsStoreRelationFilter, WsStoreWhereInput>
    WSJobApplication?: WSJobApplicationListRelationFilter
  }, "ID">

  export type WSJobOrderByWithAggregationInput = {
    ID?: SortOrder
    Name?: SortOrder
    Description?: SortOrderInput | SortOrder
    Type?: SortOrderInput | SortOrder
    Category?: SortOrderInput | SortOrder
    CreatedOn?: SortOrderInput | SortOrder
    Active?: SortOrder
    StoreId?: SortOrder
    Status?: SortOrderInput | SortOrder
    CreatedBy?: SortOrder
    MaxSalary?: SortOrder
    MinSalary?: SortOrder
    SalaryType?: SortOrder
    _count?: WSJobCountOrderByAggregateInput
    _avg?: WSJobAvgOrderByAggregateInput
    _max?: WSJobMaxOrderByAggregateInput
    _min?: WSJobMinOrderByAggregateInput
    _sum?: WSJobSumOrderByAggregateInput
  }

  export type WSJobScalarWhereWithAggregatesInput = {
    AND?: WSJobScalarWhereWithAggregatesInput | WSJobScalarWhereWithAggregatesInput[]
    OR?: WSJobScalarWhereWithAggregatesInput[]
    NOT?: WSJobScalarWhereWithAggregatesInput | WSJobScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"WSJob"> | number
    Name?: StringWithAggregatesFilter<"WSJob"> | string
    Description?: StringNullableWithAggregatesFilter<"WSJob"> | string | null
    Type?: StringNullableWithAggregatesFilter<"WSJob"> | string | null
    Category?: StringNullableWithAggregatesFilter<"WSJob"> | string | null
    CreatedOn?: DateTimeNullableWithAggregatesFilter<"WSJob"> | Date | string | null
    Active?: BoolWithAggregatesFilter<"WSJob"> | boolean
    StoreId?: IntWithAggregatesFilter<"WSJob"> | number
    Status?: StringNullableWithAggregatesFilter<"WSJob"> | string | null
    CreatedBy?: StringWithAggregatesFilter<"WSJob"> | string
    MaxSalary?: FloatWithAggregatesFilter<"WSJob"> | number
    MinSalary?: FloatWithAggregatesFilter<"WSJob"> | number
    SalaryType?: StringWithAggregatesFilter<"WSJob"> | string
  }

  export type WSJobApplicationWhereInput = {
    AND?: WSJobApplicationWhereInput | WSJobApplicationWhereInput[]
    OR?: WSJobApplicationWhereInput[]
    NOT?: WSJobApplicationWhereInput | WSJobApplicationWhereInput[]
    ID?: IntFilter<"WSJobApplication"> | number
    JobId?: IntFilter<"WSJobApplication"> | number
    UserId?: IntFilter<"WSJobApplication"> | number
    IsValid?: StringNullableFilter<"WSJobApplication"> | string | null
    Status?: StringNullableFilter<"WSJobApplication"> | string | null
    Active?: BoolFilter<"WSJobApplication"> | boolean
    CreatedBy?: StringNullableFilter<"WSJobApplication"> | string | null
    CreatedOn?: DateTimeNullableFilter<"WSJobApplication"> | Date | string | null
    IsDenied?: BoolFilter<"WSJobApplication"> | boolean
    WSJob?: XOR<WSJobRelationFilter, WSJobWhereInput>
    WsUser?: XOR<WsUserRelationFilter, WsUserWhereInput>
    WSJobApplicationEducation?: WSJobApplicationEducationListRelationFilter
    WSJobApplicationFeedback?: WSJobApplicationFeedbackListRelationFilter
    WSJobApplicationPreviousEmployment?: WSJobApplicationPreviousEmploymentListRelationFilter
    WSJobApplicationReference?: WSJobApplicationReferenceListRelationFilter
  }

  export type WSJobApplicationOrderByWithRelationInput = {
    ID?: SortOrder
    JobId?: SortOrder
    UserId?: SortOrder
    IsValid?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    Active?: SortOrder
    CreatedBy?: SortOrderInput | SortOrder
    CreatedOn?: SortOrderInput | SortOrder
    IsDenied?: SortOrder
    WSJob?: WSJobOrderByWithRelationInput
    WsUser?: WsUserOrderByWithRelationInput
    WSJobApplicationEducation?: WSJobApplicationEducationOrderByRelationAggregateInput
    WSJobApplicationFeedback?: WSJobApplicationFeedbackOrderByRelationAggregateInput
    WSJobApplicationPreviousEmployment?: WSJobApplicationPreviousEmploymentOrderByRelationAggregateInput
    WSJobApplicationReference?: WSJobApplicationReferenceOrderByRelationAggregateInput
  }

  export type WSJobApplicationWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: WSJobApplicationWhereInput | WSJobApplicationWhereInput[]
    OR?: WSJobApplicationWhereInput[]
    NOT?: WSJobApplicationWhereInput | WSJobApplicationWhereInput[]
    JobId?: IntFilter<"WSJobApplication"> | number
    UserId?: IntFilter<"WSJobApplication"> | number
    IsValid?: StringNullableFilter<"WSJobApplication"> | string | null
    Status?: StringNullableFilter<"WSJobApplication"> | string | null
    Active?: BoolFilter<"WSJobApplication"> | boolean
    CreatedBy?: StringNullableFilter<"WSJobApplication"> | string | null
    CreatedOn?: DateTimeNullableFilter<"WSJobApplication"> | Date | string | null
    IsDenied?: BoolFilter<"WSJobApplication"> | boolean
    WSJob?: XOR<WSJobRelationFilter, WSJobWhereInput>
    WsUser?: XOR<WsUserRelationFilter, WsUserWhereInput>
    WSJobApplicationEducation?: WSJobApplicationEducationListRelationFilter
    WSJobApplicationFeedback?: WSJobApplicationFeedbackListRelationFilter
    WSJobApplicationPreviousEmployment?: WSJobApplicationPreviousEmploymentListRelationFilter
    WSJobApplicationReference?: WSJobApplicationReferenceListRelationFilter
  }, "ID">

  export type WSJobApplicationOrderByWithAggregationInput = {
    ID?: SortOrder
    JobId?: SortOrder
    UserId?: SortOrder
    IsValid?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    Active?: SortOrder
    CreatedBy?: SortOrderInput | SortOrder
    CreatedOn?: SortOrderInput | SortOrder
    IsDenied?: SortOrder
    _count?: WSJobApplicationCountOrderByAggregateInput
    _avg?: WSJobApplicationAvgOrderByAggregateInput
    _max?: WSJobApplicationMaxOrderByAggregateInput
    _min?: WSJobApplicationMinOrderByAggregateInput
    _sum?: WSJobApplicationSumOrderByAggregateInput
  }

  export type WSJobApplicationScalarWhereWithAggregatesInput = {
    AND?: WSJobApplicationScalarWhereWithAggregatesInput | WSJobApplicationScalarWhereWithAggregatesInput[]
    OR?: WSJobApplicationScalarWhereWithAggregatesInput[]
    NOT?: WSJobApplicationScalarWhereWithAggregatesInput | WSJobApplicationScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"WSJobApplication"> | number
    JobId?: IntWithAggregatesFilter<"WSJobApplication"> | number
    UserId?: IntWithAggregatesFilter<"WSJobApplication"> | number
    IsValid?: StringNullableWithAggregatesFilter<"WSJobApplication"> | string | null
    Status?: StringNullableWithAggregatesFilter<"WSJobApplication"> | string | null
    Active?: BoolWithAggregatesFilter<"WSJobApplication"> | boolean
    CreatedBy?: StringNullableWithAggregatesFilter<"WSJobApplication"> | string | null
    CreatedOn?: DateTimeNullableWithAggregatesFilter<"WSJobApplication"> | Date | string | null
    IsDenied?: BoolWithAggregatesFilter<"WSJobApplication"> | boolean
  }

  export type WSJobApplicationEducationWhereInput = {
    AND?: WSJobApplicationEducationWhereInput | WSJobApplicationEducationWhereInput[]
    OR?: WSJobApplicationEducationWhereInput[]
    NOT?: WSJobApplicationEducationWhereInput | WSJobApplicationEducationWhereInput[]
    ID?: IntFilter<"WSJobApplicationEducation"> | number
    JobApplicationId?: IntNullableFilter<"WSJobApplicationEducation"> | number | null
    EducationLevel?: StringFilter<"WSJobApplicationEducation"> | string
    Name?: StringFilter<"WSJobApplicationEducation"> | string
    Address?: StringFilter<"WSJobApplicationEducation"> | string
    FromDate?: StringFilter<"WSJobApplicationEducation"> | string
    ToDate?: StringNullableFilter<"WSJobApplicationEducation"> | string | null
    IsGraduated?: StringFilter<"WSJobApplicationEducation"> | string
    IsValid?: StringNullableFilter<"WSJobApplicationEducation"> | string | null
    WSJobApplication?: XOR<WSJobApplicationNullableRelationFilter, WSJobApplicationWhereInput> | null
  }

  export type WSJobApplicationEducationOrderByWithRelationInput = {
    ID?: SortOrder
    JobApplicationId?: SortOrderInput | SortOrder
    EducationLevel?: SortOrder
    Name?: SortOrder
    Address?: SortOrder
    FromDate?: SortOrder
    ToDate?: SortOrderInput | SortOrder
    IsGraduated?: SortOrder
    IsValid?: SortOrderInput | SortOrder
    WSJobApplication?: WSJobApplicationOrderByWithRelationInput
  }

  export type WSJobApplicationEducationWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: WSJobApplicationEducationWhereInput | WSJobApplicationEducationWhereInput[]
    OR?: WSJobApplicationEducationWhereInput[]
    NOT?: WSJobApplicationEducationWhereInput | WSJobApplicationEducationWhereInput[]
    JobApplicationId?: IntNullableFilter<"WSJobApplicationEducation"> | number | null
    EducationLevel?: StringFilter<"WSJobApplicationEducation"> | string
    Name?: StringFilter<"WSJobApplicationEducation"> | string
    Address?: StringFilter<"WSJobApplicationEducation"> | string
    FromDate?: StringFilter<"WSJobApplicationEducation"> | string
    ToDate?: StringNullableFilter<"WSJobApplicationEducation"> | string | null
    IsGraduated?: StringFilter<"WSJobApplicationEducation"> | string
    IsValid?: StringNullableFilter<"WSJobApplicationEducation"> | string | null
    WSJobApplication?: XOR<WSJobApplicationNullableRelationFilter, WSJobApplicationWhereInput> | null
  }, "ID">

  export type WSJobApplicationEducationOrderByWithAggregationInput = {
    ID?: SortOrder
    JobApplicationId?: SortOrderInput | SortOrder
    EducationLevel?: SortOrder
    Name?: SortOrder
    Address?: SortOrder
    FromDate?: SortOrder
    ToDate?: SortOrderInput | SortOrder
    IsGraduated?: SortOrder
    IsValid?: SortOrderInput | SortOrder
    _count?: WSJobApplicationEducationCountOrderByAggregateInput
    _avg?: WSJobApplicationEducationAvgOrderByAggregateInput
    _max?: WSJobApplicationEducationMaxOrderByAggregateInput
    _min?: WSJobApplicationEducationMinOrderByAggregateInput
    _sum?: WSJobApplicationEducationSumOrderByAggregateInput
  }

  export type WSJobApplicationEducationScalarWhereWithAggregatesInput = {
    AND?: WSJobApplicationEducationScalarWhereWithAggregatesInput | WSJobApplicationEducationScalarWhereWithAggregatesInput[]
    OR?: WSJobApplicationEducationScalarWhereWithAggregatesInput[]
    NOT?: WSJobApplicationEducationScalarWhereWithAggregatesInput | WSJobApplicationEducationScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"WSJobApplicationEducation"> | number
    JobApplicationId?: IntNullableWithAggregatesFilter<"WSJobApplicationEducation"> | number | null
    EducationLevel?: StringWithAggregatesFilter<"WSJobApplicationEducation"> | string
    Name?: StringWithAggregatesFilter<"WSJobApplicationEducation"> | string
    Address?: StringWithAggregatesFilter<"WSJobApplicationEducation"> | string
    FromDate?: StringWithAggregatesFilter<"WSJobApplicationEducation"> | string
    ToDate?: StringNullableWithAggregatesFilter<"WSJobApplicationEducation"> | string | null
    IsGraduated?: StringWithAggregatesFilter<"WSJobApplicationEducation"> | string
    IsValid?: StringNullableWithAggregatesFilter<"WSJobApplicationEducation"> | string | null
  }

  export type WSJobApplicationFeedbackWhereInput = {
    AND?: WSJobApplicationFeedbackWhereInput | WSJobApplicationFeedbackWhereInput[]
    OR?: WSJobApplicationFeedbackWhereInput[]
    NOT?: WSJobApplicationFeedbackWhereInput | WSJobApplicationFeedbackWhereInput[]
    ID?: IntFilter<"WSJobApplicationFeedback"> | number
    JobApplicationID?: IntFilter<"WSJobApplicationFeedback"> | number
    Feedback?: StringFilter<"WSJobApplicationFeedback"> | string
    CreatedBy?: StringFilter<"WSJobApplicationFeedback"> | string
    CreatedOn?: DateTimeFilter<"WSJobApplicationFeedback"> | Date | string
    WSJobApplication?: XOR<WSJobApplicationRelationFilter, WSJobApplicationWhereInput>
    WsJobApplicationReply?: WsJobApplicationReplyListRelationFilter
  }

  export type WSJobApplicationFeedbackOrderByWithRelationInput = {
    ID?: SortOrder
    JobApplicationID?: SortOrder
    Feedback?: SortOrder
    CreatedBy?: SortOrder
    CreatedOn?: SortOrder
    WSJobApplication?: WSJobApplicationOrderByWithRelationInput
    WsJobApplicationReply?: WsJobApplicationReplyOrderByRelationAggregateInput
  }

  export type WSJobApplicationFeedbackWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: WSJobApplicationFeedbackWhereInput | WSJobApplicationFeedbackWhereInput[]
    OR?: WSJobApplicationFeedbackWhereInput[]
    NOT?: WSJobApplicationFeedbackWhereInput | WSJobApplicationFeedbackWhereInput[]
    JobApplicationID?: IntFilter<"WSJobApplicationFeedback"> | number
    Feedback?: StringFilter<"WSJobApplicationFeedback"> | string
    CreatedBy?: StringFilter<"WSJobApplicationFeedback"> | string
    CreatedOn?: DateTimeFilter<"WSJobApplicationFeedback"> | Date | string
    WSJobApplication?: XOR<WSJobApplicationRelationFilter, WSJobApplicationWhereInput>
    WsJobApplicationReply?: WsJobApplicationReplyListRelationFilter
  }, "ID">

  export type WSJobApplicationFeedbackOrderByWithAggregationInput = {
    ID?: SortOrder
    JobApplicationID?: SortOrder
    Feedback?: SortOrder
    CreatedBy?: SortOrder
    CreatedOn?: SortOrder
    _count?: WSJobApplicationFeedbackCountOrderByAggregateInput
    _avg?: WSJobApplicationFeedbackAvgOrderByAggregateInput
    _max?: WSJobApplicationFeedbackMaxOrderByAggregateInput
    _min?: WSJobApplicationFeedbackMinOrderByAggregateInput
    _sum?: WSJobApplicationFeedbackSumOrderByAggregateInput
  }

  export type WSJobApplicationFeedbackScalarWhereWithAggregatesInput = {
    AND?: WSJobApplicationFeedbackScalarWhereWithAggregatesInput | WSJobApplicationFeedbackScalarWhereWithAggregatesInput[]
    OR?: WSJobApplicationFeedbackScalarWhereWithAggregatesInput[]
    NOT?: WSJobApplicationFeedbackScalarWhereWithAggregatesInput | WSJobApplicationFeedbackScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"WSJobApplicationFeedback"> | number
    JobApplicationID?: IntWithAggregatesFilter<"WSJobApplicationFeedback"> | number
    Feedback?: StringWithAggregatesFilter<"WSJobApplicationFeedback"> | string
    CreatedBy?: StringWithAggregatesFilter<"WSJobApplicationFeedback"> | string
    CreatedOn?: DateTimeWithAggregatesFilter<"WSJobApplicationFeedback"> | Date | string
  }

  export type WSJobApplicationPreviousEmploymentWhereInput = {
    AND?: WSJobApplicationPreviousEmploymentWhereInput | WSJobApplicationPreviousEmploymentWhereInput[]
    OR?: WSJobApplicationPreviousEmploymentWhereInput[]
    NOT?: WSJobApplicationPreviousEmploymentWhereInput | WSJobApplicationPreviousEmploymentWhereInput[]
    ID?: IntFilter<"WSJobApplicationPreviousEmployment"> | number
    JobApplicationId?: IntNullableFilter<"WSJobApplicationPreviousEmployment"> | number | null
    Company?: StringFilter<"WSJobApplicationPreviousEmployment"> | string
    Supervisor?: StringFilter<"WSJobApplicationPreviousEmployment"> | string
    Address?: StringFilter<"WSJobApplicationPreviousEmployment"> | string
    FromDate?: DateTimeFilter<"WSJobApplicationPreviousEmployment"> | Date | string
    ToDate?: DateTimeNullableFilter<"WSJobApplicationPreviousEmployment"> | Date | string | null
    JobTitle?: StringFilter<"WSJobApplicationPreviousEmployment"> | string
    EndingSalary?: FloatNullableFilter<"WSJobApplicationPreviousEmployment"> | number | null
    IsHourlyRate?: StringNullableFilter<"WSJobApplicationPreviousEmployment"> | string | null
    LeavingReason?: StringNullableFilter<"WSJobApplicationPreviousEmployment"> | string | null
    IsValid?: StringNullableFilter<"WSJobApplicationPreviousEmployment"> | string | null
    WSJobApplication?: XOR<WSJobApplicationNullableRelationFilter, WSJobApplicationWhereInput> | null
  }

  export type WSJobApplicationPreviousEmploymentOrderByWithRelationInput = {
    ID?: SortOrder
    JobApplicationId?: SortOrderInput | SortOrder
    Company?: SortOrder
    Supervisor?: SortOrder
    Address?: SortOrder
    FromDate?: SortOrder
    ToDate?: SortOrderInput | SortOrder
    JobTitle?: SortOrder
    EndingSalary?: SortOrderInput | SortOrder
    IsHourlyRate?: SortOrderInput | SortOrder
    LeavingReason?: SortOrderInput | SortOrder
    IsValid?: SortOrderInput | SortOrder
    WSJobApplication?: WSJobApplicationOrderByWithRelationInput
  }

  export type WSJobApplicationPreviousEmploymentWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: WSJobApplicationPreviousEmploymentWhereInput | WSJobApplicationPreviousEmploymentWhereInput[]
    OR?: WSJobApplicationPreviousEmploymentWhereInput[]
    NOT?: WSJobApplicationPreviousEmploymentWhereInput | WSJobApplicationPreviousEmploymentWhereInput[]
    JobApplicationId?: IntNullableFilter<"WSJobApplicationPreviousEmployment"> | number | null
    Company?: StringFilter<"WSJobApplicationPreviousEmployment"> | string
    Supervisor?: StringFilter<"WSJobApplicationPreviousEmployment"> | string
    Address?: StringFilter<"WSJobApplicationPreviousEmployment"> | string
    FromDate?: DateTimeFilter<"WSJobApplicationPreviousEmployment"> | Date | string
    ToDate?: DateTimeNullableFilter<"WSJobApplicationPreviousEmployment"> | Date | string | null
    JobTitle?: StringFilter<"WSJobApplicationPreviousEmployment"> | string
    EndingSalary?: FloatNullableFilter<"WSJobApplicationPreviousEmployment"> | number | null
    IsHourlyRate?: StringNullableFilter<"WSJobApplicationPreviousEmployment"> | string | null
    LeavingReason?: StringNullableFilter<"WSJobApplicationPreviousEmployment"> | string | null
    IsValid?: StringNullableFilter<"WSJobApplicationPreviousEmployment"> | string | null
    WSJobApplication?: XOR<WSJobApplicationNullableRelationFilter, WSJobApplicationWhereInput> | null
  }, "ID">

  export type WSJobApplicationPreviousEmploymentOrderByWithAggregationInput = {
    ID?: SortOrder
    JobApplicationId?: SortOrderInput | SortOrder
    Company?: SortOrder
    Supervisor?: SortOrder
    Address?: SortOrder
    FromDate?: SortOrder
    ToDate?: SortOrderInput | SortOrder
    JobTitle?: SortOrder
    EndingSalary?: SortOrderInput | SortOrder
    IsHourlyRate?: SortOrderInput | SortOrder
    LeavingReason?: SortOrderInput | SortOrder
    IsValid?: SortOrderInput | SortOrder
    _count?: WSJobApplicationPreviousEmploymentCountOrderByAggregateInput
    _avg?: WSJobApplicationPreviousEmploymentAvgOrderByAggregateInput
    _max?: WSJobApplicationPreviousEmploymentMaxOrderByAggregateInput
    _min?: WSJobApplicationPreviousEmploymentMinOrderByAggregateInput
    _sum?: WSJobApplicationPreviousEmploymentSumOrderByAggregateInput
  }

  export type WSJobApplicationPreviousEmploymentScalarWhereWithAggregatesInput = {
    AND?: WSJobApplicationPreviousEmploymentScalarWhereWithAggregatesInput | WSJobApplicationPreviousEmploymentScalarWhereWithAggregatesInput[]
    OR?: WSJobApplicationPreviousEmploymentScalarWhereWithAggregatesInput[]
    NOT?: WSJobApplicationPreviousEmploymentScalarWhereWithAggregatesInput | WSJobApplicationPreviousEmploymentScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"WSJobApplicationPreviousEmployment"> | number
    JobApplicationId?: IntNullableWithAggregatesFilter<"WSJobApplicationPreviousEmployment"> | number | null
    Company?: StringWithAggregatesFilter<"WSJobApplicationPreviousEmployment"> | string
    Supervisor?: StringWithAggregatesFilter<"WSJobApplicationPreviousEmployment"> | string
    Address?: StringWithAggregatesFilter<"WSJobApplicationPreviousEmployment"> | string
    FromDate?: DateTimeWithAggregatesFilter<"WSJobApplicationPreviousEmployment"> | Date | string
    ToDate?: DateTimeNullableWithAggregatesFilter<"WSJobApplicationPreviousEmployment"> | Date | string | null
    JobTitle?: StringWithAggregatesFilter<"WSJobApplicationPreviousEmployment"> | string
    EndingSalary?: FloatNullableWithAggregatesFilter<"WSJobApplicationPreviousEmployment"> | number | null
    IsHourlyRate?: StringNullableWithAggregatesFilter<"WSJobApplicationPreviousEmployment"> | string | null
    LeavingReason?: StringNullableWithAggregatesFilter<"WSJobApplicationPreviousEmployment"> | string | null
    IsValid?: StringNullableWithAggregatesFilter<"WSJobApplicationPreviousEmployment"> | string | null
  }

  export type WSJobApplicationReferenceWhereInput = {
    AND?: WSJobApplicationReferenceWhereInput | WSJobApplicationReferenceWhereInput[]
    OR?: WSJobApplicationReferenceWhereInput[]
    NOT?: WSJobApplicationReferenceWhereInput | WSJobApplicationReferenceWhereInput[]
    ID?: IntFilter<"WSJobApplicationReference"> | number
    JobApplicationId?: IntNullableFilter<"WSJobApplicationReference"> | number | null
    FullName?: StringFilter<"WSJobApplicationReference"> | string
    Relationship?: StringFilter<"WSJobApplicationReference"> | string
    Company?: StringFilter<"WSJobApplicationReference"> | string
    Phone?: StringFilter<"WSJobApplicationReference"> | string
    Email?: StringFilter<"WSJobApplicationReference"> | string
    IsValid?: StringNullableFilter<"WSJobApplicationReference"> | string | null
    WSJobApplication?: XOR<WSJobApplicationNullableRelationFilter, WSJobApplicationWhereInput> | null
  }

  export type WSJobApplicationReferenceOrderByWithRelationInput = {
    ID?: SortOrder
    JobApplicationId?: SortOrderInput | SortOrder
    FullName?: SortOrder
    Relationship?: SortOrder
    Company?: SortOrder
    Phone?: SortOrder
    Email?: SortOrder
    IsValid?: SortOrderInput | SortOrder
    WSJobApplication?: WSJobApplicationOrderByWithRelationInput
  }

  export type WSJobApplicationReferenceWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: WSJobApplicationReferenceWhereInput | WSJobApplicationReferenceWhereInput[]
    OR?: WSJobApplicationReferenceWhereInput[]
    NOT?: WSJobApplicationReferenceWhereInput | WSJobApplicationReferenceWhereInput[]
    JobApplicationId?: IntNullableFilter<"WSJobApplicationReference"> | number | null
    FullName?: StringFilter<"WSJobApplicationReference"> | string
    Relationship?: StringFilter<"WSJobApplicationReference"> | string
    Company?: StringFilter<"WSJobApplicationReference"> | string
    Phone?: StringFilter<"WSJobApplicationReference"> | string
    Email?: StringFilter<"WSJobApplicationReference"> | string
    IsValid?: StringNullableFilter<"WSJobApplicationReference"> | string | null
    WSJobApplication?: XOR<WSJobApplicationNullableRelationFilter, WSJobApplicationWhereInput> | null
  }, "ID">

  export type WSJobApplicationReferenceOrderByWithAggregationInput = {
    ID?: SortOrder
    JobApplicationId?: SortOrderInput | SortOrder
    FullName?: SortOrder
    Relationship?: SortOrder
    Company?: SortOrder
    Phone?: SortOrder
    Email?: SortOrder
    IsValid?: SortOrderInput | SortOrder
    _count?: WSJobApplicationReferenceCountOrderByAggregateInput
    _avg?: WSJobApplicationReferenceAvgOrderByAggregateInput
    _max?: WSJobApplicationReferenceMaxOrderByAggregateInput
    _min?: WSJobApplicationReferenceMinOrderByAggregateInput
    _sum?: WSJobApplicationReferenceSumOrderByAggregateInput
  }

  export type WSJobApplicationReferenceScalarWhereWithAggregatesInput = {
    AND?: WSJobApplicationReferenceScalarWhereWithAggregatesInput | WSJobApplicationReferenceScalarWhereWithAggregatesInput[]
    OR?: WSJobApplicationReferenceScalarWhereWithAggregatesInput[]
    NOT?: WSJobApplicationReferenceScalarWhereWithAggregatesInput | WSJobApplicationReferenceScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"WSJobApplicationReference"> | number
    JobApplicationId?: IntNullableWithAggregatesFilter<"WSJobApplicationReference"> | number | null
    FullName?: StringWithAggregatesFilter<"WSJobApplicationReference"> | string
    Relationship?: StringWithAggregatesFilter<"WSJobApplicationReference"> | string
    Company?: StringWithAggregatesFilter<"WSJobApplicationReference"> | string
    Phone?: StringWithAggregatesFilter<"WSJobApplicationReference"> | string
    Email?: StringWithAggregatesFilter<"WSJobApplicationReference"> | string
    IsValid?: StringNullableWithAggregatesFilter<"WSJobApplicationReference"> | string | null
  }

  export type WsJobApplicationReplyWhereInput = {
    AND?: WsJobApplicationReplyWhereInput | WsJobApplicationReplyWhereInput[]
    OR?: WsJobApplicationReplyWhereInput[]
    NOT?: WsJobApplicationReplyWhereInput | WsJobApplicationReplyWhereInput[]
    ID?: IntFilter<"WsJobApplicationReply"> | number
    FeedbackID?: IntFilter<"WsJobApplicationReply"> | number
    Message?: StringFilter<"WsJobApplicationReply"> | string
    CreatedBy?: StringFilter<"WsJobApplicationReply"> | string
    CreatedOn?: DateTimeFilter<"WsJobApplicationReply"> | Date | string
    ModifiedOn?: DateTimeNullableFilter<"WsJobApplicationReply"> | Date | string | null
    WSJobApplicationFeedback?: XOR<WSJobApplicationFeedbackRelationFilter, WSJobApplicationFeedbackWhereInput>
  }

  export type WsJobApplicationReplyOrderByWithRelationInput = {
    ID?: SortOrder
    FeedbackID?: SortOrder
    Message?: SortOrder
    CreatedBy?: SortOrder
    CreatedOn?: SortOrder
    ModifiedOn?: SortOrderInput | SortOrder
    WSJobApplicationFeedback?: WSJobApplicationFeedbackOrderByWithRelationInput
  }

  export type WsJobApplicationReplyWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: WsJobApplicationReplyWhereInput | WsJobApplicationReplyWhereInput[]
    OR?: WsJobApplicationReplyWhereInput[]
    NOT?: WsJobApplicationReplyWhereInput | WsJobApplicationReplyWhereInput[]
    FeedbackID?: IntFilter<"WsJobApplicationReply"> | number
    Message?: StringFilter<"WsJobApplicationReply"> | string
    CreatedBy?: StringFilter<"WsJobApplicationReply"> | string
    CreatedOn?: DateTimeFilter<"WsJobApplicationReply"> | Date | string
    ModifiedOn?: DateTimeNullableFilter<"WsJobApplicationReply"> | Date | string | null
    WSJobApplicationFeedback?: XOR<WSJobApplicationFeedbackRelationFilter, WSJobApplicationFeedbackWhereInput>
  }, "ID">

  export type WsJobApplicationReplyOrderByWithAggregationInput = {
    ID?: SortOrder
    FeedbackID?: SortOrder
    Message?: SortOrder
    CreatedBy?: SortOrder
    CreatedOn?: SortOrder
    ModifiedOn?: SortOrderInput | SortOrder
    _count?: WsJobApplicationReplyCountOrderByAggregateInput
    _avg?: WsJobApplicationReplyAvgOrderByAggregateInput
    _max?: WsJobApplicationReplyMaxOrderByAggregateInput
    _min?: WsJobApplicationReplyMinOrderByAggregateInput
    _sum?: WsJobApplicationReplySumOrderByAggregateInput
  }

  export type WsJobApplicationReplyScalarWhereWithAggregatesInput = {
    AND?: WsJobApplicationReplyScalarWhereWithAggregatesInput | WsJobApplicationReplyScalarWhereWithAggregatesInput[]
    OR?: WsJobApplicationReplyScalarWhereWithAggregatesInput[]
    NOT?: WsJobApplicationReplyScalarWhereWithAggregatesInput | WsJobApplicationReplyScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"WsJobApplicationReply"> | number
    FeedbackID?: IntWithAggregatesFilter<"WsJobApplicationReply"> | number
    Message?: StringWithAggregatesFilter<"WsJobApplicationReply"> | string
    CreatedBy?: StringWithAggregatesFilter<"WsJobApplicationReply"> | string
    CreatedOn?: DateTimeWithAggregatesFilter<"WsJobApplicationReply"> | Date | string
    ModifiedOn?: DateTimeNullableWithAggregatesFilter<"WsJobApplicationReply"> | Date | string | null
  }

  export type WsProductsWhereInput = {
    AND?: WsProductsWhereInput | WsProductsWhereInput[]
    OR?: WsProductsWhereInput[]
    NOT?: WsProductsWhereInput | WsProductsWhereInput[]
    vendor_id?: IntFilter<"WsProducts"> | number
    item_number?: StringFilter<"WsProducts"> | string
    description?: StringNullableFilter<"WsProducts"> | string | null
    ai_description?: StringNullableFilter<"WsProducts"> | string | null
    ai_name?: StringNullableFilter<"WsProducts"> | string | null
    dep?: StringFilter<"WsProducts"> | string
    bucket?: StringFilter<"WsProducts"> | string
    original_img_url?: StringFilter<"WsProducts"> | string
    final_img_url?: StringNullableFilter<"WsProducts"> | string | null
    top_sold?: IntNullableFilter<"WsProducts"> | number | null
    is_home?: BoolNullableFilter<"WsProducts"> | boolean | null
    is_new_arrival?: BoolNullableFilter<"WsProducts"> | boolean | null
    status?: StringNullableFilter<"WsProducts"> | string | null
    created_on?: DateTimeNullableFilter<"WsProducts"> | Date | string | null
    created_by?: StringNullableFilter<"WsProducts"> | string | null
    WsDepartments?: XOR<WsDepartmentsRelationFilter, WsDepartmentsWhereInput>
  }

  export type WsProductsOrderByWithRelationInput = {
    vendor_id?: SortOrder
    item_number?: SortOrder
    description?: SortOrderInput | SortOrder
    ai_description?: SortOrderInput | SortOrder
    ai_name?: SortOrderInput | SortOrder
    dep?: SortOrder
    bucket?: SortOrder
    original_img_url?: SortOrder
    final_img_url?: SortOrderInput | SortOrder
    top_sold?: SortOrderInput | SortOrder
    is_home?: SortOrderInput | SortOrder
    is_new_arrival?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    created_on?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    WsDepartments?: WsDepartmentsOrderByWithRelationInput
  }

  export type WsProductsWhereUniqueInput = Prisma.AtLeast<{
    item_number_vendor_id?: WsProductsItem_numberVendor_idCompoundUniqueInput
    AND?: WsProductsWhereInput | WsProductsWhereInput[]
    OR?: WsProductsWhereInput[]
    NOT?: WsProductsWhereInput | WsProductsWhereInput[]
    vendor_id?: IntFilter<"WsProducts"> | number
    item_number?: StringFilter<"WsProducts"> | string
    description?: StringNullableFilter<"WsProducts"> | string | null
    ai_description?: StringNullableFilter<"WsProducts"> | string | null
    ai_name?: StringNullableFilter<"WsProducts"> | string | null
    dep?: StringFilter<"WsProducts"> | string
    bucket?: StringFilter<"WsProducts"> | string
    original_img_url?: StringFilter<"WsProducts"> | string
    final_img_url?: StringNullableFilter<"WsProducts"> | string | null
    top_sold?: IntNullableFilter<"WsProducts"> | number | null
    is_home?: BoolNullableFilter<"WsProducts"> | boolean | null
    is_new_arrival?: BoolNullableFilter<"WsProducts"> | boolean | null
    status?: StringNullableFilter<"WsProducts"> | string | null
    created_on?: DateTimeNullableFilter<"WsProducts"> | Date | string | null
    created_by?: StringNullableFilter<"WsProducts"> | string | null
    WsDepartments?: XOR<WsDepartmentsRelationFilter, WsDepartmentsWhereInput>
  }, "item_number_vendor_id">

  export type WsProductsOrderByWithAggregationInput = {
    vendor_id?: SortOrder
    item_number?: SortOrder
    description?: SortOrderInput | SortOrder
    ai_description?: SortOrderInput | SortOrder
    ai_name?: SortOrderInput | SortOrder
    dep?: SortOrder
    bucket?: SortOrder
    original_img_url?: SortOrder
    final_img_url?: SortOrderInput | SortOrder
    top_sold?: SortOrderInput | SortOrder
    is_home?: SortOrderInput | SortOrder
    is_new_arrival?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    created_on?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    _count?: WsProductsCountOrderByAggregateInput
    _avg?: WsProductsAvgOrderByAggregateInput
    _max?: WsProductsMaxOrderByAggregateInput
    _min?: WsProductsMinOrderByAggregateInput
    _sum?: WsProductsSumOrderByAggregateInput
  }

  export type WsProductsScalarWhereWithAggregatesInput = {
    AND?: WsProductsScalarWhereWithAggregatesInput | WsProductsScalarWhereWithAggregatesInput[]
    OR?: WsProductsScalarWhereWithAggregatesInput[]
    NOT?: WsProductsScalarWhereWithAggregatesInput | WsProductsScalarWhereWithAggregatesInput[]
    vendor_id?: IntWithAggregatesFilter<"WsProducts"> | number
    item_number?: StringWithAggregatesFilter<"WsProducts"> | string
    description?: StringNullableWithAggregatesFilter<"WsProducts"> | string | null
    ai_description?: StringNullableWithAggregatesFilter<"WsProducts"> | string | null
    ai_name?: StringNullableWithAggregatesFilter<"WsProducts"> | string | null
    dep?: StringWithAggregatesFilter<"WsProducts"> | string
    bucket?: StringWithAggregatesFilter<"WsProducts"> | string
    original_img_url?: StringWithAggregatesFilter<"WsProducts"> | string
    final_img_url?: StringNullableWithAggregatesFilter<"WsProducts"> | string | null
    top_sold?: IntNullableWithAggregatesFilter<"WsProducts"> | number | null
    is_home?: BoolNullableWithAggregatesFilter<"WsProducts"> | boolean | null
    is_new_arrival?: BoolNullableWithAggregatesFilter<"WsProducts"> | boolean | null
    status?: StringNullableWithAggregatesFilter<"WsProducts"> | string | null
    created_on?: DateTimeNullableWithAggregatesFilter<"WsProducts"> | Date | string | null
    created_by?: StringNullableWithAggregatesFilter<"WsProducts"> | string | null
  }

  export type WsProfileWhereInput = {
    AND?: WsProfileWhereInput | WsProfileWhereInput[]
    OR?: WsProfileWhereInput[]
    NOT?: WsProfileWhereInput | WsProfileWhereInput[]
    ID?: IntFilter<"WsProfile"> | number
    FirstName?: StringFilter<"WsProfile"> | string
    MiddleName?: StringNullableFilter<"WsProfile"> | string | null
    LastName?: StringFilter<"WsProfile"> | string
    Gender?: StringFilter<"WsProfile"> | string
    Age?: IntFilter<"WsProfile"> | number
    Email?: StringFilter<"WsProfile"> | string
    Auth0Id?: StringFilter<"WsProfile"> | string
  }

  export type WsProfileOrderByWithRelationInput = {
    ID?: SortOrder
    FirstName?: SortOrder
    MiddleName?: SortOrderInput | SortOrder
    LastName?: SortOrder
    Gender?: SortOrder
    Age?: SortOrder
    Email?: SortOrder
    Auth0Id?: SortOrder
  }

  export type WsProfileWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    Email?: string
    AND?: WsProfileWhereInput | WsProfileWhereInput[]
    OR?: WsProfileWhereInput[]
    NOT?: WsProfileWhereInput | WsProfileWhereInput[]
    FirstName?: StringFilter<"WsProfile"> | string
    MiddleName?: StringNullableFilter<"WsProfile"> | string | null
    LastName?: StringFilter<"WsProfile"> | string
    Gender?: StringFilter<"WsProfile"> | string
    Age?: IntFilter<"WsProfile"> | number
    Auth0Id?: StringFilter<"WsProfile"> | string
  }, "ID" | "Email">

  export type WsProfileOrderByWithAggregationInput = {
    ID?: SortOrder
    FirstName?: SortOrder
    MiddleName?: SortOrderInput | SortOrder
    LastName?: SortOrder
    Gender?: SortOrder
    Age?: SortOrder
    Email?: SortOrder
    Auth0Id?: SortOrder
    _count?: WsProfileCountOrderByAggregateInput
    _avg?: WsProfileAvgOrderByAggregateInput
    _max?: WsProfileMaxOrderByAggregateInput
    _min?: WsProfileMinOrderByAggregateInput
    _sum?: WsProfileSumOrderByAggregateInput
  }

  export type WsProfileScalarWhereWithAggregatesInput = {
    AND?: WsProfileScalarWhereWithAggregatesInput | WsProfileScalarWhereWithAggregatesInput[]
    OR?: WsProfileScalarWhereWithAggregatesInput[]
    NOT?: WsProfileScalarWhereWithAggregatesInput | WsProfileScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"WsProfile"> | number
    FirstName?: StringWithAggregatesFilter<"WsProfile"> | string
    MiddleName?: StringNullableWithAggregatesFilter<"WsProfile"> | string | null
    LastName?: StringWithAggregatesFilter<"WsProfile"> | string
    Gender?: StringWithAggregatesFilter<"WsProfile"> | string
    Age?: IntWithAggregatesFilter<"WsProfile"> | number
    Email?: StringWithAggregatesFilter<"WsProfile"> | string
    Auth0Id?: StringWithAggregatesFilter<"WsProfile"> | string
  }

  export type WSStateWhereInput = {
    AND?: WSStateWhereInput | WSStateWhereInput[]
    OR?: WSStateWhereInput[]
    NOT?: WSStateWhereInput | WSStateWhereInput[]
    ID?: IntFilter<"WSState"> | number
    state?: StringNullableFilter<"WSState"> | string | null
    st_licenseNumber?: StringNullableFilter<"WSState"> | string | null
    st_expiryDate?: DateTimeNullableFilter<"WSState"> | Date | string | null
    st_fileUrl?: StringNullableFilter<"WSState"> | string | null
    ll_licenseNumber?: StringNullableFilter<"WSState"> | string | null
    ll_expiryDate?: DateTimeNullableFilter<"WSState"> | Date | string | null
    ll_fileUrl?: StringNullableFilter<"WSState"> | string | null
    taxExemptId?: IntNullableFilter<"WSState"> | number | null
    WSTaxExempt?: XOR<WSTaxExemptNullableRelationFilter, WSTaxExemptWhereInput> | null
  }

  export type WSStateOrderByWithRelationInput = {
    ID?: SortOrder
    state?: SortOrderInput | SortOrder
    st_licenseNumber?: SortOrderInput | SortOrder
    st_expiryDate?: SortOrderInput | SortOrder
    st_fileUrl?: SortOrderInput | SortOrder
    ll_licenseNumber?: SortOrderInput | SortOrder
    ll_expiryDate?: SortOrderInput | SortOrder
    ll_fileUrl?: SortOrderInput | SortOrder
    taxExemptId?: SortOrderInput | SortOrder
    WSTaxExempt?: WSTaxExemptOrderByWithRelationInput
  }

  export type WSStateWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: WSStateWhereInput | WSStateWhereInput[]
    OR?: WSStateWhereInput[]
    NOT?: WSStateWhereInput | WSStateWhereInput[]
    state?: StringNullableFilter<"WSState"> | string | null
    st_licenseNumber?: StringNullableFilter<"WSState"> | string | null
    st_expiryDate?: DateTimeNullableFilter<"WSState"> | Date | string | null
    st_fileUrl?: StringNullableFilter<"WSState"> | string | null
    ll_licenseNumber?: StringNullableFilter<"WSState"> | string | null
    ll_expiryDate?: DateTimeNullableFilter<"WSState"> | Date | string | null
    ll_fileUrl?: StringNullableFilter<"WSState"> | string | null
    taxExemptId?: IntNullableFilter<"WSState"> | number | null
    WSTaxExempt?: XOR<WSTaxExemptNullableRelationFilter, WSTaxExemptWhereInput> | null
  }, "ID">

  export type WSStateOrderByWithAggregationInput = {
    ID?: SortOrder
    state?: SortOrderInput | SortOrder
    st_licenseNumber?: SortOrderInput | SortOrder
    st_expiryDate?: SortOrderInput | SortOrder
    st_fileUrl?: SortOrderInput | SortOrder
    ll_licenseNumber?: SortOrderInput | SortOrder
    ll_expiryDate?: SortOrderInput | SortOrder
    ll_fileUrl?: SortOrderInput | SortOrder
    taxExemptId?: SortOrderInput | SortOrder
    _count?: WSStateCountOrderByAggregateInput
    _avg?: WSStateAvgOrderByAggregateInput
    _max?: WSStateMaxOrderByAggregateInput
    _min?: WSStateMinOrderByAggregateInput
    _sum?: WSStateSumOrderByAggregateInput
  }

  export type WSStateScalarWhereWithAggregatesInput = {
    AND?: WSStateScalarWhereWithAggregatesInput | WSStateScalarWhereWithAggregatesInput[]
    OR?: WSStateScalarWhereWithAggregatesInput[]
    NOT?: WSStateScalarWhereWithAggregatesInput | WSStateScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"WSState"> | number
    state?: StringNullableWithAggregatesFilter<"WSState"> | string | null
    st_licenseNumber?: StringNullableWithAggregatesFilter<"WSState"> | string | null
    st_expiryDate?: DateTimeNullableWithAggregatesFilter<"WSState"> | Date | string | null
    st_fileUrl?: StringNullableWithAggregatesFilter<"WSState"> | string | null
    ll_licenseNumber?: StringNullableWithAggregatesFilter<"WSState"> | string | null
    ll_expiryDate?: DateTimeNullableWithAggregatesFilter<"WSState"> | Date | string | null
    ll_fileUrl?: StringNullableWithAggregatesFilter<"WSState"> | string | null
    taxExemptId?: IntNullableWithAggregatesFilter<"WSState"> | number | null
  }

  export type WsStoreWhereInput = {
    AND?: WsStoreWhereInput | WsStoreWhereInput[]
    OR?: WsStoreWhereInput[]
    NOT?: WsStoreWhereInput | WsStoreWhereInput[]
    ID?: IntFilter<"WsStore"> | number
    Name?: StringFilter<"WsStore"> | string
    Address?: StringNullableFilter<"WsStore"> | string | null
    Email?: StringNullableFilter<"WsStore"> | string | null
    BookingUrl?: StringNullableFilter<"WsStore"> | string | null
    Latitude?: FloatFilter<"WsStore"> | number
    Longitude?: FloatFilter<"WsStore"> | number
    PlaceID?: StringFilter<"WsStore"> | string
    WSJob?: WSJobListRelationFilter
  }

  export type WsStoreOrderByWithRelationInput = {
    ID?: SortOrder
    Name?: SortOrder
    Address?: SortOrderInput | SortOrder
    Email?: SortOrderInput | SortOrder
    BookingUrl?: SortOrderInput | SortOrder
    Latitude?: SortOrder
    Longitude?: SortOrder
    PlaceID?: SortOrder
    WSJob?: WSJobOrderByRelationAggregateInput
  }

  export type WsStoreWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: WsStoreWhereInput | WsStoreWhereInput[]
    OR?: WsStoreWhereInput[]
    NOT?: WsStoreWhereInput | WsStoreWhereInput[]
    Name?: StringFilter<"WsStore"> | string
    Address?: StringNullableFilter<"WsStore"> | string | null
    Email?: StringNullableFilter<"WsStore"> | string | null
    BookingUrl?: StringNullableFilter<"WsStore"> | string | null
    Latitude?: FloatFilter<"WsStore"> | number
    Longitude?: FloatFilter<"WsStore"> | number
    PlaceID?: StringFilter<"WsStore"> | string
    WSJob?: WSJobListRelationFilter
  }, "ID">

  export type WsStoreOrderByWithAggregationInput = {
    ID?: SortOrder
    Name?: SortOrder
    Address?: SortOrderInput | SortOrder
    Email?: SortOrderInput | SortOrder
    BookingUrl?: SortOrderInput | SortOrder
    Latitude?: SortOrder
    Longitude?: SortOrder
    PlaceID?: SortOrder
    _count?: WsStoreCountOrderByAggregateInput
    _avg?: WsStoreAvgOrderByAggregateInput
    _max?: WsStoreMaxOrderByAggregateInput
    _min?: WsStoreMinOrderByAggregateInput
    _sum?: WsStoreSumOrderByAggregateInput
  }

  export type WsStoreScalarWhereWithAggregatesInput = {
    AND?: WsStoreScalarWhereWithAggregatesInput | WsStoreScalarWhereWithAggregatesInput[]
    OR?: WsStoreScalarWhereWithAggregatesInput[]
    NOT?: WsStoreScalarWhereWithAggregatesInput | WsStoreScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"WsStore"> | number
    Name?: StringWithAggregatesFilter<"WsStore"> | string
    Address?: StringNullableWithAggregatesFilter<"WsStore"> | string | null
    Email?: StringNullableWithAggregatesFilter<"WsStore"> | string | null
    BookingUrl?: StringNullableWithAggregatesFilter<"WsStore"> | string | null
    Latitude?: FloatWithAggregatesFilter<"WsStore"> | number
    Longitude?: FloatWithAggregatesFilter<"WsStore"> | number
    PlaceID?: StringWithAggregatesFilter<"WsStore"> | string
  }

  export type WSTaxExemptWhereInput = {
    AND?: WSTaxExemptWhereInput | WSTaxExemptWhereInput[]
    OR?: WSTaxExemptWhereInput[]
    NOT?: WSTaxExemptWhereInput | WSTaxExemptWhereInput[]
    ID?: IntFilter<"WSTaxExempt"> | number
    organization?: StringNullableFilter<"WSTaxExempt"> | string | null
    organizationDescription?: StringNullableFilter<"WSTaxExempt"> | string | null
    number?: StringNullableFilter<"WSTaxExempt"> | string | null
    country?: StringNullableFilter<"WSTaxExempt"> | string | null
    streetAddress?: StringNullableFilter<"WSTaxExempt"> | string | null
    city?: StringNullableFilter<"WSTaxExempt"> | string | null
    state?: StringNullableFilter<"WSTaxExempt"> | string | null
    zip?: StringNullableFilter<"WSTaxExempt"> | string | null
    mobileNumber?: StringNullableFilter<"WSTaxExempt"> | string | null
    apartment?: StringNullableFilter<"WSTaxExempt"> | string | null
    purpose?: StringNullableFilter<"WSTaxExempt"> | string | null
    organizationType?: StringNullableFilter<"WSTaxExempt"> | string | null
    name?: StringNullableFilter<"WSTaxExempt"> | string | null
    email?: StringNullableFilter<"WSTaxExempt"> | string | null
    status?: StringNullableFilter<"WSTaxExempt"> | string | null
    states?: StringNullableFilter<"WSTaxExempt"> | string | null
    signerName?: StringNullableFilter<"WSTaxExempt"> | string | null
    signerTitle?: StringNullableFilter<"WSTaxExempt"> | string | null
    signature?: StringNullableFilter<"WSTaxExempt"> | string | null
    certificateType?: StringNullableFilter<"WSTaxExempt"> | string | null
    WSState?: WSStateListRelationFilter
  }

  export type WSTaxExemptOrderByWithRelationInput = {
    ID?: SortOrder
    organization?: SortOrderInput | SortOrder
    organizationDescription?: SortOrderInput | SortOrder
    number?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    streetAddress?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    zip?: SortOrderInput | SortOrder
    mobileNumber?: SortOrderInput | SortOrder
    apartment?: SortOrderInput | SortOrder
    purpose?: SortOrderInput | SortOrder
    organizationType?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    states?: SortOrderInput | SortOrder
    signerName?: SortOrderInput | SortOrder
    signerTitle?: SortOrderInput | SortOrder
    signature?: SortOrderInput | SortOrder
    certificateType?: SortOrderInput | SortOrder
    WSState?: WSStateOrderByRelationAggregateInput
  }

  export type WSTaxExemptWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: WSTaxExemptWhereInput | WSTaxExemptWhereInput[]
    OR?: WSTaxExemptWhereInput[]
    NOT?: WSTaxExemptWhereInput | WSTaxExemptWhereInput[]
    organization?: StringNullableFilter<"WSTaxExempt"> | string | null
    organizationDescription?: StringNullableFilter<"WSTaxExempt"> | string | null
    number?: StringNullableFilter<"WSTaxExempt"> | string | null
    country?: StringNullableFilter<"WSTaxExempt"> | string | null
    streetAddress?: StringNullableFilter<"WSTaxExempt"> | string | null
    city?: StringNullableFilter<"WSTaxExempt"> | string | null
    state?: StringNullableFilter<"WSTaxExempt"> | string | null
    zip?: StringNullableFilter<"WSTaxExempt"> | string | null
    mobileNumber?: StringNullableFilter<"WSTaxExempt"> | string | null
    apartment?: StringNullableFilter<"WSTaxExempt"> | string | null
    purpose?: StringNullableFilter<"WSTaxExempt"> | string | null
    organizationType?: StringNullableFilter<"WSTaxExempt"> | string | null
    name?: StringNullableFilter<"WSTaxExempt"> | string | null
    email?: StringNullableFilter<"WSTaxExempt"> | string | null
    status?: StringNullableFilter<"WSTaxExempt"> | string | null
    states?: StringNullableFilter<"WSTaxExempt"> | string | null
    signerName?: StringNullableFilter<"WSTaxExempt"> | string | null
    signerTitle?: StringNullableFilter<"WSTaxExempt"> | string | null
    signature?: StringNullableFilter<"WSTaxExempt"> | string | null
    certificateType?: StringNullableFilter<"WSTaxExempt"> | string | null
    WSState?: WSStateListRelationFilter
  }, "ID">

  export type WSTaxExemptOrderByWithAggregationInput = {
    ID?: SortOrder
    organization?: SortOrderInput | SortOrder
    organizationDescription?: SortOrderInput | SortOrder
    number?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    streetAddress?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    zip?: SortOrderInput | SortOrder
    mobileNumber?: SortOrderInput | SortOrder
    apartment?: SortOrderInput | SortOrder
    purpose?: SortOrderInput | SortOrder
    organizationType?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    states?: SortOrderInput | SortOrder
    signerName?: SortOrderInput | SortOrder
    signerTitle?: SortOrderInput | SortOrder
    signature?: SortOrderInput | SortOrder
    certificateType?: SortOrderInput | SortOrder
    _count?: WSTaxExemptCountOrderByAggregateInput
    _avg?: WSTaxExemptAvgOrderByAggregateInput
    _max?: WSTaxExemptMaxOrderByAggregateInput
    _min?: WSTaxExemptMinOrderByAggregateInput
    _sum?: WSTaxExemptSumOrderByAggregateInput
  }

  export type WSTaxExemptScalarWhereWithAggregatesInput = {
    AND?: WSTaxExemptScalarWhereWithAggregatesInput | WSTaxExemptScalarWhereWithAggregatesInput[]
    OR?: WSTaxExemptScalarWhereWithAggregatesInput[]
    NOT?: WSTaxExemptScalarWhereWithAggregatesInput | WSTaxExemptScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"WSTaxExempt"> | number
    organization?: StringNullableWithAggregatesFilter<"WSTaxExempt"> | string | null
    organizationDescription?: StringNullableWithAggregatesFilter<"WSTaxExempt"> | string | null
    number?: StringNullableWithAggregatesFilter<"WSTaxExempt"> | string | null
    country?: StringNullableWithAggregatesFilter<"WSTaxExempt"> | string | null
    streetAddress?: StringNullableWithAggregatesFilter<"WSTaxExempt"> | string | null
    city?: StringNullableWithAggregatesFilter<"WSTaxExempt"> | string | null
    state?: StringNullableWithAggregatesFilter<"WSTaxExempt"> | string | null
    zip?: StringNullableWithAggregatesFilter<"WSTaxExempt"> | string | null
    mobileNumber?: StringNullableWithAggregatesFilter<"WSTaxExempt"> | string | null
    apartment?: StringNullableWithAggregatesFilter<"WSTaxExempt"> | string | null
    purpose?: StringNullableWithAggregatesFilter<"WSTaxExempt"> | string | null
    organizationType?: StringNullableWithAggregatesFilter<"WSTaxExempt"> | string | null
    name?: StringNullableWithAggregatesFilter<"WSTaxExempt"> | string | null
    email?: StringNullableWithAggregatesFilter<"WSTaxExempt"> | string | null
    status?: StringNullableWithAggregatesFilter<"WSTaxExempt"> | string | null
    states?: StringNullableWithAggregatesFilter<"WSTaxExempt"> | string | null
    signerName?: StringNullableWithAggregatesFilter<"WSTaxExempt"> | string | null
    signerTitle?: StringNullableWithAggregatesFilter<"WSTaxExempt"> | string | null
    signature?: StringNullableWithAggregatesFilter<"WSTaxExempt"> | string | null
    certificateType?: StringNullableWithAggregatesFilter<"WSTaxExempt"> | string | null
  }

  export type WsUserWhereInput = {
    AND?: WsUserWhereInput | WsUserWhereInput[]
    OR?: WsUserWhereInput[]
    NOT?: WsUserWhereInput | WsUserWhereInput[]
    ID?: IntFilter<"WsUser"> | number
    Name?: StringFilter<"WsUser"> | string
    MiddleName?: StringNullableFilter<"WsUser"> | string | null
    LastName?: StringFilter<"WsUser"> | string
    Street?: StringFilter<"WsUser"> | string
    Apartment?: StringNullableFilter<"WsUser"> | string | null
    City?: StringFilter<"WsUser"> | string
    State?: StringFilter<"WsUser"> | string
    Zip?: StringFilter<"WsUser"> | string
    Phone?: StringFilter<"WsUser"> | string
    SocialSecurity?: StringFilter<"WsUser"> | string
    CanWorkInUs?: StringFilter<"WsUser"> | string
    IsLegalAge?: StringFilter<"WsUser"> | string
    ServedInMilitary?: StringNullableFilter<"WsUser"> | string | null
    MilitaryBranch?: StringNullableFilter<"WsUser"> | string | null
    MilitaryRank?: StringNullableFilter<"WsUser"> | string | null
    MilitaryTypeOfDischarge?: StringNullableFilter<"WsUser"> | string | null
    ResumeUrl?: StringNullableFilter<"WsUser"> | string | null
    Email?: StringFilter<"WsUser"> | string
    Auth0Id?: StringFilter<"WsUser"> | string
    WSJobApplication?: WSJobApplicationListRelationFilter
  }

  export type WsUserOrderByWithRelationInput = {
    ID?: SortOrder
    Name?: SortOrder
    MiddleName?: SortOrderInput | SortOrder
    LastName?: SortOrder
    Street?: SortOrder
    Apartment?: SortOrderInput | SortOrder
    City?: SortOrder
    State?: SortOrder
    Zip?: SortOrder
    Phone?: SortOrder
    SocialSecurity?: SortOrder
    CanWorkInUs?: SortOrder
    IsLegalAge?: SortOrder
    ServedInMilitary?: SortOrderInput | SortOrder
    MilitaryBranch?: SortOrderInput | SortOrder
    MilitaryRank?: SortOrderInput | SortOrder
    MilitaryTypeOfDischarge?: SortOrderInput | SortOrder
    ResumeUrl?: SortOrderInput | SortOrder
    Email?: SortOrder
    Auth0Id?: SortOrder
    WSJobApplication?: WSJobApplicationOrderByRelationAggregateInput
  }

  export type WsUserWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: WsUserWhereInput | WsUserWhereInput[]
    OR?: WsUserWhereInput[]
    NOT?: WsUserWhereInput | WsUserWhereInput[]
    Name?: StringFilter<"WsUser"> | string
    MiddleName?: StringNullableFilter<"WsUser"> | string | null
    LastName?: StringFilter<"WsUser"> | string
    Street?: StringFilter<"WsUser"> | string
    Apartment?: StringNullableFilter<"WsUser"> | string | null
    City?: StringFilter<"WsUser"> | string
    State?: StringFilter<"WsUser"> | string
    Zip?: StringFilter<"WsUser"> | string
    Phone?: StringFilter<"WsUser"> | string
    SocialSecurity?: StringFilter<"WsUser"> | string
    CanWorkInUs?: StringFilter<"WsUser"> | string
    IsLegalAge?: StringFilter<"WsUser"> | string
    ServedInMilitary?: StringNullableFilter<"WsUser"> | string | null
    MilitaryBranch?: StringNullableFilter<"WsUser"> | string | null
    MilitaryRank?: StringNullableFilter<"WsUser"> | string | null
    MilitaryTypeOfDischarge?: StringNullableFilter<"WsUser"> | string | null
    ResumeUrl?: StringNullableFilter<"WsUser"> | string | null
    Email?: StringFilter<"WsUser"> | string
    Auth0Id?: StringFilter<"WsUser"> | string
    WSJobApplication?: WSJobApplicationListRelationFilter
  }, "ID">

  export type WsUserOrderByWithAggregationInput = {
    ID?: SortOrder
    Name?: SortOrder
    MiddleName?: SortOrderInput | SortOrder
    LastName?: SortOrder
    Street?: SortOrder
    Apartment?: SortOrderInput | SortOrder
    City?: SortOrder
    State?: SortOrder
    Zip?: SortOrder
    Phone?: SortOrder
    SocialSecurity?: SortOrder
    CanWorkInUs?: SortOrder
    IsLegalAge?: SortOrder
    ServedInMilitary?: SortOrderInput | SortOrder
    MilitaryBranch?: SortOrderInput | SortOrder
    MilitaryRank?: SortOrderInput | SortOrder
    MilitaryTypeOfDischarge?: SortOrderInput | SortOrder
    ResumeUrl?: SortOrderInput | SortOrder
    Email?: SortOrder
    Auth0Id?: SortOrder
    _count?: WsUserCountOrderByAggregateInput
    _avg?: WsUserAvgOrderByAggregateInput
    _max?: WsUserMaxOrderByAggregateInput
    _min?: WsUserMinOrderByAggregateInput
    _sum?: WsUserSumOrderByAggregateInput
  }

  export type WsUserScalarWhereWithAggregatesInput = {
    AND?: WsUserScalarWhereWithAggregatesInput | WsUserScalarWhereWithAggregatesInput[]
    OR?: WsUserScalarWhereWithAggregatesInput[]
    NOT?: WsUserScalarWhereWithAggregatesInput | WsUserScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"WsUser"> | number
    Name?: StringWithAggregatesFilter<"WsUser"> | string
    MiddleName?: StringNullableWithAggregatesFilter<"WsUser"> | string | null
    LastName?: StringWithAggregatesFilter<"WsUser"> | string
    Street?: StringWithAggregatesFilter<"WsUser"> | string
    Apartment?: StringNullableWithAggregatesFilter<"WsUser"> | string | null
    City?: StringWithAggregatesFilter<"WsUser"> | string
    State?: StringWithAggregatesFilter<"WsUser"> | string
    Zip?: StringWithAggregatesFilter<"WsUser"> | string
    Phone?: StringWithAggregatesFilter<"WsUser"> | string
    SocialSecurity?: StringWithAggregatesFilter<"WsUser"> | string
    CanWorkInUs?: StringWithAggregatesFilter<"WsUser"> | string
    IsLegalAge?: StringWithAggregatesFilter<"WsUser"> | string
    ServedInMilitary?: StringNullableWithAggregatesFilter<"WsUser"> | string | null
    MilitaryBranch?: StringNullableWithAggregatesFilter<"WsUser"> | string | null
    MilitaryRank?: StringNullableWithAggregatesFilter<"WsUser"> | string | null
    MilitaryTypeOfDischarge?: StringNullableWithAggregatesFilter<"WsUser"> | string | null
    ResumeUrl?: StringNullableWithAggregatesFilter<"WsUser"> | string | null
    Email?: StringWithAggregatesFilter<"WsUser"> | string
    Auth0Id?: StringWithAggregatesFilter<"WsUser"> | string
  }

  export type WsBillboardsCreateInput = {
    alias?: string | null
    description?: string | null
    order?: number | null
    is_enabled?: boolean | null
    banner_url?: string | null
    created_on?: Date | string | null
    created_by?: string | null
  }

  export type WsBillboardsUncheckedCreateInput = {
    ID?: number
    alias?: string | null
    description?: string | null
    order?: number | null
    is_enabled?: boolean | null
    banner_url?: string | null
    created_on?: Date | string | null
    created_by?: string | null
  }

  export type WsBillboardsUpdateInput = {
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    is_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banner_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WsBillboardsUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    is_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banner_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WsBillboardsCreateManyInput = {
    alias?: string | null
    description?: string | null
    order?: number | null
    is_enabled?: boolean | null
    banner_url?: string | null
    created_on?: Date | string | null
    created_by?: string | null
  }

  export type WsBillboardsUpdateManyMutationInput = {
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    is_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banner_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WsBillboardsUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    is_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banner_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WsCategoriesCreateInput = {
    Category: string
    Type: string
  }

  export type WsCategoriesUncheckedCreateInput = {
    ID?: number
    Category: string
    Type: string
  }

  export type WsCategoriesUpdateInput = {
    Category?: StringFieldUpdateOperationsInput | string
    Type?: StringFieldUpdateOperationsInput | string
  }

  export type WsCategoriesUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Category?: StringFieldUpdateOperationsInput | string
    Type?: StringFieldUpdateOperationsInput | string
  }

  export type WsCategoriesCreateManyInput = {
    Category: string
    Type: string
  }

  export type WsCategoriesUpdateManyMutationInput = {
    Category?: StringFieldUpdateOperationsInput | string
    Type?: StringFieldUpdateOperationsInput | string
  }

  export type WsCategoriesUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Category?: StringFieldUpdateOperationsInput | string
    Type?: StringFieldUpdateOperationsInput | string
  }

  export type WsDepartmentsCreateInput = {
    dep: string
    alias?: string | null
    order?: number | null
    app_bar?: boolean | null
    banner_url?: string | null
    created_on?: Date | string | null
    created_by?: string | null
    WsProducts?: WsProductsCreateNestedManyWithoutWsDepartmentsInput
  }

  export type WsDepartmentsUncheckedCreateInput = {
    dep: string
    alias?: string | null
    order?: number | null
    app_bar?: boolean | null
    banner_url?: string | null
    created_on?: Date | string | null
    created_by?: string | null
    WsProducts?: WsProductsUncheckedCreateNestedManyWithoutWsDepartmentsInput
  }

  export type WsDepartmentsUpdateInput = {
    dep?: StringFieldUpdateOperationsInput | string
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    app_bar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banner_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    WsProducts?: WsProductsUpdateManyWithoutWsDepartmentsNestedInput
  }

  export type WsDepartmentsUncheckedUpdateInput = {
    dep?: StringFieldUpdateOperationsInput | string
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    app_bar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banner_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    WsProducts?: WsProductsUncheckedUpdateManyWithoutWsDepartmentsNestedInput
  }

  export type WsDepartmentsCreateManyInput = {
    dep: string
    alias?: string | null
    order?: number | null
    app_bar?: boolean | null
    banner_url?: string | null
    created_on?: Date | string | null
    created_by?: string | null
  }

  export type WsDepartmentsUpdateManyMutationInput = {
    dep?: StringFieldUpdateOperationsInput | string
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    app_bar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banner_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WsDepartmentsUncheckedUpdateManyInput = {
    dep?: StringFieldUpdateOperationsInput | string
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    app_bar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banner_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WsHomeBannersCreateInput = {
    dep: string
    image_url: string
  }

  export type WsHomeBannersUncheckedCreateInput = {
    ID?: number
    dep: string
    image_url: string
  }

  export type WsHomeBannersUpdateInput = {
    dep?: StringFieldUpdateOperationsInput | string
    image_url?: StringFieldUpdateOperationsInput | string
  }

  export type WsHomeBannersUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    dep?: StringFieldUpdateOperationsInput | string
    image_url?: StringFieldUpdateOperationsInput | string
  }

  export type WsHomeBannersCreateManyInput = {
    dep: string
    image_url: string
  }

  export type WsHomeBannersUpdateManyMutationInput = {
    dep?: StringFieldUpdateOperationsInput | string
    image_url?: StringFieldUpdateOperationsInput | string
  }

  export type WsHomeBannersUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    dep?: StringFieldUpdateOperationsInput | string
    image_url?: StringFieldUpdateOperationsInput | string
  }

  export type WsImagesCreateInput = {
    vendor_id: number
    item_number: string
    image_url?: string | null
    created_on?: Date | string | null
    created_by?: string | null
  }

  export type WsImagesUncheckedCreateInput = {
    vendor_id: number
    item_number: string
    image_url?: string | null
    created_on?: Date | string | null
    created_by?: string | null
  }

  export type WsImagesUpdateInput = {
    vendor_id?: IntFieldUpdateOperationsInput | number
    item_number?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WsImagesUncheckedUpdateInput = {
    vendor_id?: IntFieldUpdateOperationsInput | number
    item_number?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WsImagesCreateManyInput = {
    vendor_id: number
    item_number: string
    image_url?: string | null
    created_on?: Date | string | null
    created_by?: string | null
  }

  export type WsImagesUpdateManyMutationInput = {
    vendor_id?: IntFieldUpdateOperationsInput | number
    item_number?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WsImagesUncheckedUpdateManyInput = {
    vendor_id?: IntFieldUpdateOperationsInput | number
    item_number?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WSJobCreateInput = {
    Name: string
    Description?: string | null
    Type?: string | null
    Category?: string | null
    CreatedOn?: Date | string | null
    Active?: boolean
    Status?: string | null
    CreatedBy: string
    MaxSalary?: number
    MinSalary?: number
    SalaryType?: string
    WsStore: WsStoreCreateNestedOneWithoutWSJobInput
    WSJobApplication?: WSJobApplicationCreateNestedManyWithoutWSJobInput
  }

  export type WSJobUncheckedCreateInput = {
    ID?: number
    Name: string
    Description?: string | null
    Type?: string | null
    Category?: string | null
    CreatedOn?: Date | string | null
    Active?: boolean
    StoreId: number
    Status?: string | null
    CreatedBy: string
    MaxSalary?: number
    MinSalary?: number
    SalaryType?: string
    WSJobApplication?: WSJobApplicationUncheckedCreateNestedManyWithoutWSJobInput
  }

  export type WSJobUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Active?: BoolFieldUpdateOperationsInput | boolean
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedBy?: StringFieldUpdateOperationsInput | string
    MaxSalary?: FloatFieldUpdateOperationsInput | number
    MinSalary?: FloatFieldUpdateOperationsInput | number
    SalaryType?: StringFieldUpdateOperationsInput | string
    WsStore?: WsStoreUpdateOneRequiredWithoutWSJobNestedInput
    WSJobApplication?: WSJobApplicationUpdateManyWithoutWSJobNestedInput
  }

  export type WSJobUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Active?: BoolFieldUpdateOperationsInput | boolean
    StoreId?: IntFieldUpdateOperationsInput | number
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedBy?: StringFieldUpdateOperationsInput | string
    MaxSalary?: FloatFieldUpdateOperationsInput | number
    MinSalary?: FloatFieldUpdateOperationsInput | number
    SalaryType?: StringFieldUpdateOperationsInput | string
    WSJobApplication?: WSJobApplicationUncheckedUpdateManyWithoutWSJobNestedInput
  }

  export type WSJobCreateManyInput = {
    Name: string
    Description?: string | null
    Type?: string | null
    Category?: string | null
    CreatedOn?: Date | string | null
    Active?: boolean
    StoreId: number
    Status?: string | null
    CreatedBy: string
    MaxSalary?: number
    MinSalary?: number
    SalaryType?: string
  }

  export type WSJobUpdateManyMutationInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Active?: BoolFieldUpdateOperationsInput | boolean
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedBy?: StringFieldUpdateOperationsInput | string
    MaxSalary?: FloatFieldUpdateOperationsInput | number
    MinSalary?: FloatFieldUpdateOperationsInput | number
    SalaryType?: StringFieldUpdateOperationsInput | string
  }

  export type WSJobUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Active?: BoolFieldUpdateOperationsInput | boolean
    StoreId?: IntFieldUpdateOperationsInput | number
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedBy?: StringFieldUpdateOperationsInput | string
    MaxSalary?: FloatFieldUpdateOperationsInput | number
    MinSalary?: FloatFieldUpdateOperationsInput | number
    SalaryType?: StringFieldUpdateOperationsInput | string
  }

  export type WSJobApplicationCreateInput = {
    IsValid?: string | null
    Status?: string | null
    Active: boolean
    CreatedBy?: string | null
    CreatedOn?: Date | string | null
    IsDenied?: boolean
    WSJob: WSJobCreateNestedOneWithoutWSJobApplicationInput
    WsUser: WsUserCreateNestedOneWithoutWSJobApplicationInput
    WSJobApplicationEducation?: WSJobApplicationEducationCreateNestedManyWithoutWSJobApplicationInput
    WSJobApplicationFeedback?: WSJobApplicationFeedbackCreateNestedManyWithoutWSJobApplicationInput
    WSJobApplicationPreviousEmployment?: WSJobApplicationPreviousEmploymentCreateNestedManyWithoutWSJobApplicationInput
    WSJobApplicationReference?: WSJobApplicationReferenceCreateNestedManyWithoutWSJobApplicationInput
  }

  export type WSJobApplicationUncheckedCreateInput = {
    ID?: number
    JobId: number
    UserId: number
    IsValid?: string | null
    Status?: string | null
    Active: boolean
    CreatedBy?: string | null
    CreatedOn?: Date | string | null
    IsDenied?: boolean
    WSJobApplicationEducation?: WSJobApplicationEducationUncheckedCreateNestedManyWithoutWSJobApplicationInput
    WSJobApplicationFeedback?: WSJobApplicationFeedbackUncheckedCreateNestedManyWithoutWSJobApplicationInput
    WSJobApplicationPreviousEmployment?: WSJobApplicationPreviousEmploymentUncheckedCreateNestedManyWithoutWSJobApplicationInput
    WSJobApplicationReference?: WSJobApplicationReferenceUncheckedCreateNestedManyWithoutWSJobApplicationInput
  }

  export type WSJobApplicationUpdateInput = {
    IsValid?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Active?: BoolFieldUpdateOperationsInput | boolean
    CreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsDenied?: BoolFieldUpdateOperationsInput | boolean
    WSJob?: WSJobUpdateOneRequiredWithoutWSJobApplicationNestedInput
    WsUser?: WsUserUpdateOneRequiredWithoutWSJobApplicationNestedInput
    WSJobApplicationEducation?: WSJobApplicationEducationUpdateManyWithoutWSJobApplicationNestedInput
    WSJobApplicationFeedback?: WSJobApplicationFeedbackUpdateManyWithoutWSJobApplicationNestedInput
    WSJobApplicationPreviousEmployment?: WSJobApplicationPreviousEmploymentUpdateManyWithoutWSJobApplicationNestedInput
    WSJobApplicationReference?: WSJobApplicationReferenceUpdateManyWithoutWSJobApplicationNestedInput
  }

  export type WSJobApplicationUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    JobId?: IntFieldUpdateOperationsInput | number
    UserId?: IntFieldUpdateOperationsInput | number
    IsValid?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Active?: BoolFieldUpdateOperationsInput | boolean
    CreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsDenied?: BoolFieldUpdateOperationsInput | boolean
    WSJobApplicationEducation?: WSJobApplicationEducationUncheckedUpdateManyWithoutWSJobApplicationNestedInput
    WSJobApplicationFeedback?: WSJobApplicationFeedbackUncheckedUpdateManyWithoutWSJobApplicationNestedInput
    WSJobApplicationPreviousEmployment?: WSJobApplicationPreviousEmploymentUncheckedUpdateManyWithoutWSJobApplicationNestedInput
    WSJobApplicationReference?: WSJobApplicationReferenceUncheckedUpdateManyWithoutWSJobApplicationNestedInput
  }

  export type WSJobApplicationCreateManyInput = {
    JobId: number
    UserId: number
    IsValid?: string | null
    Status?: string | null
    Active: boolean
    CreatedBy?: string | null
    CreatedOn?: Date | string | null
    IsDenied?: boolean
  }

  export type WSJobApplicationUpdateManyMutationInput = {
    IsValid?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Active?: BoolFieldUpdateOperationsInput | boolean
    CreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsDenied?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WSJobApplicationUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    JobId?: IntFieldUpdateOperationsInput | number
    UserId?: IntFieldUpdateOperationsInput | number
    IsValid?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Active?: BoolFieldUpdateOperationsInput | boolean
    CreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsDenied?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WSJobApplicationEducationCreateInput = {
    EducationLevel: string
    Name: string
    Address: string
    FromDate: string
    ToDate?: string | null
    IsGraduated: string
    IsValid?: string | null
    WSJobApplication?: WSJobApplicationCreateNestedOneWithoutWSJobApplicationEducationInput
  }

  export type WSJobApplicationEducationUncheckedCreateInput = {
    ID?: number
    JobApplicationId?: number | null
    EducationLevel: string
    Name: string
    Address: string
    FromDate: string
    ToDate?: string | null
    IsGraduated: string
    IsValid?: string | null
  }

  export type WSJobApplicationEducationUpdateInput = {
    EducationLevel?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    FromDate?: StringFieldUpdateOperationsInput | string
    ToDate?: NullableStringFieldUpdateOperationsInput | string | null
    IsGraduated?: StringFieldUpdateOperationsInput | string
    IsValid?: NullableStringFieldUpdateOperationsInput | string | null
    WSJobApplication?: WSJobApplicationUpdateOneWithoutWSJobApplicationEducationNestedInput
  }

  export type WSJobApplicationEducationUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    JobApplicationId?: NullableIntFieldUpdateOperationsInput | number | null
    EducationLevel?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    FromDate?: StringFieldUpdateOperationsInput | string
    ToDate?: NullableStringFieldUpdateOperationsInput | string | null
    IsGraduated?: StringFieldUpdateOperationsInput | string
    IsValid?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WSJobApplicationEducationCreateManyInput = {
    JobApplicationId?: number | null
    EducationLevel: string
    Name: string
    Address: string
    FromDate: string
    ToDate?: string | null
    IsGraduated: string
    IsValid?: string | null
  }

  export type WSJobApplicationEducationUpdateManyMutationInput = {
    EducationLevel?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    FromDate?: StringFieldUpdateOperationsInput | string
    ToDate?: NullableStringFieldUpdateOperationsInput | string | null
    IsGraduated?: StringFieldUpdateOperationsInput | string
    IsValid?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WSJobApplicationEducationUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    JobApplicationId?: NullableIntFieldUpdateOperationsInput | number | null
    EducationLevel?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    FromDate?: StringFieldUpdateOperationsInput | string
    ToDate?: NullableStringFieldUpdateOperationsInput | string | null
    IsGraduated?: StringFieldUpdateOperationsInput | string
    IsValid?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WSJobApplicationFeedbackCreateInput = {
    Feedback: string
    CreatedBy: string
    CreatedOn: Date | string
    WSJobApplication: WSJobApplicationCreateNestedOneWithoutWSJobApplicationFeedbackInput
    WsJobApplicationReply?: WsJobApplicationReplyCreateNestedManyWithoutWSJobApplicationFeedbackInput
  }

  export type WSJobApplicationFeedbackUncheckedCreateInput = {
    ID?: number
    JobApplicationID: number
    Feedback: string
    CreatedBy: string
    CreatedOn: Date | string
    WsJobApplicationReply?: WsJobApplicationReplyUncheckedCreateNestedManyWithoutWSJobApplicationFeedbackInput
  }

  export type WSJobApplicationFeedbackUpdateInput = {
    Feedback?: StringFieldUpdateOperationsInput | string
    CreatedBy?: StringFieldUpdateOperationsInput | string
    CreatedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    WSJobApplication?: WSJobApplicationUpdateOneRequiredWithoutWSJobApplicationFeedbackNestedInput
    WsJobApplicationReply?: WsJobApplicationReplyUpdateManyWithoutWSJobApplicationFeedbackNestedInput
  }

  export type WSJobApplicationFeedbackUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    JobApplicationID?: IntFieldUpdateOperationsInput | number
    Feedback?: StringFieldUpdateOperationsInput | string
    CreatedBy?: StringFieldUpdateOperationsInput | string
    CreatedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    WsJobApplicationReply?: WsJobApplicationReplyUncheckedUpdateManyWithoutWSJobApplicationFeedbackNestedInput
  }

  export type WSJobApplicationFeedbackCreateManyInput = {
    JobApplicationID: number
    Feedback: string
    CreatedBy: string
    CreatedOn: Date | string
  }

  export type WSJobApplicationFeedbackUpdateManyMutationInput = {
    Feedback?: StringFieldUpdateOperationsInput | string
    CreatedBy?: StringFieldUpdateOperationsInput | string
    CreatedOn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WSJobApplicationFeedbackUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    JobApplicationID?: IntFieldUpdateOperationsInput | number
    Feedback?: StringFieldUpdateOperationsInput | string
    CreatedBy?: StringFieldUpdateOperationsInput | string
    CreatedOn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WSJobApplicationPreviousEmploymentCreateInput = {
    Company: string
    Supervisor: string
    Address: string
    FromDate: Date | string
    ToDate?: Date | string | null
    JobTitle: string
    EndingSalary?: number | null
    IsHourlyRate?: string | null
    LeavingReason?: string | null
    IsValid?: string | null
    WSJobApplication?: WSJobApplicationCreateNestedOneWithoutWSJobApplicationPreviousEmploymentInput
  }

  export type WSJobApplicationPreviousEmploymentUncheckedCreateInput = {
    ID?: number
    JobApplicationId?: number | null
    Company: string
    Supervisor: string
    Address: string
    FromDate: Date | string
    ToDate?: Date | string | null
    JobTitle: string
    EndingSalary?: number | null
    IsHourlyRate?: string | null
    LeavingReason?: string | null
    IsValid?: string | null
  }

  export type WSJobApplicationPreviousEmploymentUpdateInput = {
    Company?: StringFieldUpdateOperationsInput | string
    Supervisor?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    FromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ToDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    JobTitle?: StringFieldUpdateOperationsInput | string
    EndingSalary?: NullableFloatFieldUpdateOperationsInput | number | null
    IsHourlyRate?: NullableStringFieldUpdateOperationsInput | string | null
    LeavingReason?: NullableStringFieldUpdateOperationsInput | string | null
    IsValid?: NullableStringFieldUpdateOperationsInput | string | null
    WSJobApplication?: WSJobApplicationUpdateOneWithoutWSJobApplicationPreviousEmploymentNestedInput
  }

  export type WSJobApplicationPreviousEmploymentUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    JobApplicationId?: NullableIntFieldUpdateOperationsInput | number | null
    Company?: StringFieldUpdateOperationsInput | string
    Supervisor?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    FromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ToDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    JobTitle?: StringFieldUpdateOperationsInput | string
    EndingSalary?: NullableFloatFieldUpdateOperationsInput | number | null
    IsHourlyRate?: NullableStringFieldUpdateOperationsInput | string | null
    LeavingReason?: NullableStringFieldUpdateOperationsInput | string | null
    IsValid?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WSJobApplicationPreviousEmploymentCreateManyInput = {
    JobApplicationId?: number | null
    Company: string
    Supervisor: string
    Address: string
    FromDate: Date | string
    ToDate?: Date | string | null
    JobTitle: string
    EndingSalary?: number | null
    IsHourlyRate?: string | null
    LeavingReason?: string | null
    IsValid?: string | null
  }

  export type WSJobApplicationPreviousEmploymentUpdateManyMutationInput = {
    Company?: StringFieldUpdateOperationsInput | string
    Supervisor?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    FromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ToDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    JobTitle?: StringFieldUpdateOperationsInput | string
    EndingSalary?: NullableFloatFieldUpdateOperationsInput | number | null
    IsHourlyRate?: NullableStringFieldUpdateOperationsInput | string | null
    LeavingReason?: NullableStringFieldUpdateOperationsInput | string | null
    IsValid?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WSJobApplicationPreviousEmploymentUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    JobApplicationId?: NullableIntFieldUpdateOperationsInput | number | null
    Company?: StringFieldUpdateOperationsInput | string
    Supervisor?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    FromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ToDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    JobTitle?: StringFieldUpdateOperationsInput | string
    EndingSalary?: NullableFloatFieldUpdateOperationsInput | number | null
    IsHourlyRate?: NullableStringFieldUpdateOperationsInput | string | null
    LeavingReason?: NullableStringFieldUpdateOperationsInput | string | null
    IsValid?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WSJobApplicationReferenceCreateInput = {
    FullName: string
    Relationship: string
    Company: string
    Phone: string
    Email: string
    IsValid?: string | null
    WSJobApplication?: WSJobApplicationCreateNestedOneWithoutWSJobApplicationReferenceInput
  }

  export type WSJobApplicationReferenceUncheckedCreateInput = {
    ID?: number
    JobApplicationId?: number | null
    FullName: string
    Relationship: string
    Company: string
    Phone: string
    Email: string
    IsValid?: string | null
  }

  export type WSJobApplicationReferenceUpdateInput = {
    FullName?: StringFieldUpdateOperationsInput | string
    Relationship?: StringFieldUpdateOperationsInput | string
    Company?: StringFieldUpdateOperationsInput | string
    Phone?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    IsValid?: NullableStringFieldUpdateOperationsInput | string | null
    WSJobApplication?: WSJobApplicationUpdateOneWithoutWSJobApplicationReferenceNestedInput
  }

  export type WSJobApplicationReferenceUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    JobApplicationId?: NullableIntFieldUpdateOperationsInput | number | null
    FullName?: StringFieldUpdateOperationsInput | string
    Relationship?: StringFieldUpdateOperationsInput | string
    Company?: StringFieldUpdateOperationsInput | string
    Phone?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    IsValid?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WSJobApplicationReferenceCreateManyInput = {
    JobApplicationId?: number | null
    FullName: string
    Relationship: string
    Company: string
    Phone: string
    Email: string
    IsValid?: string | null
  }

  export type WSJobApplicationReferenceUpdateManyMutationInput = {
    FullName?: StringFieldUpdateOperationsInput | string
    Relationship?: StringFieldUpdateOperationsInput | string
    Company?: StringFieldUpdateOperationsInput | string
    Phone?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    IsValid?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WSJobApplicationReferenceUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    JobApplicationId?: NullableIntFieldUpdateOperationsInput | number | null
    FullName?: StringFieldUpdateOperationsInput | string
    Relationship?: StringFieldUpdateOperationsInput | string
    Company?: StringFieldUpdateOperationsInput | string
    Phone?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    IsValid?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WsJobApplicationReplyCreateInput = {
    Message: string
    CreatedBy: string
    CreatedOn: Date | string
    ModifiedOn?: Date | string | null
    WSJobApplicationFeedback: WSJobApplicationFeedbackCreateNestedOneWithoutWsJobApplicationReplyInput
  }

  export type WsJobApplicationReplyUncheckedCreateInput = {
    ID?: number
    FeedbackID: number
    Message: string
    CreatedBy: string
    CreatedOn: Date | string
    ModifiedOn?: Date | string | null
  }

  export type WsJobApplicationReplyUpdateInput = {
    Message?: StringFieldUpdateOperationsInput | string
    CreatedBy?: StringFieldUpdateOperationsInput | string
    CreatedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    ModifiedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    WSJobApplicationFeedback?: WSJobApplicationFeedbackUpdateOneRequiredWithoutWsJobApplicationReplyNestedInput
  }

  export type WsJobApplicationReplyUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    FeedbackID?: IntFieldUpdateOperationsInput | number
    Message?: StringFieldUpdateOperationsInput | string
    CreatedBy?: StringFieldUpdateOperationsInput | string
    CreatedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    ModifiedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WsJobApplicationReplyCreateManyInput = {
    FeedbackID: number
    Message: string
    CreatedBy: string
    CreatedOn: Date | string
    ModifiedOn?: Date | string | null
  }

  export type WsJobApplicationReplyUpdateManyMutationInput = {
    Message?: StringFieldUpdateOperationsInput | string
    CreatedBy?: StringFieldUpdateOperationsInput | string
    CreatedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    ModifiedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WsJobApplicationReplyUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    FeedbackID?: IntFieldUpdateOperationsInput | number
    Message?: StringFieldUpdateOperationsInput | string
    CreatedBy?: StringFieldUpdateOperationsInput | string
    CreatedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    ModifiedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WsProductsCreateInput = {
    vendor_id: number
    item_number: string
    description?: string | null
    ai_description?: string | null
    ai_name?: string | null
    bucket: string
    original_img_url: string
    final_img_url?: string | null
    top_sold?: number | null
    is_home?: boolean | null
    is_new_arrival?: boolean | null
    status?: string | null
    created_on?: Date | string | null
    created_by?: string | null
    WsDepartments: WsDepartmentsCreateNestedOneWithoutWsProductsInput
  }

  export type WsProductsUncheckedCreateInput = {
    vendor_id: number
    item_number: string
    description?: string | null
    ai_description?: string | null
    ai_name?: string | null
    dep: string
    bucket: string
    original_img_url: string
    final_img_url?: string | null
    top_sold?: number | null
    is_home?: boolean | null
    is_new_arrival?: boolean | null
    status?: string | null
    created_on?: Date | string | null
    created_by?: string | null
  }

  export type WsProductsUpdateInput = {
    vendor_id?: IntFieldUpdateOperationsInput | number
    item_number?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ai_description?: NullableStringFieldUpdateOperationsInput | string | null
    ai_name?: NullableStringFieldUpdateOperationsInput | string | null
    bucket?: StringFieldUpdateOperationsInput | string
    original_img_url?: StringFieldUpdateOperationsInput | string
    final_img_url?: NullableStringFieldUpdateOperationsInput | string | null
    top_sold?: NullableIntFieldUpdateOperationsInput | number | null
    is_home?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_new_arrival?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    WsDepartments?: WsDepartmentsUpdateOneRequiredWithoutWsProductsNestedInput
  }

  export type WsProductsUncheckedUpdateInput = {
    vendor_id?: IntFieldUpdateOperationsInput | number
    item_number?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ai_description?: NullableStringFieldUpdateOperationsInput | string | null
    ai_name?: NullableStringFieldUpdateOperationsInput | string | null
    dep?: StringFieldUpdateOperationsInput | string
    bucket?: StringFieldUpdateOperationsInput | string
    original_img_url?: StringFieldUpdateOperationsInput | string
    final_img_url?: NullableStringFieldUpdateOperationsInput | string | null
    top_sold?: NullableIntFieldUpdateOperationsInput | number | null
    is_home?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_new_arrival?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WsProductsCreateManyInput = {
    vendor_id: number
    item_number: string
    description?: string | null
    ai_description?: string | null
    ai_name?: string | null
    dep: string
    bucket: string
    original_img_url: string
    final_img_url?: string | null
    top_sold?: number | null
    is_home?: boolean | null
    is_new_arrival?: boolean | null
    status?: string | null
    created_on?: Date | string | null
    created_by?: string | null
  }

  export type WsProductsUpdateManyMutationInput = {
    vendor_id?: IntFieldUpdateOperationsInput | number
    item_number?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ai_description?: NullableStringFieldUpdateOperationsInput | string | null
    ai_name?: NullableStringFieldUpdateOperationsInput | string | null
    bucket?: StringFieldUpdateOperationsInput | string
    original_img_url?: StringFieldUpdateOperationsInput | string
    final_img_url?: NullableStringFieldUpdateOperationsInput | string | null
    top_sold?: NullableIntFieldUpdateOperationsInput | number | null
    is_home?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_new_arrival?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WsProductsUncheckedUpdateManyInput = {
    vendor_id?: IntFieldUpdateOperationsInput | number
    item_number?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ai_description?: NullableStringFieldUpdateOperationsInput | string | null
    ai_name?: NullableStringFieldUpdateOperationsInput | string | null
    dep?: StringFieldUpdateOperationsInput | string
    bucket?: StringFieldUpdateOperationsInput | string
    original_img_url?: StringFieldUpdateOperationsInput | string
    final_img_url?: NullableStringFieldUpdateOperationsInput | string | null
    top_sold?: NullableIntFieldUpdateOperationsInput | number | null
    is_home?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_new_arrival?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WsProfileCreateInput = {
    FirstName: string
    MiddleName?: string | null
    LastName: string
    Gender: string
    Age: number
    Email: string
    Auth0Id: string
  }

  export type WsProfileUncheckedCreateInput = {
    ID?: number
    FirstName: string
    MiddleName?: string | null
    LastName: string
    Gender: string
    Age: number
    Email: string
    Auth0Id: string
  }

  export type WsProfileUpdateInput = {
    FirstName?: StringFieldUpdateOperationsInput | string
    MiddleName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: StringFieldUpdateOperationsInput | string
    Gender?: StringFieldUpdateOperationsInput | string
    Age?: IntFieldUpdateOperationsInput | number
    Email?: StringFieldUpdateOperationsInput | string
    Auth0Id?: StringFieldUpdateOperationsInput | string
  }

  export type WsProfileUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    FirstName?: StringFieldUpdateOperationsInput | string
    MiddleName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: StringFieldUpdateOperationsInput | string
    Gender?: StringFieldUpdateOperationsInput | string
    Age?: IntFieldUpdateOperationsInput | number
    Email?: StringFieldUpdateOperationsInput | string
    Auth0Id?: StringFieldUpdateOperationsInput | string
  }

  export type WsProfileCreateManyInput = {
    FirstName: string
    MiddleName?: string | null
    LastName: string
    Gender: string
    Age: number
    Email: string
    Auth0Id: string
  }

  export type WsProfileUpdateManyMutationInput = {
    FirstName?: StringFieldUpdateOperationsInput | string
    MiddleName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: StringFieldUpdateOperationsInput | string
    Gender?: StringFieldUpdateOperationsInput | string
    Age?: IntFieldUpdateOperationsInput | number
    Email?: StringFieldUpdateOperationsInput | string
    Auth0Id?: StringFieldUpdateOperationsInput | string
  }

  export type WsProfileUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    FirstName?: StringFieldUpdateOperationsInput | string
    MiddleName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: StringFieldUpdateOperationsInput | string
    Gender?: StringFieldUpdateOperationsInput | string
    Age?: IntFieldUpdateOperationsInput | number
    Email?: StringFieldUpdateOperationsInput | string
    Auth0Id?: StringFieldUpdateOperationsInput | string
  }

  export type WSStateCreateInput = {
    state?: string | null
    st_licenseNumber?: string | null
    st_expiryDate?: Date | string | null
    st_fileUrl?: string | null
    ll_licenseNumber?: string | null
    ll_expiryDate?: Date | string | null
    ll_fileUrl?: string | null
    WSTaxExempt?: WSTaxExemptCreateNestedOneWithoutWSStateInput
  }

  export type WSStateUncheckedCreateInput = {
    ID?: number
    state?: string | null
    st_licenseNumber?: string | null
    st_expiryDate?: Date | string | null
    st_fileUrl?: string | null
    ll_licenseNumber?: string | null
    ll_expiryDate?: Date | string | null
    ll_fileUrl?: string | null
    taxExemptId?: number | null
  }

  export type WSStateUpdateInput = {
    state?: NullableStringFieldUpdateOperationsInput | string | null
    st_licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    st_expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    st_fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ll_licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ll_expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ll_fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    WSTaxExempt?: WSTaxExemptUpdateOneWithoutWSStateNestedInput
  }

  export type WSStateUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    state?: NullableStringFieldUpdateOperationsInput | string | null
    st_licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    st_expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    st_fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ll_licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ll_expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ll_fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxExemptId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type WSStateCreateManyInput = {
    state?: string | null
    st_licenseNumber?: string | null
    st_expiryDate?: Date | string | null
    st_fileUrl?: string | null
    ll_licenseNumber?: string | null
    ll_expiryDate?: Date | string | null
    ll_fileUrl?: string | null
    taxExemptId?: number | null
  }

  export type WSStateUpdateManyMutationInput = {
    state?: NullableStringFieldUpdateOperationsInput | string | null
    st_licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    st_expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    st_fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ll_licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ll_expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ll_fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WSStateUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    state?: NullableStringFieldUpdateOperationsInput | string | null
    st_licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    st_expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    st_fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ll_licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ll_expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ll_fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxExemptId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type WsStoreCreateInput = {
    Name: string
    Address?: string | null
    Email?: string | null
    BookingUrl?: string | null
    Latitude?: number
    Longitude?: number
    PlaceID?: string
    WSJob?: WSJobCreateNestedManyWithoutWsStoreInput
  }

  export type WsStoreUncheckedCreateInput = {
    ID?: number
    Name: string
    Address?: string | null
    Email?: string | null
    BookingUrl?: string | null
    Latitude?: number
    Longitude?: number
    PlaceID?: string
    WSJob?: WSJobUncheckedCreateNestedManyWithoutWsStoreInput
  }

  export type WsStoreUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    BookingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Latitude?: FloatFieldUpdateOperationsInput | number
    Longitude?: FloatFieldUpdateOperationsInput | number
    PlaceID?: StringFieldUpdateOperationsInput | string
    WSJob?: WSJobUpdateManyWithoutWsStoreNestedInput
  }

  export type WsStoreUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    BookingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Latitude?: FloatFieldUpdateOperationsInput | number
    Longitude?: FloatFieldUpdateOperationsInput | number
    PlaceID?: StringFieldUpdateOperationsInput | string
    WSJob?: WSJobUncheckedUpdateManyWithoutWsStoreNestedInput
  }

  export type WsStoreCreateManyInput = {
    Name: string
    Address?: string | null
    Email?: string | null
    BookingUrl?: string | null
    Latitude?: number
    Longitude?: number
    PlaceID?: string
  }

  export type WsStoreUpdateManyMutationInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    BookingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Latitude?: FloatFieldUpdateOperationsInput | number
    Longitude?: FloatFieldUpdateOperationsInput | number
    PlaceID?: StringFieldUpdateOperationsInput | string
  }

  export type WsStoreUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    BookingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Latitude?: FloatFieldUpdateOperationsInput | number
    Longitude?: FloatFieldUpdateOperationsInput | number
    PlaceID?: StringFieldUpdateOperationsInput | string
  }

  export type WSTaxExemptCreateInput = {
    organization?: string | null
    organizationDescription?: string | null
    number?: string | null
    country?: string | null
    streetAddress?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    mobileNumber?: string | null
    apartment?: string | null
    purpose?: string | null
    organizationType?: string | null
    name?: string | null
    email?: string | null
    status?: string | null
    states?: string | null
    signerName?: string | null
    signerTitle?: string | null
    signature?: string | null
    certificateType?: string | null
    WSState?: WSStateCreateNestedManyWithoutWSTaxExemptInput
  }

  export type WSTaxExemptUncheckedCreateInput = {
    ID?: number
    organization?: string | null
    organizationDescription?: string | null
    number?: string | null
    country?: string | null
    streetAddress?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    mobileNumber?: string | null
    apartment?: string | null
    purpose?: string | null
    organizationType?: string | null
    name?: string | null
    email?: string | null
    status?: string | null
    states?: string | null
    signerName?: string | null
    signerTitle?: string | null
    signature?: string | null
    certificateType?: string | null
    WSState?: WSStateUncheckedCreateNestedManyWithoutWSTaxExemptInput
  }

  export type WSTaxExemptUpdateInput = {
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    organizationDescription?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    streetAddress?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    apartment?: NullableStringFieldUpdateOperationsInput | string | null
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    organizationType?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    states?: NullableStringFieldUpdateOperationsInput | string | null
    signerName?: NullableStringFieldUpdateOperationsInput | string | null
    signerTitle?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    certificateType?: NullableStringFieldUpdateOperationsInput | string | null
    WSState?: WSStateUpdateManyWithoutWSTaxExemptNestedInput
  }

  export type WSTaxExemptUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    organizationDescription?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    streetAddress?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    apartment?: NullableStringFieldUpdateOperationsInput | string | null
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    organizationType?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    states?: NullableStringFieldUpdateOperationsInput | string | null
    signerName?: NullableStringFieldUpdateOperationsInput | string | null
    signerTitle?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    certificateType?: NullableStringFieldUpdateOperationsInput | string | null
    WSState?: WSStateUncheckedUpdateManyWithoutWSTaxExemptNestedInput
  }

  export type WSTaxExemptCreateManyInput = {
    organization?: string | null
    organizationDescription?: string | null
    number?: string | null
    country?: string | null
    streetAddress?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    mobileNumber?: string | null
    apartment?: string | null
    purpose?: string | null
    organizationType?: string | null
    name?: string | null
    email?: string | null
    status?: string | null
    states?: string | null
    signerName?: string | null
    signerTitle?: string | null
    signature?: string | null
    certificateType?: string | null
  }

  export type WSTaxExemptUpdateManyMutationInput = {
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    organizationDescription?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    streetAddress?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    apartment?: NullableStringFieldUpdateOperationsInput | string | null
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    organizationType?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    states?: NullableStringFieldUpdateOperationsInput | string | null
    signerName?: NullableStringFieldUpdateOperationsInput | string | null
    signerTitle?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    certificateType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WSTaxExemptUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    organizationDescription?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    streetAddress?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    apartment?: NullableStringFieldUpdateOperationsInput | string | null
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    organizationType?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    states?: NullableStringFieldUpdateOperationsInput | string | null
    signerName?: NullableStringFieldUpdateOperationsInput | string | null
    signerTitle?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    certificateType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WsUserCreateInput = {
    Name: string
    MiddleName?: string | null
    LastName: string
    Street: string
    Apartment?: string | null
    City: string
    State: string
    Zip: string
    Phone: string
    SocialSecurity: string
    CanWorkInUs: string
    IsLegalAge: string
    ServedInMilitary?: string | null
    MilitaryBranch?: string | null
    MilitaryRank?: string | null
    MilitaryTypeOfDischarge?: string | null
    ResumeUrl?: string | null
    Email: string
    Auth0Id: string
    WSJobApplication?: WSJobApplicationCreateNestedManyWithoutWsUserInput
  }

  export type WsUserUncheckedCreateInput = {
    ID?: number
    Name: string
    MiddleName?: string | null
    LastName: string
    Street: string
    Apartment?: string | null
    City: string
    State: string
    Zip: string
    Phone: string
    SocialSecurity: string
    CanWorkInUs: string
    IsLegalAge: string
    ServedInMilitary?: string | null
    MilitaryBranch?: string | null
    MilitaryRank?: string | null
    MilitaryTypeOfDischarge?: string | null
    ResumeUrl?: string | null
    Email: string
    Auth0Id: string
    WSJobApplication?: WSJobApplicationUncheckedCreateNestedManyWithoutWsUserInput
  }

  export type WsUserUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    MiddleName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: StringFieldUpdateOperationsInput | string
    Street?: StringFieldUpdateOperationsInput | string
    Apartment?: NullableStringFieldUpdateOperationsInput | string | null
    City?: StringFieldUpdateOperationsInput | string
    State?: StringFieldUpdateOperationsInput | string
    Zip?: StringFieldUpdateOperationsInput | string
    Phone?: StringFieldUpdateOperationsInput | string
    SocialSecurity?: StringFieldUpdateOperationsInput | string
    CanWorkInUs?: StringFieldUpdateOperationsInput | string
    IsLegalAge?: StringFieldUpdateOperationsInput | string
    ServedInMilitary?: NullableStringFieldUpdateOperationsInput | string | null
    MilitaryBranch?: NullableStringFieldUpdateOperationsInput | string | null
    MilitaryRank?: NullableStringFieldUpdateOperationsInput | string | null
    MilitaryTypeOfDischarge?: NullableStringFieldUpdateOperationsInput | string | null
    ResumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: StringFieldUpdateOperationsInput | string
    Auth0Id?: StringFieldUpdateOperationsInput | string
    WSJobApplication?: WSJobApplicationUpdateManyWithoutWsUserNestedInput
  }

  export type WsUserUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    MiddleName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: StringFieldUpdateOperationsInput | string
    Street?: StringFieldUpdateOperationsInput | string
    Apartment?: NullableStringFieldUpdateOperationsInput | string | null
    City?: StringFieldUpdateOperationsInput | string
    State?: StringFieldUpdateOperationsInput | string
    Zip?: StringFieldUpdateOperationsInput | string
    Phone?: StringFieldUpdateOperationsInput | string
    SocialSecurity?: StringFieldUpdateOperationsInput | string
    CanWorkInUs?: StringFieldUpdateOperationsInput | string
    IsLegalAge?: StringFieldUpdateOperationsInput | string
    ServedInMilitary?: NullableStringFieldUpdateOperationsInput | string | null
    MilitaryBranch?: NullableStringFieldUpdateOperationsInput | string | null
    MilitaryRank?: NullableStringFieldUpdateOperationsInput | string | null
    MilitaryTypeOfDischarge?: NullableStringFieldUpdateOperationsInput | string | null
    ResumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: StringFieldUpdateOperationsInput | string
    Auth0Id?: StringFieldUpdateOperationsInput | string
    WSJobApplication?: WSJobApplicationUncheckedUpdateManyWithoutWsUserNestedInput
  }

  export type WsUserCreateManyInput = {
    Name: string
    MiddleName?: string | null
    LastName: string
    Street: string
    Apartment?: string | null
    City: string
    State: string
    Zip: string
    Phone: string
    SocialSecurity: string
    CanWorkInUs: string
    IsLegalAge: string
    ServedInMilitary?: string | null
    MilitaryBranch?: string | null
    MilitaryRank?: string | null
    MilitaryTypeOfDischarge?: string | null
    ResumeUrl?: string | null
    Email: string
    Auth0Id: string
  }

  export type WsUserUpdateManyMutationInput = {
    Name?: StringFieldUpdateOperationsInput | string
    MiddleName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: StringFieldUpdateOperationsInput | string
    Street?: StringFieldUpdateOperationsInput | string
    Apartment?: NullableStringFieldUpdateOperationsInput | string | null
    City?: StringFieldUpdateOperationsInput | string
    State?: StringFieldUpdateOperationsInput | string
    Zip?: StringFieldUpdateOperationsInput | string
    Phone?: StringFieldUpdateOperationsInput | string
    SocialSecurity?: StringFieldUpdateOperationsInput | string
    CanWorkInUs?: StringFieldUpdateOperationsInput | string
    IsLegalAge?: StringFieldUpdateOperationsInput | string
    ServedInMilitary?: NullableStringFieldUpdateOperationsInput | string | null
    MilitaryBranch?: NullableStringFieldUpdateOperationsInput | string | null
    MilitaryRank?: NullableStringFieldUpdateOperationsInput | string | null
    MilitaryTypeOfDischarge?: NullableStringFieldUpdateOperationsInput | string | null
    ResumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: StringFieldUpdateOperationsInput | string
    Auth0Id?: StringFieldUpdateOperationsInput | string
  }

  export type WsUserUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    MiddleName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: StringFieldUpdateOperationsInput | string
    Street?: StringFieldUpdateOperationsInput | string
    Apartment?: NullableStringFieldUpdateOperationsInput | string | null
    City?: StringFieldUpdateOperationsInput | string
    State?: StringFieldUpdateOperationsInput | string
    Zip?: StringFieldUpdateOperationsInput | string
    Phone?: StringFieldUpdateOperationsInput | string
    SocialSecurity?: StringFieldUpdateOperationsInput | string
    CanWorkInUs?: StringFieldUpdateOperationsInput | string
    IsLegalAge?: StringFieldUpdateOperationsInput | string
    ServedInMilitary?: NullableStringFieldUpdateOperationsInput | string | null
    MilitaryBranch?: NullableStringFieldUpdateOperationsInput | string | null
    MilitaryRank?: NullableStringFieldUpdateOperationsInput | string | null
    MilitaryTypeOfDischarge?: NullableStringFieldUpdateOperationsInput | string | null
    ResumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: StringFieldUpdateOperationsInput | string
    Auth0Id?: StringFieldUpdateOperationsInput | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type WsBillboardsCountOrderByAggregateInput = {
    ID?: SortOrder
    alias?: SortOrder
    description?: SortOrder
    order?: SortOrder
    is_enabled?: SortOrder
    banner_url?: SortOrder
    created_on?: SortOrder
    created_by?: SortOrder
  }

  export type WsBillboardsAvgOrderByAggregateInput = {
    ID?: SortOrder
    order?: SortOrder
  }

  export type WsBillboardsMaxOrderByAggregateInput = {
    ID?: SortOrder
    alias?: SortOrder
    description?: SortOrder
    order?: SortOrder
    is_enabled?: SortOrder
    banner_url?: SortOrder
    created_on?: SortOrder
    created_by?: SortOrder
  }

  export type WsBillboardsMinOrderByAggregateInput = {
    ID?: SortOrder
    alias?: SortOrder
    description?: SortOrder
    order?: SortOrder
    is_enabled?: SortOrder
    banner_url?: SortOrder
    created_on?: SortOrder
    created_by?: SortOrder
  }

  export type WsBillboardsSumOrderByAggregateInput = {
    ID?: SortOrder
    order?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type WsCategoriesCountOrderByAggregateInput = {
    ID?: SortOrder
    Category?: SortOrder
    Type?: SortOrder
  }

  export type WsCategoriesAvgOrderByAggregateInput = {
    ID?: SortOrder
  }

  export type WsCategoriesMaxOrderByAggregateInput = {
    ID?: SortOrder
    Category?: SortOrder
    Type?: SortOrder
  }

  export type WsCategoriesMinOrderByAggregateInput = {
    ID?: SortOrder
    Category?: SortOrder
    Type?: SortOrder
  }

  export type WsCategoriesSumOrderByAggregateInput = {
    ID?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type WsProductsListRelationFilter = {
    every?: WsProductsWhereInput
    some?: WsProductsWhereInput
    none?: WsProductsWhereInput
  }

  export type WsProductsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WsDepartmentsCountOrderByAggregateInput = {
    dep?: SortOrder
    alias?: SortOrder
    order?: SortOrder
    app_bar?: SortOrder
    banner_url?: SortOrder
    created_on?: SortOrder
    created_by?: SortOrder
  }

  export type WsDepartmentsAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type WsDepartmentsMaxOrderByAggregateInput = {
    dep?: SortOrder
    alias?: SortOrder
    order?: SortOrder
    app_bar?: SortOrder
    banner_url?: SortOrder
    created_on?: SortOrder
    created_by?: SortOrder
  }

  export type WsDepartmentsMinOrderByAggregateInput = {
    dep?: SortOrder
    alias?: SortOrder
    order?: SortOrder
    app_bar?: SortOrder
    banner_url?: SortOrder
    created_on?: SortOrder
    created_by?: SortOrder
  }

  export type WsDepartmentsSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type WsHomeBannersCountOrderByAggregateInput = {
    ID?: SortOrder
    dep?: SortOrder
    image_url?: SortOrder
  }

  export type WsHomeBannersAvgOrderByAggregateInput = {
    ID?: SortOrder
  }

  export type WsHomeBannersMaxOrderByAggregateInput = {
    ID?: SortOrder
    dep?: SortOrder
    image_url?: SortOrder
  }

  export type WsHomeBannersMinOrderByAggregateInput = {
    ID?: SortOrder
    dep?: SortOrder
    image_url?: SortOrder
  }

  export type WsHomeBannersSumOrderByAggregateInput = {
    ID?: SortOrder
  }

  export type WsImagesVendor_idItem_numberCompoundUniqueInput = {
    vendor_id: number
    item_number: string
  }

  export type WsImagesCountOrderByAggregateInput = {
    vendor_id?: SortOrder
    item_number?: SortOrder
    image_url?: SortOrder
    created_on?: SortOrder
    created_by?: SortOrder
  }

  export type WsImagesAvgOrderByAggregateInput = {
    vendor_id?: SortOrder
  }

  export type WsImagesMaxOrderByAggregateInput = {
    vendor_id?: SortOrder
    item_number?: SortOrder
    image_url?: SortOrder
    created_on?: SortOrder
    created_by?: SortOrder
  }

  export type WsImagesMinOrderByAggregateInput = {
    vendor_id?: SortOrder
    item_number?: SortOrder
    image_url?: SortOrder
    created_on?: SortOrder
    created_by?: SortOrder
  }

  export type WsImagesSumOrderByAggregateInput = {
    vendor_id?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type WsStoreRelationFilter = {
    is?: WsStoreWhereInput
    isNot?: WsStoreWhereInput
  }

  export type WSJobApplicationListRelationFilter = {
    every?: WSJobApplicationWhereInput
    some?: WSJobApplicationWhereInput
    none?: WSJobApplicationWhereInput
  }

  export type WSJobApplicationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WSJobCountOrderByAggregateInput = {
    ID?: SortOrder
    Name?: SortOrder
    Description?: SortOrder
    Type?: SortOrder
    Category?: SortOrder
    CreatedOn?: SortOrder
    Active?: SortOrder
    StoreId?: SortOrder
    Status?: SortOrder
    CreatedBy?: SortOrder
    MaxSalary?: SortOrder
    MinSalary?: SortOrder
    SalaryType?: SortOrder
  }

  export type WSJobAvgOrderByAggregateInput = {
    ID?: SortOrder
    StoreId?: SortOrder
    MaxSalary?: SortOrder
    MinSalary?: SortOrder
  }

  export type WSJobMaxOrderByAggregateInput = {
    ID?: SortOrder
    Name?: SortOrder
    Description?: SortOrder
    Type?: SortOrder
    Category?: SortOrder
    CreatedOn?: SortOrder
    Active?: SortOrder
    StoreId?: SortOrder
    Status?: SortOrder
    CreatedBy?: SortOrder
    MaxSalary?: SortOrder
    MinSalary?: SortOrder
    SalaryType?: SortOrder
  }

  export type WSJobMinOrderByAggregateInput = {
    ID?: SortOrder
    Name?: SortOrder
    Description?: SortOrder
    Type?: SortOrder
    Category?: SortOrder
    CreatedOn?: SortOrder
    Active?: SortOrder
    StoreId?: SortOrder
    Status?: SortOrder
    CreatedBy?: SortOrder
    MaxSalary?: SortOrder
    MinSalary?: SortOrder
    SalaryType?: SortOrder
  }

  export type WSJobSumOrderByAggregateInput = {
    ID?: SortOrder
    StoreId?: SortOrder
    MaxSalary?: SortOrder
    MinSalary?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type WSJobRelationFilter = {
    is?: WSJobWhereInput
    isNot?: WSJobWhereInput
  }

  export type WsUserRelationFilter = {
    is?: WsUserWhereInput
    isNot?: WsUserWhereInput
  }

  export type WSJobApplicationEducationListRelationFilter = {
    every?: WSJobApplicationEducationWhereInput
    some?: WSJobApplicationEducationWhereInput
    none?: WSJobApplicationEducationWhereInput
  }

  export type WSJobApplicationFeedbackListRelationFilter = {
    every?: WSJobApplicationFeedbackWhereInput
    some?: WSJobApplicationFeedbackWhereInput
    none?: WSJobApplicationFeedbackWhereInput
  }

  export type WSJobApplicationPreviousEmploymentListRelationFilter = {
    every?: WSJobApplicationPreviousEmploymentWhereInput
    some?: WSJobApplicationPreviousEmploymentWhereInput
    none?: WSJobApplicationPreviousEmploymentWhereInput
  }

  export type WSJobApplicationReferenceListRelationFilter = {
    every?: WSJobApplicationReferenceWhereInput
    some?: WSJobApplicationReferenceWhereInput
    none?: WSJobApplicationReferenceWhereInput
  }

  export type WSJobApplicationEducationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WSJobApplicationFeedbackOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WSJobApplicationPreviousEmploymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WSJobApplicationReferenceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WSJobApplicationCountOrderByAggregateInput = {
    ID?: SortOrder
    JobId?: SortOrder
    UserId?: SortOrder
    IsValid?: SortOrder
    Status?: SortOrder
    Active?: SortOrder
    CreatedBy?: SortOrder
    CreatedOn?: SortOrder
    IsDenied?: SortOrder
  }

  export type WSJobApplicationAvgOrderByAggregateInput = {
    ID?: SortOrder
    JobId?: SortOrder
    UserId?: SortOrder
  }

  export type WSJobApplicationMaxOrderByAggregateInput = {
    ID?: SortOrder
    JobId?: SortOrder
    UserId?: SortOrder
    IsValid?: SortOrder
    Status?: SortOrder
    Active?: SortOrder
    CreatedBy?: SortOrder
    CreatedOn?: SortOrder
    IsDenied?: SortOrder
  }

  export type WSJobApplicationMinOrderByAggregateInput = {
    ID?: SortOrder
    JobId?: SortOrder
    UserId?: SortOrder
    IsValid?: SortOrder
    Status?: SortOrder
    Active?: SortOrder
    CreatedBy?: SortOrder
    CreatedOn?: SortOrder
    IsDenied?: SortOrder
  }

  export type WSJobApplicationSumOrderByAggregateInput = {
    ID?: SortOrder
    JobId?: SortOrder
    UserId?: SortOrder
  }

  export type WSJobApplicationNullableRelationFilter = {
    is?: WSJobApplicationWhereInput | null
    isNot?: WSJobApplicationWhereInput | null
  }

  export type WSJobApplicationEducationCountOrderByAggregateInput = {
    ID?: SortOrder
    JobApplicationId?: SortOrder
    EducationLevel?: SortOrder
    Name?: SortOrder
    Address?: SortOrder
    FromDate?: SortOrder
    ToDate?: SortOrder
    IsGraduated?: SortOrder
    IsValid?: SortOrder
  }

  export type WSJobApplicationEducationAvgOrderByAggregateInput = {
    ID?: SortOrder
    JobApplicationId?: SortOrder
  }

  export type WSJobApplicationEducationMaxOrderByAggregateInput = {
    ID?: SortOrder
    JobApplicationId?: SortOrder
    EducationLevel?: SortOrder
    Name?: SortOrder
    Address?: SortOrder
    FromDate?: SortOrder
    ToDate?: SortOrder
    IsGraduated?: SortOrder
    IsValid?: SortOrder
  }

  export type WSJobApplicationEducationMinOrderByAggregateInput = {
    ID?: SortOrder
    JobApplicationId?: SortOrder
    EducationLevel?: SortOrder
    Name?: SortOrder
    Address?: SortOrder
    FromDate?: SortOrder
    ToDate?: SortOrder
    IsGraduated?: SortOrder
    IsValid?: SortOrder
  }

  export type WSJobApplicationEducationSumOrderByAggregateInput = {
    ID?: SortOrder
    JobApplicationId?: SortOrder
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type WSJobApplicationRelationFilter = {
    is?: WSJobApplicationWhereInput
    isNot?: WSJobApplicationWhereInput
  }

  export type WsJobApplicationReplyListRelationFilter = {
    every?: WsJobApplicationReplyWhereInput
    some?: WsJobApplicationReplyWhereInput
    none?: WsJobApplicationReplyWhereInput
  }

  export type WsJobApplicationReplyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WSJobApplicationFeedbackCountOrderByAggregateInput = {
    ID?: SortOrder
    JobApplicationID?: SortOrder
    Feedback?: SortOrder
    CreatedBy?: SortOrder
    CreatedOn?: SortOrder
  }

  export type WSJobApplicationFeedbackAvgOrderByAggregateInput = {
    ID?: SortOrder
    JobApplicationID?: SortOrder
  }

  export type WSJobApplicationFeedbackMaxOrderByAggregateInput = {
    ID?: SortOrder
    JobApplicationID?: SortOrder
    Feedback?: SortOrder
    CreatedBy?: SortOrder
    CreatedOn?: SortOrder
  }

  export type WSJobApplicationFeedbackMinOrderByAggregateInput = {
    ID?: SortOrder
    JobApplicationID?: SortOrder
    Feedback?: SortOrder
    CreatedBy?: SortOrder
    CreatedOn?: SortOrder
  }

  export type WSJobApplicationFeedbackSumOrderByAggregateInput = {
    ID?: SortOrder
    JobApplicationID?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type WSJobApplicationPreviousEmploymentCountOrderByAggregateInput = {
    ID?: SortOrder
    JobApplicationId?: SortOrder
    Company?: SortOrder
    Supervisor?: SortOrder
    Address?: SortOrder
    FromDate?: SortOrder
    ToDate?: SortOrder
    JobTitle?: SortOrder
    EndingSalary?: SortOrder
    IsHourlyRate?: SortOrder
    LeavingReason?: SortOrder
    IsValid?: SortOrder
  }

  export type WSJobApplicationPreviousEmploymentAvgOrderByAggregateInput = {
    ID?: SortOrder
    JobApplicationId?: SortOrder
    EndingSalary?: SortOrder
  }

  export type WSJobApplicationPreviousEmploymentMaxOrderByAggregateInput = {
    ID?: SortOrder
    JobApplicationId?: SortOrder
    Company?: SortOrder
    Supervisor?: SortOrder
    Address?: SortOrder
    FromDate?: SortOrder
    ToDate?: SortOrder
    JobTitle?: SortOrder
    EndingSalary?: SortOrder
    IsHourlyRate?: SortOrder
    LeavingReason?: SortOrder
    IsValid?: SortOrder
  }

  export type WSJobApplicationPreviousEmploymentMinOrderByAggregateInput = {
    ID?: SortOrder
    JobApplicationId?: SortOrder
    Company?: SortOrder
    Supervisor?: SortOrder
    Address?: SortOrder
    FromDate?: SortOrder
    ToDate?: SortOrder
    JobTitle?: SortOrder
    EndingSalary?: SortOrder
    IsHourlyRate?: SortOrder
    LeavingReason?: SortOrder
    IsValid?: SortOrder
  }

  export type WSJobApplicationPreviousEmploymentSumOrderByAggregateInput = {
    ID?: SortOrder
    JobApplicationId?: SortOrder
    EndingSalary?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type WSJobApplicationReferenceCountOrderByAggregateInput = {
    ID?: SortOrder
    JobApplicationId?: SortOrder
    FullName?: SortOrder
    Relationship?: SortOrder
    Company?: SortOrder
    Phone?: SortOrder
    Email?: SortOrder
    IsValid?: SortOrder
  }

  export type WSJobApplicationReferenceAvgOrderByAggregateInput = {
    ID?: SortOrder
    JobApplicationId?: SortOrder
  }

  export type WSJobApplicationReferenceMaxOrderByAggregateInput = {
    ID?: SortOrder
    JobApplicationId?: SortOrder
    FullName?: SortOrder
    Relationship?: SortOrder
    Company?: SortOrder
    Phone?: SortOrder
    Email?: SortOrder
    IsValid?: SortOrder
  }

  export type WSJobApplicationReferenceMinOrderByAggregateInput = {
    ID?: SortOrder
    JobApplicationId?: SortOrder
    FullName?: SortOrder
    Relationship?: SortOrder
    Company?: SortOrder
    Phone?: SortOrder
    Email?: SortOrder
    IsValid?: SortOrder
  }

  export type WSJobApplicationReferenceSumOrderByAggregateInput = {
    ID?: SortOrder
    JobApplicationId?: SortOrder
  }

  export type WSJobApplicationFeedbackRelationFilter = {
    is?: WSJobApplicationFeedbackWhereInput
    isNot?: WSJobApplicationFeedbackWhereInput
  }

  export type WsJobApplicationReplyCountOrderByAggregateInput = {
    ID?: SortOrder
    FeedbackID?: SortOrder
    Message?: SortOrder
    CreatedBy?: SortOrder
    CreatedOn?: SortOrder
    ModifiedOn?: SortOrder
  }

  export type WsJobApplicationReplyAvgOrderByAggregateInput = {
    ID?: SortOrder
    FeedbackID?: SortOrder
  }

  export type WsJobApplicationReplyMaxOrderByAggregateInput = {
    ID?: SortOrder
    FeedbackID?: SortOrder
    Message?: SortOrder
    CreatedBy?: SortOrder
    CreatedOn?: SortOrder
    ModifiedOn?: SortOrder
  }

  export type WsJobApplicationReplyMinOrderByAggregateInput = {
    ID?: SortOrder
    FeedbackID?: SortOrder
    Message?: SortOrder
    CreatedBy?: SortOrder
    CreatedOn?: SortOrder
    ModifiedOn?: SortOrder
  }

  export type WsJobApplicationReplySumOrderByAggregateInput = {
    ID?: SortOrder
    FeedbackID?: SortOrder
  }

  export type WsDepartmentsRelationFilter = {
    is?: WsDepartmentsWhereInput
    isNot?: WsDepartmentsWhereInput
  }

  export type WsProductsItem_numberVendor_idCompoundUniqueInput = {
    item_number: string
    vendor_id: number
  }

  export type WsProductsCountOrderByAggregateInput = {
    vendor_id?: SortOrder
    item_number?: SortOrder
    description?: SortOrder
    ai_description?: SortOrder
    ai_name?: SortOrder
    dep?: SortOrder
    bucket?: SortOrder
    original_img_url?: SortOrder
    final_img_url?: SortOrder
    top_sold?: SortOrder
    is_home?: SortOrder
    is_new_arrival?: SortOrder
    status?: SortOrder
    created_on?: SortOrder
    created_by?: SortOrder
  }

  export type WsProductsAvgOrderByAggregateInput = {
    vendor_id?: SortOrder
    top_sold?: SortOrder
  }

  export type WsProductsMaxOrderByAggregateInput = {
    vendor_id?: SortOrder
    item_number?: SortOrder
    description?: SortOrder
    ai_description?: SortOrder
    ai_name?: SortOrder
    dep?: SortOrder
    bucket?: SortOrder
    original_img_url?: SortOrder
    final_img_url?: SortOrder
    top_sold?: SortOrder
    is_home?: SortOrder
    is_new_arrival?: SortOrder
    status?: SortOrder
    created_on?: SortOrder
    created_by?: SortOrder
  }

  export type WsProductsMinOrderByAggregateInput = {
    vendor_id?: SortOrder
    item_number?: SortOrder
    description?: SortOrder
    ai_description?: SortOrder
    ai_name?: SortOrder
    dep?: SortOrder
    bucket?: SortOrder
    original_img_url?: SortOrder
    final_img_url?: SortOrder
    top_sold?: SortOrder
    is_home?: SortOrder
    is_new_arrival?: SortOrder
    status?: SortOrder
    created_on?: SortOrder
    created_by?: SortOrder
  }

  export type WsProductsSumOrderByAggregateInput = {
    vendor_id?: SortOrder
    top_sold?: SortOrder
  }

  export type WsProfileCountOrderByAggregateInput = {
    ID?: SortOrder
    FirstName?: SortOrder
    MiddleName?: SortOrder
    LastName?: SortOrder
    Gender?: SortOrder
    Age?: SortOrder
    Email?: SortOrder
    Auth0Id?: SortOrder
  }

  export type WsProfileAvgOrderByAggregateInput = {
    ID?: SortOrder
    Age?: SortOrder
  }

  export type WsProfileMaxOrderByAggregateInput = {
    ID?: SortOrder
    FirstName?: SortOrder
    MiddleName?: SortOrder
    LastName?: SortOrder
    Gender?: SortOrder
    Age?: SortOrder
    Email?: SortOrder
    Auth0Id?: SortOrder
  }

  export type WsProfileMinOrderByAggregateInput = {
    ID?: SortOrder
    FirstName?: SortOrder
    MiddleName?: SortOrder
    LastName?: SortOrder
    Gender?: SortOrder
    Age?: SortOrder
    Email?: SortOrder
    Auth0Id?: SortOrder
  }

  export type WsProfileSumOrderByAggregateInput = {
    ID?: SortOrder
    Age?: SortOrder
  }

  export type WSTaxExemptNullableRelationFilter = {
    is?: WSTaxExemptWhereInput | null
    isNot?: WSTaxExemptWhereInput | null
  }

  export type WSStateCountOrderByAggregateInput = {
    ID?: SortOrder
    state?: SortOrder
    st_licenseNumber?: SortOrder
    st_expiryDate?: SortOrder
    st_fileUrl?: SortOrder
    ll_licenseNumber?: SortOrder
    ll_expiryDate?: SortOrder
    ll_fileUrl?: SortOrder
    taxExemptId?: SortOrder
  }

  export type WSStateAvgOrderByAggregateInput = {
    ID?: SortOrder
    taxExemptId?: SortOrder
  }

  export type WSStateMaxOrderByAggregateInput = {
    ID?: SortOrder
    state?: SortOrder
    st_licenseNumber?: SortOrder
    st_expiryDate?: SortOrder
    st_fileUrl?: SortOrder
    ll_licenseNumber?: SortOrder
    ll_expiryDate?: SortOrder
    ll_fileUrl?: SortOrder
    taxExemptId?: SortOrder
  }

  export type WSStateMinOrderByAggregateInput = {
    ID?: SortOrder
    state?: SortOrder
    st_licenseNumber?: SortOrder
    st_expiryDate?: SortOrder
    st_fileUrl?: SortOrder
    ll_licenseNumber?: SortOrder
    ll_expiryDate?: SortOrder
    ll_fileUrl?: SortOrder
    taxExemptId?: SortOrder
  }

  export type WSStateSumOrderByAggregateInput = {
    ID?: SortOrder
    taxExemptId?: SortOrder
  }

  export type WSJobListRelationFilter = {
    every?: WSJobWhereInput
    some?: WSJobWhereInput
    none?: WSJobWhereInput
  }

  export type WSJobOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WsStoreCountOrderByAggregateInput = {
    ID?: SortOrder
    Name?: SortOrder
    Address?: SortOrder
    Email?: SortOrder
    BookingUrl?: SortOrder
    Latitude?: SortOrder
    Longitude?: SortOrder
    PlaceID?: SortOrder
  }

  export type WsStoreAvgOrderByAggregateInput = {
    ID?: SortOrder
    Latitude?: SortOrder
    Longitude?: SortOrder
  }

  export type WsStoreMaxOrderByAggregateInput = {
    ID?: SortOrder
    Name?: SortOrder
    Address?: SortOrder
    Email?: SortOrder
    BookingUrl?: SortOrder
    Latitude?: SortOrder
    Longitude?: SortOrder
    PlaceID?: SortOrder
  }

  export type WsStoreMinOrderByAggregateInput = {
    ID?: SortOrder
    Name?: SortOrder
    Address?: SortOrder
    Email?: SortOrder
    BookingUrl?: SortOrder
    Latitude?: SortOrder
    Longitude?: SortOrder
    PlaceID?: SortOrder
  }

  export type WsStoreSumOrderByAggregateInput = {
    ID?: SortOrder
    Latitude?: SortOrder
    Longitude?: SortOrder
  }

  export type WSStateListRelationFilter = {
    every?: WSStateWhereInput
    some?: WSStateWhereInput
    none?: WSStateWhereInput
  }

  export type WSStateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WSTaxExemptCountOrderByAggregateInput = {
    ID?: SortOrder
    organization?: SortOrder
    organizationDescription?: SortOrder
    number?: SortOrder
    country?: SortOrder
    streetAddress?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zip?: SortOrder
    mobileNumber?: SortOrder
    apartment?: SortOrder
    purpose?: SortOrder
    organizationType?: SortOrder
    name?: SortOrder
    email?: SortOrder
    status?: SortOrder
    states?: SortOrder
    signerName?: SortOrder
    signerTitle?: SortOrder
    signature?: SortOrder
    certificateType?: SortOrder
  }

  export type WSTaxExemptAvgOrderByAggregateInput = {
    ID?: SortOrder
  }

  export type WSTaxExemptMaxOrderByAggregateInput = {
    ID?: SortOrder
    organization?: SortOrder
    organizationDescription?: SortOrder
    number?: SortOrder
    country?: SortOrder
    streetAddress?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zip?: SortOrder
    mobileNumber?: SortOrder
    apartment?: SortOrder
    purpose?: SortOrder
    organizationType?: SortOrder
    name?: SortOrder
    email?: SortOrder
    status?: SortOrder
    states?: SortOrder
    signerName?: SortOrder
    signerTitle?: SortOrder
    signature?: SortOrder
    certificateType?: SortOrder
  }

  export type WSTaxExemptMinOrderByAggregateInput = {
    ID?: SortOrder
    organization?: SortOrder
    organizationDescription?: SortOrder
    number?: SortOrder
    country?: SortOrder
    streetAddress?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zip?: SortOrder
    mobileNumber?: SortOrder
    apartment?: SortOrder
    purpose?: SortOrder
    organizationType?: SortOrder
    name?: SortOrder
    email?: SortOrder
    status?: SortOrder
    states?: SortOrder
    signerName?: SortOrder
    signerTitle?: SortOrder
    signature?: SortOrder
    certificateType?: SortOrder
  }

  export type WSTaxExemptSumOrderByAggregateInput = {
    ID?: SortOrder
  }

  export type WsUserCountOrderByAggregateInput = {
    ID?: SortOrder
    Name?: SortOrder
    MiddleName?: SortOrder
    LastName?: SortOrder
    Street?: SortOrder
    Apartment?: SortOrder
    City?: SortOrder
    State?: SortOrder
    Zip?: SortOrder
    Phone?: SortOrder
    SocialSecurity?: SortOrder
    CanWorkInUs?: SortOrder
    IsLegalAge?: SortOrder
    ServedInMilitary?: SortOrder
    MilitaryBranch?: SortOrder
    MilitaryRank?: SortOrder
    MilitaryTypeOfDischarge?: SortOrder
    ResumeUrl?: SortOrder
    Email?: SortOrder
    Auth0Id?: SortOrder
  }

  export type WsUserAvgOrderByAggregateInput = {
    ID?: SortOrder
  }

  export type WsUserMaxOrderByAggregateInput = {
    ID?: SortOrder
    Name?: SortOrder
    MiddleName?: SortOrder
    LastName?: SortOrder
    Street?: SortOrder
    Apartment?: SortOrder
    City?: SortOrder
    State?: SortOrder
    Zip?: SortOrder
    Phone?: SortOrder
    SocialSecurity?: SortOrder
    CanWorkInUs?: SortOrder
    IsLegalAge?: SortOrder
    ServedInMilitary?: SortOrder
    MilitaryBranch?: SortOrder
    MilitaryRank?: SortOrder
    MilitaryTypeOfDischarge?: SortOrder
    ResumeUrl?: SortOrder
    Email?: SortOrder
    Auth0Id?: SortOrder
  }

  export type WsUserMinOrderByAggregateInput = {
    ID?: SortOrder
    Name?: SortOrder
    MiddleName?: SortOrder
    LastName?: SortOrder
    Street?: SortOrder
    Apartment?: SortOrder
    City?: SortOrder
    State?: SortOrder
    Zip?: SortOrder
    Phone?: SortOrder
    SocialSecurity?: SortOrder
    CanWorkInUs?: SortOrder
    IsLegalAge?: SortOrder
    ServedInMilitary?: SortOrder
    MilitaryBranch?: SortOrder
    MilitaryRank?: SortOrder
    MilitaryTypeOfDischarge?: SortOrder
    ResumeUrl?: SortOrder
    Email?: SortOrder
    Auth0Id?: SortOrder
  }

  export type WsUserSumOrderByAggregateInput = {
    ID?: SortOrder
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type WsProductsCreateNestedManyWithoutWsDepartmentsInput = {
    create?: XOR<WsProductsCreateWithoutWsDepartmentsInput, WsProductsUncheckedCreateWithoutWsDepartmentsInput> | WsProductsCreateWithoutWsDepartmentsInput[] | WsProductsUncheckedCreateWithoutWsDepartmentsInput[]
    connectOrCreate?: WsProductsCreateOrConnectWithoutWsDepartmentsInput | WsProductsCreateOrConnectWithoutWsDepartmentsInput[]
    createMany?: WsProductsCreateManyWsDepartmentsInputEnvelope
    connect?: WsProductsWhereUniqueInput | WsProductsWhereUniqueInput[]
  }

  export type WsProductsUncheckedCreateNestedManyWithoutWsDepartmentsInput = {
    create?: XOR<WsProductsCreateWithoutWsDepartmentsInput, WsProductsUncheckedCreateWithoutWsDepartmentsInput> | WsProductsCreateWithoutWsDepartmentsInput[] | WsProductsUncheckedCreateWithoutWsDepartmentsInput[]
    connectOrCreate?: WsProductsCreateOrConnectWithoutWsDepartmentsInput | WsProductsCreateOrConnectWithoutWsDepartmentsInput[]
    createMany?: WsProductsCreateManyWsDepartmentsInputEnvelope
    connect?: WsProductsWhereUniqueInput | WsProductsWhereUniqueInput[]
  }

  export type WsProductsUpdateManyWithoutWsDepartmentsNestedInput = {
    create?: XOR<WsProductsCreateWithoutWsDepartmentsInput, WsProductsUncheckedCreateWithoutWsDepartmentsInput> | WsProductsCreateWithoutWsDepartmentsInput[] | WsProductsUncheckedCreateWithoutWsDepartmentsInput[]
    connectOrCreate?: WsProductsCreateOrConnectWithoutWsDepartmentsInput | WsProductsCreateOrConnectWithoutWsDepartmentsInput[]
    upsert?: WsProductsUpsertWithWhereUniqueWithoutWsDepartmentsInput | WsProductsUpsertWithWhereUniqueWithoutWsDepartmentsInput[]
    createMany?: WsProductsCreateManyWsDepartmentsInputEnvelope
    set?: WsProductsWhereUniqueInput | WsProductsWhereUniqueInput[]
    disconnect?: WsProductsWhereUniqueInput | WsProductsWhereUniqueInput[]
    delete?: WsProductsWhereUniqueInput | WsProductsWhereUniqueInput[]
    connect?: WsProductsWhereUniqueInput | WsProductsWhereUniqueInput[]
    update?: WsProductsUpdateWithWhereUniqueWithoutWsDepartmentsInput | WsProductsUpdateWithWhereUniqueWithoutWsDepartmentsInput[]
    updateMany?: WsProductsUpdateManyWithWhereWithoutWsDepartmentsInput | WsProductsUpdateManyWithWhereWithoutWsDepartmentsInput[]
    deleteMany?: WsProductsScalarWhereInput | WsProductsScalarWhereInput[]
  }

  export type WsProductsUncheckedUpdateManyWithoutWsDepartmentsNestedInput = {
    create?: XOR<WsProductsCreateWithoutWsDepartmentsInput, WsProductsUncheckedCreateWithoutWsDepartmentsInput> | WsProductsCreateWithoutWsDepartmentsInput[] | WsProductsUncheckedCreateWithoutWsDepartmentsInput[]
    connectOrCreate?: WsProductsCreateOrConnectWithoutWsDepartmentsInput | WsProductsCreateOrConnectWithoutWsDepartmentsInput[]
    upsert?: WsProductsUpsertWithWhereUniqueWithoutWsDepartmentsInput | WsProductsUpsertWithWhereUniqueWithoutWsDepartmentsInput[]
    createMany?: WsProductsCreateManyWsDepartmentsInputEnvelope
    set?: WsProductsWhereUniqueInput | WsProductsWhereUniqueInput[]
    disconnect?: WsProductsWhereUniqueInput | WsProductsWhereUniqueInput[]
    delete?: WsProductsWhereUniqueInput | WsProductsWhereUniqueInput[]
    connect?: WsProductsWhereUniqueInput | WsProductsWhereUniqueInput[]
    update?: WsProductsUpdateWithWhereUniqueWithoutWsDepartmentsInput | WsProductsUpdateWithWhereUniqueWithoutWsDepartmentsInput[]
    updateMany?: WsProductsUpdateManyWithWhereWithoutWsDepartmentsInput | WsProductsUpdateManyWithWhereWithoutWsDepartmentsInput[]
    deleteMany?: WsProductsScalarWhereInput | WsProductsScalarWhereInput[]
  }

  export type WsStoreCreateNestedOneWithoutWSJobInput = {
    create?: XOR<WsStoreCreateWithoutWSJobInput, WsStoreUncheckedCreateWithoutWSJobInput>
    connectOrCreate?: WsStoreCreateOrConnectWithoutWSJobInput
    connect?: WsStoreWhereUniqueInput
  }

  export type WSJobApplicationCreateNestedManyWithoutWSJobInput = {
    create?: XOR<WSJobApplicationCreateWithoutWSJobInput, WSJobApplicationUncheckedCreateWithoutWSJobInput> | WSJobApplicationCreateWithoutWSJobInput[] | WSJobApplicationUncheckedCreateWithoutWSJobInput[]
    connectOrCreate?: WSJobApplicationCreateOrConnectWithoutWSJobInput | WSJobApplicationCreateOrConnectWithoutWSJobInput[]
    createMany?: WSJobApplicationCreateManyWSJobInputEnvelope
    connect?: WSJobApplicationWhereUniqueInput | WSJobApplicationWhereUniqueInput[]
  }

  export type WSJobApplicationUncheckedCreateNestedManyWithoutWSJobInput = {
    create?: XOR<WSJobApplicationCreateWithoutWSJobInput, WSJobApplicationUncheckedCreateWithoutWSJobInput> | WSJobApplicationCreateWithoutWSJobInput[] | WSJobApplicationUncheckedCreateWithoutWSJobInput[]
    connectOrCreate?: WSJobApplicationCreateOrConnectWithoutWSJobInput | WSJobApplicationCreateOrConnectWithoutWSJobInput[]
    createMany?: WSJobApplicationCreateManyWSJobInputEnvelope
    connect?: WSJobApplicationWhereUniqueInput | WSJobApplicationWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type WsStoreUpdateOneRequiredWithoutWSJobNestedInput = {
    create?: XOR<WsStoreCreateWithoutWSJobInput, WsStoreUncheckedCreateWithoutWSJobInput>
    connectOrCreate?: WsStoreCreateOrConnectWithoutWSJobInput
    upsert?: WsStoreUpsertWithoutWSJobInput
    connect?: WsStoreWhereUniqueInput
    update?: XOR<XOR<WsStoreUpdateToOneWithWhereWithoutWSJobInput, WsStoreUpdateWithoutWSJobInput>, WsStoreUncheckedUpdateWithoutWSJobInput>
  }

  export type WSJobApplicationUpdateManyWithoutWSJobNestedInput = {
    create?: XOR<WSJobApplicationCreateWithoutWSJobInput, WSJobApplicationUncheckedCreateWithoutWSJobInput> | WSJobApplicationCreateWithoutWSJobInput[] | WSJobApplicationUncheckedCreateWithoutWSJobInput[]
    connectOrCreate?: WSJobApplicationCreateOrConnectWithoutWSJobInput | WSJobApplicationCreateOrConnectWithoutWSJobInput[]
    upsert?: WSJobApplicationUpsertWithWhereUniqueWithoutWSJobInput | WSJobApplicationUpsertWithWhereUniqueWithoutWSJobInput[]
    createMany?: WSJobApplicationCreateManyWSJobInputEnvelope
    set?: WSJobApplicationWhereUniqueInput | WSJobApplicationWhereUniqueInput[]
    disconnect?: WSJobApplicationWhereUniqueInput | WSJobApplicationWhereUniqueInput[]
    delete?: WSJobApplicationWhereUniqueInput | WSJobApplicationWhereUniqueInput[]
    connect?: WSJobApplicationWhereUniqueInput | WSJobApplicationWhereUniqueInput[]
    update?: WSJobApplicationUpdateWithWhereUniqueWithoutWSJobInput | WSJobApplicationUpdateWithWhereUniqueWithoutWSJobInput[]
    updateMany?: WSJobApplicationUpdateManyWithWhereWithoutWSJobInput | WSJobApplicationUpdateManyWithWhereWithoutWSJobInput[]
    deleteMany?: WSJobApplicationScalarWhereInput | WSJobApplicationScalarWhereInput[]
  }

  export type WSJobApplicationUncheckedUpdateManyWithoutWSJobNestedInput = {
    create?: XOR<WSJobApplicationCreateWithoutWSJobInput, WSJobApplicationUncheckedCreateWithoutWSJobInput> | WSJobApplicationCreateWithoutWSJobInput[] | WSJobApplicationUncheckedCreateWithoutWSJobInput[]
    connectOrCreate?: WSJobApplicationCreateOrConnectWithoutWSJobInput | WSJobApplicationCreateOrConnectWithoutWSJobInput[]
    upsert?: WSJobApplicationUpsertWithWhereUniqueWithoutWSJobInput | WSJobApplicationUpsertWithWhereUniqueWithoutWSJobInput[]
    createMany?: WSJobApplicationCreateManyWSJobInputEnvelope
    set?: WSJobApplicationWhereUniqueInput | WSJobApplicationWhereUniqueInput[]
    disconnect?: WSJobApplicationWhereUniqueInput | WSJobApplicationWhereUniqueInput[]
    delete?: WSJobApplicationWhereUniqueInput | WSJobApplicationWhereUniqueInput[]
    connect?: WSJobApplicationWhereUniqueInput | WSJobApplicationWhereUniqueInput[]
    update?: WSJobApplicationUpdateWithWhereUniqueWithoutWSJobInput | WSJobApplicationUpdateWithWhereUniqueWithoutWSJobInput[]
    updateMany?: WSJobApplicationUpdateManyWithWhereWithoutWSJobInput | WSJobApplicationUpdateManyWithWhereWithoutWSJobInput[]
    deleteMany?: WSJobApplicationScalarWhereInput | WSJobApplicationScalarWhereInput[]
  }

  export type WSJobCreateNestedOneWithoutWSJobApplicationInput = {
    create?: XOR<WSJobCreateWithoutWSJobApplicationInput, WSJobUncheckedCreateWithoutWSJobApplicationInput>
    connectOrCreate?: WSJobCreateOrConnectWithoutWSJobApplicationInput
    connect?: WSJobWhereUniqueInput
  }

  export type WsUserCreateNestedOneWithoutWSJobApplicationInput = {
    create?: XOR<WsUserCreateWithoutWSJobApplicationInput, WsUserUncheckedCreateWithoutWSJobApplicationInput>
    connectOrCreate?: WsUserCreateOrConnectWithoutWSJobApplicationInput
    connect?: WsUserWhereUniqueInput
  }

  export type WSJobApplicationEducationCreateNestedManyWithoutWSJobApplicationInput = {
    create?: XOR<WSJobApplicationEducationCreateWithoutWSJobApplicationInput, WSJobApplicationEducationUncheckedCreateWithoutWSJobApplicationInput> | WSJobApplicationEducationCreateWithoutWSJobApplicationInput[] | WSJobApplicationEducationUncheckedCreateWithoutWSJobApplicationInput[]
    connectOrCreate?: WSJobApplicationEducationCreateOrConnectWithoutWSJobApplicationInput | WSJobApplicationEducationCreateOrConnectWithoutWSJobApplicationInput[]
    createMany?: WSJobApplicationEducationCreateManyWSJobApplicationInputEnvelope
    connect?: WSJobApplicationEducationWhereUniqueInput | WSJobApplicationEducationWhereUniqueInput[]
  }

  export type WSJobApplicationFeedbackCreateNestedManyWithoutWSJobApplicationInput = {
    create?: XOR<WSJobApplicationFeedbackCreateWithoutWSJobApplicationInput, WSJobApplicationFeedbackUncheckedCreateWithoutWSJobApplicationInput> | WSJobApplicationFeedbackCreateWithoutWSJobApplicationInput[] | WSJobApplicationFeedbackUncheckedCreateWithoutWSJobApplicationInput[]
    connectOrCreate?: WSJobApplicationFeedbackCreateOrConnectWithoutWSJobApplicationInput | WSJobApplicationFeedbackCreateOrConnectWithoutWSJobApplicationInput[]
    createMany?: WSJobApplicationFeedbackCreateManyWSJobApplicationInputEnvelope
    connect?: WSJobApplicationFeedbackWhereUniqueInput | WSJobApplicationFeedbackWhereUniqueInput[]
  }

  export type WSJobApplicationPreviousEmploymentCreateNestedManyWithoutWSJobApplicationInput = {
    create?: XOR<WSJobApplicationPreviousEmploymentCreateWithoutWSJobApplicationInput, WSJobApplicationPreviousEmploymentUncheckedCreateWithoutWSJobApplicationInput> | WSJobApplicationPreviousEmploymentCreateWithoutWSJobApplicationInput[] | WSJobApplicationPreviousEmploymentUncheckedCreateWithoutWSJobApplicationInput[]
    connectOrCreate?: WSJobApplicationPreviousEmploymentCreateOrConnectWithoutWSJobApplicationInput | WSJobApplicationPreviousEmploymentCreateOrConnectWithoutWSJobApplicationInput[]
    createMany?: WSJobApplicationPreviousEmploymentCreateManyWSJobApplicationInputEnvelope
    connect?: WSJobApplicationPreviousEmploymentWhereUniqueInput | WSJobApplicationPreviousEmploymentWhereUniqueInput[]
  }

  export type WSJobApplicationReferenceCreateNestedManyWithoutWSJobApplicationInput = {
    create?: XOR<WSJobApplicationReferenceCreateWithoutWSJobApplicationInput, WSJobApplicationReferenceUncheckedCreateWithoutWSJobApplicationInput> | WSJobApplicationReferenceCreateWithoutWSJobApplicationInput[] | WSJobApplicationReferenceUncheckedCreateWithoutWSJobApplicationInput[]
    connectOrCreate?: WSJobApplicationReferenceCreateOrConnectWithoutWSJobApplicationInput | WSJobApplicationReferenceCreateOrConnectWithoutWSJobApplicationInput[]
    createMany?: WSJobApplicationReferenceCreateManyWSJobApplicationInputEnvelope
    connect?: WSJobApplicationReferenceWhereUniqueInput | WSJobApplicationReferenceWhereUniqueInput[]
  }

  export type WSJobApplicationEducationUncheckedCreateNestedManyWithoutWSJobApplicationInput = {
    create?: XOR<WSJobApplicationEducationCreateWithoutWSJobApplicationInput, WSJobApplicationEducationUncheckedCreateWithoutWSJobApplicationInput> | WSJobApplicationEducationCreateWithoutWSJobApplicationInput[] | WSJobApplicationEducationUncheckedCreateWithoutWSJobApplicationInput[]
    connectOrCreate?: WSJobApplicationEducationCreateOrConnectWithoutWSJobApplicationInput | WSJobApplicationEducationCreateOrConnectWithoutWSJobApplicationInput[]
    createMany?: WSJobApplicationEducationCreateManyWSJobApplicationInputEnvelope
    connect?: WSJobApplicationEducationWhereUniqueInput | WSJobApplicationEducationWhereUniqueInput[]
  }

  export type WSJobApplicationFeedbackUncheckedCreateNestedManyWithoutWSJobApplicationInput = {
    create?: XOR<WSJobApplicationFeedbackCreateWithoutWSJobApplicationInput, WSJobApplicationFeedbackUncheckedCreateWithoutWSJobApplicationInput> | WSJobApplicationFeedbackCreateWithoutWSJobApplicationInput[] | WSJobApplicationFeedbackUncheckedCreateWithoutWSJobApplicationInput[]
    connectOrCreate?: WSJobApplicationFeedbackCreateOrConnectWithoutWSJobApplicationInput | WSJobApplicationFeedbackCreateOrConnectWithoutWSJobApplicationInput[]
    createMany?: WSJobApplicationFeedbackCreateManyWSJobApplicationInputEnvelope
    connect?: WSJobApplicationFeedbackWhereUniqueInput | WSJobApplicationFeedbackWhereUniqueInput[]
  }

  export type WSJobApplicationPreviousEmploymentUncheckedCreateNestedManyWithoutWSJobApplicationInput = {
    create?: XOR<WSJobApplicationPreviousEmploymentCreateWithoutWSJobApplicationInput, WSJobApplicationPreviousEmploymentUncheckedCreateWithoutWSJobApplicationInput> | WSJobApplicationPreviousEmploymentCreateWithoutWSJobApplicationInput[] | WSJobApplicationPreviousEmploymentUncheckedCreateWithoutWSJobApplicationInput[]
    connectOrCreate?: WSJobApplicationPreviousEmploymentCreateOrConnectWithoutWSJobApplicationInput | WSJobApplicationPreviousEmploymentCreateOrConnectWithoutWSJobApplicationInput[]
    createMany?: WSJobApplicationPreviousEmploymentCreateManyWSJobApplicationInputEnvelope
    connect?: WSJobApplicationPreviousEmploymentWhereUniqueInput | WSJobApplicationPreviousEmploymentWhereUniqueInput[]
  }

  export type WSJobApplicationReferenceUncheckedCreateNestedManyWithoutWSJobApplicationInput = {
    create?: XOR<WSJobApplicationReferenceCreateWithoutWSJobApplicationInput, WSJobApplicationReferenceUncheckedCreateWithoutWSJobApplicationInput> | WSJobApplicationReferenceCreateWithoutWSJobApplicationInput[] | WSJobApplicationReferenceUncheckedCreateWithoutWSJobApplicationInput[]
    connectOrCreate?: WSJobApplicationReferenceCreateOrConnectWithoutWSJobApplicationInput | WSJobApplicationReferenceCreateOrConnectWithoutWSJobApplicationInput[]
    createMany?: WSJobApplicationReferenceCreateManyWSJobApplicationInputEnvelope
    connect?: WSJobApplicationReferenceWhereUniqueInput | WSJobApplicationReferenceWhereUniqueInput[]
  }

  export type WSJobUpdateOneRequiredWithoutWSJobApplicationNestedInput = {
    create?: XOR<WSJobCreateWithoutWSJobApplicationInput, WSJobUncheckedCreateWithoutWSJobApplicationInput>
    connectOrCreate?: WSJobCreateOrConnectWithoutWSJobApplicationInput
    upsert?: WSJobUpsertWithoutWSJobApplicationInput
    connect?: WSJobWhereUniqueInput
    update?: XOR<XOR<WSJobUpdateToOneWithWhereWithoutWSJobApplicationInput, WSJobUpdateWithoutWSJobApplicationInput>, WSJobUncheckedUpdateWithoutWSJobApplicationInput>
  }

  export type WsUserUpdateOneRequiredWithoutWSJobApplicationNestedInput = {
    create?: XOR<WsUserCreateWithoutWSJobApplicationInput, WsUserUncheckedCreateWithoutWSJobApplicationInput>
    connectOrCreate?: WsUserCreateOrConnectWithoutWSJobApplicationInput
    upsert?: WsUserUpsertWithoutWSJobApplicationInput
    connect?: WsUserWhereUniqueInput
    update?: XOR<XOR<WsUserUpdateToOneWithWhereWithoutWSJobApplicationInput, WsUserUpdateWithoutWSJobApplicationInput>, WsUserUncheckedUpdateWithoutWSJobApplicationInput>
  }

  export type WSJobApplicationEducationUpdateManyWithoutWSJobApplicationNestedInput = {
    create?: XOR<WSJobApplicationEducationCreateWithoutWSJobApplicationInput, WSJobApplicationEducationUncheckedCreateWithoutWSJobApplicationInput> | WSJobApplicationEducationCreateWithoutWSJobApplicationInput[] | WSJobApplicationEducationUncheckedCreateWithoutWSJobApplicationInput[]
    connectOrCreate?: WSJobApplicationEducationCreateOrConnectWithoutWSJobApplicationInput | WSJobApplicationEducationCreateOrConnectWithoutWSJobApplicationInput[]
    upsert?: WSJobApplicationEducationUpsertWithWhereUniqueWithoutWSJobApplicationInput | WSJobApplicationEducationUpsertWithWhereUniqueWithoutWSJobApplicationInput[]
    createMany?: WSJobApplicationEducationCreateManyWSJobApplicationInputEnvelope
    set?: WSJobApplicationEducationWhereUniqueInput | WSJobApplicationEducationWhereUniqueInput[]
    disconnect?: WSJobApplicationEducationWhereUniqueInput | WSJobApplicationEducationWhereUniqueInput[]
    delete?: WSJobApplicationEducationWhereUniqueInput | WSJobApplicationEducationWhereUniqueInput[]
    connect?: WSJobApplicationEducationWhereUniqueInput | WSJobApplicationEducationWhereUniqueInput[]
    update?: WSJobApplicationEducationUpdateWithWhereUniqueWithoutWSJobApplicationInput | WSJobApplicationEducationUpdateWithWhereUniqueWithoutWSJobApplicationInput[]
    updateMany?: WSJobApplicationEducationUpdateManyWithWhereWithoutWSJobApplicationInput | WSJobApplicationEducationUpdateManyWithWhereWithoutWSJobApplicationInput[]
    deleteMany?: WSJobApplicationEducationScalarWhereInput | WSJobApplicationEducationScalarWhereInput[]
  }

  export type WSJobApplicationFeedbackUpdateManyWithoutWSJobApplicationNestedInput = {
    create?: XOR<WSJobApplicationFeedbackCreateWithoutWSJobApplicationInput, WSJobApplicationFeedbackUncheckedCreateWithoutWSJobApplicationInput> | WSJobApplicationFeedbackCreateWithoutWSJobApplicationInput[] | WSJobApplicationFeedbackUncheckedCreateWithoutWSJobApplicationInput[]
    connectOrCreate?: WSJobApplicationFeedbackCreateOrConnectWithoutWSJobApplicationInput | WSJobApplicationFeedbackCreateOrConnectWithoutWSJobApplicationInput[]
    upsert?: WSJobApplicationFeedbackUpsertWithWhereUniqueWithoutWSJobApplicationInput | WSJobApplicationFeedbackUpsertWithWhereUniqueWithoutWSJobApplicationInput[]
    createMany?: WSJobApplicationFeedbackCreateManyWSJobApplicationInputEnvelope
    set?: WSJobApplicationFeedbackWhereUniqueInput | WSJobApplicationFeedbackWhereUniqueInput[]
    disconnect?: WSJobApplicationFeedbackWhereUniqueInput | WSJobApplicationFeedbackWhereUniqueInput[]
    delete?: WSJobApplicationFeedbackWhereUniqueInput | WSJobApplicationFeedbackWhereUniqueInput[]
    connect?: WSJobApplicationFeedbackWhereUniqueInput | WSJobApplicationFeedbackWhereUniqueInput[]
    update?: WSJobApplicationFeedbackUpdateWithWhereUniqueWithoutWSJobApplicationInput | WSJobApplicationFeedbackUpdateWithWhereUniqueWithoutWSJobApplicationInput[]
    updateMany?: WSJobApplicationFeedbackUpdateManyWithWhereWithoutWSJobApplicationInput | WSJobApplicationFeedbackUpdateManyWithWhereWithoutWSJobApplicationInput[]
    deleteMany?: WSJobApplicationFeedbackScalarWhereInput | WSJobApplicationFeedbackScalarWhereInput[]
  }

  export type WSJobApplicationPreviousEmploymentUpdateManyWithoutWSJobApplicationNestedInput = {
    create?: XOR<WSJobApplicationPreviousEmploymentCreateWithoutWSJobApplicationInput, WSJobApplicationPreviousEmploymentUncheckedCreateWithoutWSJobApplicationInput> | WSJobApplicationPreviousEmploymentCreateWithoutWSJobApplicationInput[] | WSJobApplicationPreviousEmploymentUncheckedCreateWithoutWSJobApplicationInput[]
    connectOrCreate?: WSJobApplicationPreviousEmploymentCreateOrConnectWithoutWSJobApplicationInput | WSJobApplicationPreviousEmploymentCreateOrConnectWithoutWSJobApplicationInput[]
    upsert?: WSJobApplicationPreviousEmploymentUpsertWithWhereUniqueWithoutWSJobApplicationInput | WSJobApplicationPreviousEmploymentUpsertWithWhereUniqueWithoutWSJobApplicationInput[]
    createMany?: WSJobApplicationPreviousEmploymentCreateManyWSJobApplicationInputEnvelope
    set?: WSJobApplicationPreviousEmploymentWhereUniqueInput | WSJobApplicationPreviousEmploymentWhereUniqueInput[]
    disconnect?: WSJobApplicationPreviousEmploymentWhereUniqueInput | WSJobApplicationPreviousEmploymentWhereUniqueInput[]
    delete?: WSJobApplicationPreviousEmploymentWhereUniqueInput | WSJobApplicationPreviousEmploymentWhereUniqueInput[]
    connect?: WSJobApplicationPreviousEmploymentWhereUniqueInput | WSJobApplicationPreviousEmploymentWhereUniqueInput[]
    update?: WSJobApplicationPreviousEmploymentUpdateWithWhereUniqueWithoutWSJobApplicationInput | WSJobApplicationPreviousEmploymentUpdateWithWhereUniqueWithoutWSJobApplicationInput[]
    updateMany?: WSJobApplicationPreviousEmploymentUpdateManyWithWhereWithoutWSJobApplicationInput | WSJobApplicationPreviousEmploymentUpdateManyWithWhereWithoutWSJobApplicationInput[]
    deleteMany?: WSJobApplicationPreviousEmploymentScalarWhereInput | WSJobApplicationPreviousEmploymentScalarWhereInput[]
  }

  export type WSJobApplicationReferenceUpdateManyWithoutWSJobApplicationNestedInput = {
    create?: XOR<WSJobApplicationReferenceCreateWithoutWSJobApplicationInput, WSJobApplicationReferenceUncheckedCreateWithoutWSJobApplicationInput> | WSJobApplicationReferenceCreateWithoutWSJobApplicationInput[] | WSJobApplicationReferenceUncheckedCreateWithoutWSJobApplicationInput[]
    connectOrCreate?: WSJobApplicationReferenceCreateOrConnectWithoutWSJobApplicationInput | WSJobApplicationReferenceCreateOrConnectWithoutWSJobApplicationInput[]
    upsert?: WSJobApplicationReferenceUpsertWithWhereUniqueWithoutWSJobApplicationInput | WSJobApplicationReferenceUpsertWithWhereUniqueWithoutWSJobApplicationInput[]
    createMany?: WSJobApplicationReferenceCreateManyWSJobApplicationInputEnvelope
    set?: WSJobApplicationReferenceWhereUniqueInput | WSJobApplicationReferenceWhereUniqueInput[]
    disconnect?: WSJobApplicationReferenceWhereUniqueInput | WSJobApplicationReferenceWhereUniqueInput[]
    delete?: WSJobApplicationReferenceWhereUniqueInput | WSJobApplicationReferenceWhereUniqueInput[]
    connect?: WSJobApplicationReferenceWhereUniqueInput | WSJobApplicationReferenceWhereUniqueInput[]
    update?: WSJobApplicationReferenceUpdateWithWhereUniqueWithoutWSJobApplicationInput | WSJobApplicationReferenceUpdateWithWhereUniqueWithoutWSJobApplicationInput[]
    updateMany?: WSJobApplicationReferenceUpdateManyWithWhereWithoutWSJobApplicationInput | WSJobApplicationReferenceUpdateManyWithWhereWithoutWSJobApplicationInput[]
    deleteMany?: WSJobApplicationReferenceScalarWhereInput | WSJobApplicationReferenceScalarWhereInput[]
  }

  export type WSJobApplicationEducationUncheckedUpdateManyWithoutWSJobApplicationNestedInput = {
    create?: XOR<WSJobApplicationEducationCreateWithoutWSJobApplicationInput, WSJobApplicationEducationUncheckedCreateWithoutWSJobApplicationInput> | WSJobApplicationEducationCreateWithoutWSJobApplicationInput[] | WSJobApplicationEducationUncheckedCreateWithoutWSJobApplicationInput[]
    connectOrCreate?: WSJobApplicationEducationCreateOrConnectWithoutWSJobApplicationInput | WSJobApplicationEducationCreateOrConnectWithoutWSJobApplicationInput[]
    upsert?: WSJobApplicationEducationUpsertWithWhereUniqueWithoutWSJobApplicationInput | WSJobApplicationEducationUpsertWithWhereUniqueWithoutWSJobApplicationInput[]
    createMany?: WSJobApplicationEducationCreateManyWSJobApplicationInputEnvelope
    set?: WSJobApplicationEducationWhereUniqueInput | WSJobApplicationEducationWhereUniqueInput[]
    disconnect?: WSJobApplicationEducationWhereUniqueInput | WSJobApplicationEducationWhereUniqueInput[]
    delete?: WSJobApplicationEducationWhereUniqueInput | WSJobApplicationEducationWhereUniqueInput[]
    connect?: WSJobApplicationEducationWhereUniqueInput | WSJobApplicationEducationWhereUniqueInput[]
    update?: WSJobApplicationEducationUpdateWithWhereUniqueWithoutWSJobApplicationInput | WSJobApplicationEducationUpdateWithWhereUniqueWithoutWSJobApplicationInput[]
    updateMany?: WSJobApplicationEducationUpdateManyWithWhereWithoutWSJobApplicationInput | WSJobApplicationEducationUpdateManyWithWhereWithoutWSJobApplicationInput[]
    deleteMany?: WSJobApplicationEducationScalarWhereInput | WSJobApplicationEducationScalarWhereInput[]
  }

  export type WSJobApplicationFeedbackUncheckedUpdateManyWithoutWSJobApplicationNestedInput = {
    create?: XOR<WSJobApplicationFeedbackCreateWithoutWSJobApplicationInput, WSJobApplicationFeedbackUncheckedCreateWithoutWSJobApplicationInput> | WSJobApplicationFeedbackCreateWithoutWSJobApplicationInput[] | WSJobApplicationFeedbackUncheckedCreateWithoutWSJobApplicationInput[]
    connectOrCreate?: WSJobApplicationFeedbackCreateOrConnectWithoutWSJobApplicationInput | WSJobApplicationFeedbackCreateOrConnectWithoutWSJobApplicationInput[]
    upsert?: WSJobApplicationFeedbackUpsertWithWhereUniqueWithoutWSJobApplicationInput | WSJobApplicationFeedbackUpsertWithWhereUniqueWithoutWSJobApplicationInput[]
    createMany?: WSJobApplicationFeedbackCreateManyWSJobApplicationInputEnvelope
    set?: WSJobApplicationFeedbackWhereUniqueInput | WSJobApplicationFeedbackWhereUniqueInput[]
    disconnect?: WSJobApplicationFeedbackWhereUniqueInput | WSJobApplicationFeedbackWhereUniqueInput[]
    delete?: WSJobApplicationFeedbackWhereUniqueInput | WSJobApplicationFeedbackWhereUniqueInput[]
    connect?: WSJobApplicationFeedbackWhereUniqueInput | WSJobApplicationFeedbackWhereUniqueInput[]
    update?: WSJobApplicationFeedbackUpdateWithWhereUniqueWithoutWSJobApplicationInput | WSJobApplicationFeedbackUpdateWithWhereUniqueWithoutWSJobApplicationInput[]
    updateMany?: WSJobApplicationFeedbackUpdateManyWithWhereWithoutWSJobApplicationInput | WSJobApplicationFeedbackUpdateManyWithWhereWithoutWSJobApplicationInput[]
    deleteMany?: WSJobApplicationFeedbackScalarWhereInput | WSJobApplicationFeedbackScalarWhereInput[]
  }

  export type WSJobApplicationPreviousEmploymentUncheckedUpdateManyWithoutWSJobApplicationNestedInput = {
    create?: XOR<WSJobApplicationPreviousEmploymentCreateWithoutWSJobApplicationInput, WSJobApplicationPreviousEmploymentUncheckedCreateWithoutWSJobApplicationInput> | WSJobApplicationPreviousEmploymentCreateWithoutWSJobApplicationInput[] | WSJobApplicationPreviousEmploymentUncheckedCreateWithoutWSJobApplicationInput[]
    connectOrCreate?: WSJobApplicationPreviousEmploymentCreateOrConnectWithoutWSJobApplicationInput | WSJobApplicationPreviousEmploymentCreateOrConnectWithoutWSJobApplicationInput[]
    upsert?: WSJobApplicationPreviousEmploymentUpsertWithWhereUniqueWithoutWSJobApplicationInput | WSJobApplicationPreviousEmploymentUpsertWithWhereUniqueWithoutWSJobApplicationInput[]
    createMany?: WSJobApplicationPreviousEmploymentCreateManyWSJobApplicationInputEnvelope
    set?: WSJobApplicationPreviousEmploymentWhereUniqueInput | WSJobApplicationPreviousEmploymentWhereUniqueInput[]
    disconnect?: WSJobApplicationPreviousEmploymentWhereUniqueInput | WSJobApplicationPreviousEmploymentWhereUniqueInput[]
    delete?: WSJobApplicationPreviousEmploymentWhereUniqueInput | WSJobApplicationPreviousEmploymentWhereUniqueInput[]
    connect?: WSJobApplicationPreviousEmploymentWhereUniqueInput | WSJobApplicationPreviousEmploymentWhereUniqueInput[]
    update?: WSJobApplicationPreviousEmploymentUpdateWithWhereUniqueWithoutWSJobApplicationInput | WSJobApplicationPreviousEmploymentUpdateWithWhereUniqueWithoutWSJobApplicationInput[]
    updateMany?: WSJobApplicationPreviousEmploymentUpdateManyWithWhereWithoutWSJobApplicationInput | WSJobApplicationPreviousEmploymentUpdateManyWithWhereWithoutWSJobApplicationInput[]
    deleteMany?: WSJobApplicationPreviousEmploymentScalarWhereInput | WSJobApplicationPreviousEmploymentScalarWhereInput[]
  }

  export type WSJobApplicationReferenceUncheckedUpdateManyWithoutWSJobApplicationNestedInput = {
    create?: XOR<WSJobApplicationReferenceCreateWithoutWSJobApplicationInput, WSJobApplicationReferenceUncheckedCreateWithoutWSJobApplicationInput> | WSJobApplicationReferenceCreateWithoutWSJobApplicationInput[] | WSJobApplicationReferenceUncheckedCreateWithoutWSJobApplicationInput[]
    connectOrCreate?: WSJobApplicationReferenceCreateOrConnectWithoutWSJobApplicationInput | WSJobApplicationReferenceCreateOrConnectWithoutWSJobApplicationInput[]
    upsert?: WSJobApplicationReferenceUpsertWithWhereUniqueWithoutWSJobApplicationInput | WSJobApplicationReferenceUpsertWithWhereUniqueWithoutWSJobApplicationInput[]
    createMany?: WSJobApplicationReferenceCreateManyWSJobApplicationInputEnvelope
    set?: WSJobApplicationReferenceWhereUniqueInput | WSJobApplicationReferenceWhereUniqueInput[]
    disconnect?: WSJobApplicationReferenceWhereUniqueInput | WSJobApplicationReferenceWhereUniqueInput[]
    delete?: WSJobApplicationReferenceWhereUniqueInput | WSJobApplicationReferenceWhereUniqueInput[]
    connect?: WSJobApplicationReferenceWhereUniqueInput | WSJobApplicationReferenceWhereUniqueInput[]
    update?: WSJobApplicationReferenceUpdateWithWhereUniqueWithoutWSJobApplicationInput | WSJobApplicationReferenceUpdateWithWhereUniqueWithoutWSJobApplicationInput[]
    updateMany?: WSJobApplicationReferenceUpdateManyWithWhereWithoutWSJobApplicationInput | WSJobApplicationReferenceUpdateManyWithWhereWithoutWSJobApplicationInput[]
    deleteMany?: WSJobApplicationReferenceScalarWhereInput | WSJobApplicationReferenceScalarWhereInput[]
  }

  export type WSJobApplicationCreateNestedOneWithoutWSJobApplicationEducationInput = {
    create?: XOR<WSJobApplicationCreateWithoutWSJobApplicationEducationInput, WSJobApplicationUncheckedCreateWithoutWSJobApplicationEducationInput>
    connectOrCreate?: WSJobApplicationCreateOrConnectWithoutWSJobApplicationEducationInput
    connect?: WSJobApplicationWhereUniqueInput
  }

  export type WSJobApplicationUpdateOneWithoutWSJobApplicationEducationNestedInput = {
    create?: XOR<WSJobApplicationCreateWithoutWSJobApplicationEducationInput, WSJobApplicationUncheckedCreateWithoutWSJobApplicationEducationInput>
    connectOrCreate?: WSJobApplicationCreateOrConnectWithoutWSJobApplicationEducationInput
    upsert?: WSJobApplicationUpsertWithoutWSJobApplicationEducationInput
    disconnect?: WSJobApplicationWhereInput | boolean
    delete?: WSJobApplicationWhereInput | boolean
    connect?: WSJobApplicationWhereUniqueInput
    update?: XOR<XOR<WSJobApplicationUpdateToOneWithWhereWithoutWSJobApplicationEducationInput, WSJobApplicationUpdateWithoutWSJobApplicationEducationInput>, WSJobApplicationUncheckedUpdateWithoutWSJobApplicationEducationInput>
  }

  export type WSJobApplicationCreateNestedOneWithoutWSJobApplicationFeedbackInput = {
    create?: XOR<WSJobApplicationCreateWithoutWSJobApplicationFeedbackInput, WSJobApplicationUncheckedCreateWithoutWSJobApplicationFeedbackInput>
    connectOrCreate?: WSJobApplicationCreateOrConnectWithoutWSJobApplicationFeedbackInput
    connect?: WSJobApplicationWhereUniqueInput
  }

  export type WsJobApplicationReplyCreateNestedManyWithoutWSJobApplicationFeedbackInput = {
    create?: XOR<WsJobApplicationReplyCreateWithoutWSJobApplicationFeedbackInput, WsJobApplicationReplyUncheckedCreateWithoutWSJobApplicationFeedbackInput> | WsJobApplicationReplyCreateWithoutWSJobApplicationFeedbackInput[] | WsJobApplicationReplyUncheckedCreateWithoutWSJobApplicationFeedbackInput[]
    connectOrCreate?: WsJobApplicationReplyCreateOrConnectWithoutWSJobApplicationFeedbackInput | WsJobApplicationReplyCreateOrConnectWithoutWSJobApplicationFeedbackInput[]
    createMany?: WsJobApplicationReplyCreateManyWSJobApplicationFeedbackInputEnvelope
    connect?: WsJobApplicationReplyWhereUniqueInput | WsJobApplicationReplyWhereUniqueInput[]
  }

  export type WsJobApplicationReplyUncheckedCreateNestedManyWithoutWSJobApplicationFeedbackInput = {
    create?: XOR<WsJobApplicationReplyCreateWithoutWSJobApplicationFeedbackInput, WsJobApplicationReplyUncheckedCreateWithoutWSJobApplicationFeedbackInput> | WsJobApplicationReplyCreateWithoutWSJobApplicationFeedbackInput[] | WsJobApplicationReplyUncheckedCreateWithoutWSJobApplicationFeedbackInput[]
    connectOrCreate?: WsJobApplicationReplyCreateOrConnectWithoutWSJobApplicationFeedbackInput | WsJobApplicationReplyCreateOrConnectWithoutWSJobApplicationFeedbackInput[]
    createMany?: WsJobApplicationReplyCreateManyWSJobApplicationFeedbackInputEnvelope
    connect?: WsJobApplicationReplyWhereUniqueInput | WsJobApplicationReplyWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type WSJobApplicationUpdateOneRequiredWithoutWSJobApplicationFeedbackNestedInput = {
    create?: XOR<WSJobApplicationCreateWithoutWSJobApplicationFeedbackInput, WSJobApplicationUncheckedCreateWithoutWSJobApplicationFeedbackInput>
    connectOrCreate?: WSJobApplicationCreateOrConnectWithoutWSJobApplicationFeedbackInput
    upsert?: WSJobApplicationUpsertWithoutWSJobApplicationFeedbackInput
    connect?: WSJobApplicationWhereUniqueInput
    update?: XOR<XOR<WSJobApplicationUpdateToOneWithWhereWithoutWSJobApplicationFeedbackInput, WSJobApplicationUpdateWithoutWSJobApplicationFeedbackInput>, WSJobApplicationUncheckedUpdateWithoutWSJobApplicationFeedbackInput>
  }

  export type WsJobApplicationReplyUpdateManyWithoutWSJobApplicationFeedbackNestedInput = {
    create?: XOR<WsJobApplicationReplyCreateWithoutWSJobApplicationFeedbackInput, WsJobApplicationReplyUncheckedCreateWithoutWSJobApplicationFeedbackInput> | WsJobApplicationReplyCreateWithoutWSJobApplicationFeedbackInput[] | WsJobApplicationReplyUncheckedCreateWithoutWSJobApplicationFeedbackInput[]
    connectOrCreate?: WsJobApplicationReplyCreateOrConnectWithoutWSJobApplicationFeedbackInput | WsJobApplicationReplyCreateOrConnectWithoutWSJobApplicationFeedbackInput[]
    upsert?: WsJobApplicationReplyUpsertWithWhereUniqueWithoutWSJobApplicationFeedbackInput | WsJobApplicationReplyUpsertWithWhereUniqueWithoutWSJobApplicationFeedbackInput[]
    createMany?: WsJobApplicationReplyCreateManyWSJobApplicationFeedbackInputEnvelope
    set?: WsJobApplicationReplyWhereUniqueInput | WsJobApplicationReplyWhereUniqueInput[]
    disconnect?: WsJobApplicationReplyWhereUniqueInput | WsJobApplicationReplyWhereUniqueInput[]
    delete?: WsJobApplicationReplyWhereUniqueInput | WsJobApplicationReplyWhereUniqueInput[]
    connect?: WsJobApplicationReplyWhereUniqueInput | WsJobApplicationReplyWhereUniqueInput[]
    update?: WsJobApplicationReplyUpdateWithWhereUniqueWithoutWSJobApplicationFeedbackInput | WsJobApplicationReplyUpdateWithWhereUniqueWithoutWSJobApplicationFeedbackInput[]
    updateMany?: WsJobApplicationReplyUpdateManyWithWhereWithoutWSJobApplicationFeedbackInput | WsJobApplicationReplyUpdateManyWithWhereWithoutWSJobApplicationFeedbackInput[]
    deleteMany?: WsJobApplicationReplyScalarWhereInput | WsJobApplicationReplyScalarWhereInput[]
  }

  export type WsJobApplicationReplyUncheckedUpdateManyWithoutWSJobApplicationFeedbackNestedInput = {
    create?: XOR<WsJobApplicationReplyCreateWithoutWSJobApplicationFeedbackInput, WsJobApplicationReplyUncheckedCreateWithoutWSJobApplicationFeedbackInput> | WsJobApplicationReplyCreateWithoutWSJobApplicationFeedbackInput[] | WsJobApplicationReplyUncheckedCreateWithoutWSJobApplicationFeedbackInput[]
    connectOrCreate?: WsJobApplicationReplyCreateOrConnectWithoutWSJobApplicationFeedbackInput | WsJobApplicationReplyCreateOrConnectWithoutWSJobApplicationFeedbackInput[]
    upsert?: WsJobApplicationReplyUpsertWithWhereUniqueWithoutWSJobApplicationFeedbackInput | WsJobApplicationReplyUpsertWithWhereUniqueWithoutWSJobApplicationFeedbackInput[]
    createMany?: WsJobApplicationReplyCreateManyWSJobApplicationFeedbackInputEnvelope
    set?: WsJobApplicationReplyWhereUniqueInput | WsJobApplicationReplyWhereUniqueInput[]
    disconnect?: WsJobApplicationReplyWhereUniqueInput | WsJobApplicationReplyWhereUniqueInput[]
    delete?: WsJobApplicationReplyWhereUniqueInput | WsJobApplicationReplyWhereUniqueInput[]
    connect?: WsJobApplicationReplyWhereUniqueInput | WsJobApplicationReplyWhereUniqueInput[]
    update?: WsJobApplicationReplyUpdateWithWhereUniqueWithoutWSJobApplicationFeedbackInput | WsJobApplicationReplyUpdateWithWhereUniqueWithoutWSJobApplicationFeedbackInput[]
    updateMany?: WsJobApplicationReplyUpdateManyWithWhereWithoutWSJobApplicationFeedbackInput | WsJobApplicationReplyUpdateManyWithWhereWithoutWSJobApplicationFeedbackInput[]
    deleteMany?: WsJobApplicationReplyScalarWhereInput | WsJobApplicationReplyScalarWhereInput[]
  }

  export type WSJobApplicationCreateNestedOneWithoutWSJobApplicationPreviousEmploymentInput = {
    create?: XOR<WSJobApplicationCreateWithoutWSJobApplicationPreviousEmploymentInput, WSJobApplicationUncheckedCreateWithoutWSJobApplicationPreviousEmploymentInput>
    connectOrCreate?: WSJobApplicationCreateOrConnectWithoutWSJobApplicationPreviousEmploymentInput
    connect?: WSJobApplicationWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type WSJobApplicationUpdateOneWithoutWSJobApplicationPreviousEmploymentNestedInput = {
    create?: XOR<WSJobApplicationCreateWithoutWSJobApplicationPreviousEmploymentInput, WSJobApplicationUncheckedCreateWithoutWSJobApplicationPreviousEmploymentInput>
    connectOrCreate?: WSJobApplicationCreateOrConnectWithoutWSJobApplicationPreviousEmploymentInput
    upsert?: WSJobApplicationUpsertWithoutWSJobApplicationPreviousEmploymentInput
    disconnect?: WSJobApplicationWhereInput | boolean
    delete?: WSJobApplicationWhereInput | boolean
    connect?: WSJobApplicationWhereUniqueInput
    update?: XOR<XOR<WSJobApplicationUpdateToOneWithWhereWithoutWSJobApplicationPreviousEmploymentInput, WSJobApplicationUpdateWithoutWSJobApplicationPreviousEmploymentInput>, WSJobApplicationUncheckedUpdateWithoutWSJobApplicationPreviousEmploymentInput>
  }

  export type WSJobApplicationCreateNestedOneWithoutWSJobApplicationReferenceInput = {
    create?: XOR<WSJobApplicationCreateWithoutWSJobApplicationReferenceInput, WSJobApplicationUncheckedCreateWithoutWSJobApplicationReferenceInput>
    connectOrCreate?: WSJobApplicationCreateOrConnectWithoutWSJobApplicationReferenceInput
    connect?: WSJobApplicationWhereUniqueInput
  }

  export type WSJobApplicationUpdateOneWithoutWSJobApplicationReferenceNestedInput = {
    create?: XOR<WSJobApplicationCreateWithoutWSJobApplicationReferenceInput, WSJobApplicationUncheckedCreateWithoutWSJobApplicationReferenceInput>
    connectOrCreate?: WSJobApplicationCreateOrConnectWithoutWSJobApplicationReferenceInput
    upsert?: WSJobApplicationUpsertWithoutWSJobApplicationReferenceInput
    disconnect?: WSJobApplicationWhereInput | boolean
    delete?: WSJobApplicationWhereInput | boolean
    connect?: WSJobApplicationWhereUniqueInput
    update?: XOR<XOR<WSJobApplicationUpdateToOneWithWhereWithoutWSJobApplicationReferenceInput, WSJobApplicationUpdateWithoutWSJobApplicationReferenceInput>, WSJobApplicationUncheckedUpdateWithoutWSJobApplicationReferenceInput>
  }

  export type WSJobApplicationFeedbackCreateNestedOneWithoutWsJobApplicationReplyInput = {
    create?: XOR<WSJobApplicationFeedbackCreateWithoutWsJobApplicationReplyInput, WSJobApplicationFeedbackUncheckedCreateWithoutWsJobApplicationReplyInput>
    connectOrCreate?: WSJobApplicationFeedbackCreateOrConnectWithoutWsJobApplicationReplyInput
    connect?: WSJobApplicationFeedbackWhereUniqueInput
  }

  export type WSJobApplicationFeedbackUpdateOneRequiredWithoutWsJobApplicationReplyNestedInput = {
    create?: XOR<WSJobApplicationFeedbackCreateWithoutWsJobApplicationReplyInput, WSJobApplicationFeedbackUncheckedCreateWithoutWsJobApplicationReplyInput>
    connectOrCreate?: WSJobApplicationFeedbackCreateOrConnectWithoutWsJobApplicationReplyInput
    upsert?: WSJobApplicationFeedbackUpsertWithoutWsJobApplicationReplyInput
    connect?: WSJobApplicationFeedbackWhereUniqueInput
    update?: XOR<XOR<WSJobApplicationFeedbackUpdateToOneWithWhereWithoutWsJobApplicationReplyInput, WSJobApplicationFeedbackUpdateWithoutWsJobApplicationReplyInput>, WSJobApplicationFeedbackUncheckedUpdateWithoutWsJobApplicationReplyInput>
  }

  export type WsDepartmentsCreateNestedOneWithoutWsProductsInput = {
    create?: XOR<WsDepartmentsCreateWithoutWsProductsInput, WsDepartmentsUncheckedCreateWithoutWsProductsInput>
    connectOrCreate?: WsDepartmentsCreateOrConnectWithoutWsProductsInput
    connect?: WsDepartmentsWhereUniqueInput
  }

  export type WsDepartmentsUpdateOneRequiredWithoutWsProductsNestedInput = {
    create?: XOR<WsDepartmentsCreateWithoutWsProductsInput, WsDepartmentsUncheckedCreateWithoutWsProductsInput>
    connectOrCreate?: WsDepartmentsCreateOrConnectWithoutWsProductsInput
    upsert?: WsDepartmentsUpsertWithoutWsProductsInput
    connect?: WsDepartmentsWhereUniqueInput
    update?: XOR<XOR<WsDepartmentsUpdateToOneWithWhereWithoutWsProductsInput, WsDepartmentsUpdateWithoutWsProductsInput>, WsDepartmentsUncheckedUpdateWithoutWsProductsInput>
  }

  export type WSTaxExemptCreateNestedOneWithoutWSStateInput = {
    create?: XOR<WSTaxExemptCreateWithoutWSStateInput, WSTaxExemptUncheckedCreateWithoutWSStateInput>
    connectOrCreate?: WSTaxExemptCreateOrConnectWithoutWSStateInput
    connect?: WSTaxExemptWhereUniqueInput
  }

  export type WSTaxExemptUpdateOneWithoutWSStateNestedInput = {
    create?: XOR<WSTaxExemptCreateWithoutWSStateInput, WSTaxExemptUncheckedCreateWithoutWSStateInput>
    connectOrCreate?: WSTaxExemptCreateOrConnectWithoutWSStateInput
    upsert?: WSTaxExemptUpsertWithoutWSStateInput
    disconnect?: WSTaxExemptWhereInput | boolean
    delete?: WSTaxExemptWhereInput | boolean
    connect?: WSTaxExemptWhereUniqueInput
    update?: XOR<XOR<WSTaxExemptUpdateToOneWithWhereWithoutWSStateInput, WSTaxExemptUpdateWithoutWSStateInput>, WSTaxExemptUncheckedUpdateWithoutWSStateInput>
  }

  export type WSJobCreateNestedManyWithoutWsStoreInput = {
    create?: XOR<WSJobCreateWithoutWsStoreInput, WSJobUncheckedCreateWithoutWsStoreInput> | WSJobCreateWithoutWsStoreInput[] | WSJobUncheckedCreateWithoutWsStoreInput[]
    connectOrCreate?: WSJobCreateOrConnectWithoutWsStoreInput | WSJobCreateOrConnectWithoutWsStoreInput[]
    createMany?: WSJobCreateManyWsStoreInputEnvelope
    connect?: WSJobWhereUniqueInput | WSJobWhereUniqueInput[]
  }

  export type WSJobUncheckedCreateNestedManyWithoutWsStoreInput = {
    create?: XOR<WSJobCreateWithoutWsStoreInput, WSJobUncheckedCreateWithoutWsStoreInput> | WSJobCreateWithoutWsStoreInput[] | WSJobUncheckedCreateWithoutWsStoreInput[]
    connectOrCreate?: WSJobCreateOrConnectWithoutWsStoreInput | WSJobCreateOrConnectWithoutWsStoreInput[]
    createMany?: WSJobCreateManyWsStoreInputEnvelope
    connect?: WSJobWhereUniqueInput | WSJobWhereUniqueInput[]
  }

  export type WSJobUpdateManyWithoutWsStoreNestedInput = {
    create?: XOR<WSJobCreateWithoutWsStoreInput, WSJobUncheckedCreateWithoutWsStoreInput> | WSJobCreateWithoutWsStoreInput[] | WSJobUncheckedCreateWithoutWsStoreInput[]
    connectOrCreate?: WSJobCreateOrConnectWithoutWsStoreInput | WSJobCreateOrConnectWithoutWsStoreInput[]
    upsert?: WSJobUpsertWithWhereUniqueWithoutWsStoreInput | WSJobUpsertWithWhereUniqueWithoutWsStoreInput[]
    createMany?: WSJobCreateManyWsStoreInputEnvelope
    set?: WSJobWhereUniqueInput | WSJobWhereUniqueInput[]
    disconnect?: WSJobWhereUniqueInput | WSJobWhereUniqueInput[]
    delete?: WSJobWhereUniqueInput | WSJobWhereUniqueInput[]
    connect?: WSJobWhereUniqueInput | WSJobWhereUniqueInput[]
    update?: WSJobUpdateWithWhereUniqueWithoutWsStoreInput | WSJobUpdateWithWhereUniqueWithoutWsStoreInput[]
    updateMany?: WSJobUpdateManyWithWhereWithoutWsStoreInput | WSJobUpdateManyWithWhereWithoutWsStoreInput[]
    deleteMany?: WSJobScalarWhereInput | WSJobScalarWhereInput[]
  }

  export type WSJobUncheckedUpdateManyWithoutWsStoreNestedInput = {
    create?: XOR<WSJobCreateWithoutWsStoreInput, WSJobUncheckedCreateWithoutWsStoreInput> | WSJobCreateWithoutWsStoreInput[] | WSJobUncheckedCreateWithoutWsStoreInput[]
    connectOrCreate?: WSJobCreateOrConnectWithoutWsStoreInput | WSJobCreateOrConnectWithoutWsStoreInput[]
    upsert?: WSJobUpsertWithWhereUniqueWithoutWsStoreInput | WSJobUpsertWithWhereUniqueWithoutWsStoreInput[]
    createMany?: WSJobCreateManyWsStoreInputEnvelope
    set?: WSJobWhereUniqueInput | WSJobWhereUniqueInput[]
    disconnect?: WSJobWhereUniqueInput | WSJobWhereUniqueInput[]
    delete?: WSJobWhereUniqueInput | WSJobWhereUniqueInput[]
    connect?: WSJobWhereUniqueInput | WSJobWhereUniqueInput[]
    update?: WSJobUpdateWithWhereUniqueWithoutWsStoreInput | WSJobUpdateWithWhereUniqueWithoutWsStoreInput[]
    updateMany?: WSJobUpdateManyWithWhereWithoutWsStoreInput | WSJobUpdateManyWithWhereWithoutWsStoreInput[]
    deleteMany?: WSJobScalarWhereInput | WSJobScalarWhereInput[]
  }

  export type WSStateCreateNestedManyWithoutWSTaxExemptInput = {
    create?: XOR<WSStateCreateWithoutWSTaxExemptInput, WSStateUncheckedCreateWithoutWSTaxExemptInput> | WSStateCreateWithoutWSTaxExemptInput[] | WSStateUncheckedCreateWithoutWSTaxExemptInput[]
    connectOrCreate?: WSStateCreateOrConnectWithoutWSTaxExemptInput | WSStateCreateOrConnectWithoutWSTaxExemptInput[]
    createMany?: WSStateCreateManyWSTaxExemptInputEnvelope
    connect?: WSStateWhereUniqueInput | WSStateWhereUniqueInput[]
  }

  export type WSStateUncheckedCreateNestedManyWithoutWSTaxExemptInput = {
    create?: XOR<WSStateCreateWithoutWSTaxExemptInput, WSStateUncheckedCreateWithoutWSTaxExemptInput> | WSStateCreateWithoutWSTaxExemptInput[] | WSStateUncheckedCreateWithoutWSTaxExemptInput[]
    connectOrCreate?: WSStateCreateOrConnectWithoutWSTaxExemptInput | WSStateCreateOrConnectWithoutWSTaxExemptInput[]
    createMany?: WSStateCreateManyWSTaxExemptInputEnvelope
    connect?: WSStateWhereUniqueInput | WSStateWhereUniqueInput[]
  }

  export type WSStateUpdateManyWithoutWSTaxExemptNestedInput = {
    create?: XOR<WSStateCreateWithoutWSTaxExemptInput, WSStateUncheckedCreateWithoutWSTaxExemptInput> | WSStateCreateWithoutWSTaxExemptInput[] | WSStateUncheckedCreateWithoutWSTaxExemptInput[]
    connectOrCreate?: WSStateCreateOrConnectWithoutWSTaxExemptInput | WSStateCreateOrConnectWithoutWSTaxExemptInput[]
    upsert?: WSStateUpsertWithWhereUniqueWithoutWSTaxExemptInput | WSStateUpsertWithWhereUniqueWithoutWSTaxExemptInput[]
    createMany?: WSStateCreateManyWSTaxExemptInputEnvelope
    set?: WSStateWhereUniqueInput | WSStateWhereUniqueInput[]
    disconnect?: WSStateWhereUniqueInput | WSStateWhereUniqueInput[]
    delete?: WSStateWhereUniqueInput | WSStateWhereUniqueInput[]
    connect?: WSStateWhereUniqueInput | WSStateWhereUniqueInput[]
    update?: WSStateUpdateWithWhereUniqueWithoutWSTaxExemptInput | WSStateUpdateWithWhereUniqueWithoutWSTaxExemptInput[]
    updateMany?: WSStateUpdateManyWithWhereWithoutWSTaxExemptInput | WSStateUpdateManyWithWhereWithoutWSTaxExemptInput[]
    deleteMany?: WSStateScalarWhereInput | WSStateScalarWhereInput[]
  }

  export type WSStateUncheckedUpdateManyWithoutWSTaxExemptNestedInput = {
    create?: XOR<WSStateCreateWithoutWSTaxExemptInput, WSStateUncheckedCreateWithoutWSTaxExemptInput> | WSStateCreateWithoutWSTaxExemptInput[] | WSStateUncheckedCreateWithoutWSTaxExemptInput[]
    connectOrCreate?: WSStateCreateOrConnectWithoutWSTaxExemptInput | WSStateCreateOrConnectWithoutWSTaxExemptInput[]
    upsert?: WSStateUpsertWithWhereUniqueWithoutWSTaxExemptInput | WSStateUpsertWithWhereUniqueWithoutWSTaxExemptInput[]
    createMany?: WSStateCreateManyWSTaxExemptInputEnvelope
    set?: WSStateWhereUniqueInput | WSStateWhereUniqueInput[]
    disconnect?: WSStateWhereUniqueInput | WSStateWhereUniqueInput[]
    delete?: WSStateWhereUniqueInput | WSStateWhereUniqueInput[]
    connect?: WSStateWhereUniqueInput | WSStateWhereUniqueInput[]
    update?: WSStateUpdateWithWhereUniqueWithoutWSTaxExemptInput | WSStateUpdateWithWhereUniqueWithoutWSTaxExemptInput[]
    updateMany?: WSStateUpdateManyWithWhereWithoutWSTaxExemptInput | WSStateUpdateManyWithWhereWithoutWSTaxExemptInput[]
    deleteMany?: WSStateScalarWhereInput | WSStateScalarWhereInput[]
  }

  export type WSJobApplicationCreateNestedManyWithoutWsUserInput = {
    create?: XOR<WSJobApplicationCreateWithoutWsUserInput, WSJobApplicationUncheckedCreateWithoutWsUserInput> | WSJobApplicationCreateWithoutWsUserInput[] | WSJobApplicationUncheckedCreateWithoutWsUserInput[]
    connectOrCreate?: WSJobApplicationCreateOrConnectWithoutWsUserInput | WSJobApplicationCreateOrConnectWithoutWsUserInput[]
    createMany?: WSJobApplicationCreateManyWsUserInputEnvelope
    connect?: WSJobApplicationWhereUniqueInput | WSJobApplicationWhereUniqueInput[]
  }

  export type WSJobApplicationUncheckedCreateNestedManyWithoutWsUserInput = {
    create?: XOR<WSJobApplicationCreateWithoutWsUserInput, WSJobApplicationUncheckedCreateWithoutWsUserInput> | WSJobApplicationCreateWithoutWsUserInput[] | WSJobApplicationUncheckedCreateWithoutWsUserInput[]
    connectOrCreate?: WSJobApplicationCreateOrConnectWithoutWsUserInput | WSJobApplicationCreateOrConnectWithoutWsUserInput[]
    createMany?: WSJobApplicationCreateManyWsUserInputEnvelope
    connect?: WSJobApplicationWhereUniqueInput | WSJobApplicationWhereUniqueInput[]
  }

  export type WSJobApplicationUpdateManyWithoutWsUserNestedInput = {
    create?: XOR<WSJobApplicationCreateWithoutWsUserInput, WSJobApplicationUncheckedCreateWithoutWsUserInput> | WSJobApplicationCreateWithoutWsUserInput[] | WSJobApplicationUncheckedCreateWithoutWsUserInput[]
    connectOrCreate?: WSJobApplicationCreateOrConnectWithoutWsUserInput | WSJobApplicationCreateOrConnectWithoutWsUserInput[]
    upsert?: WSJobApplicationUpsertWithWhereUniqueWithoutWsUserInput | WSJobApplicationUpsertWithWhereUniqueWithoutWsUserInput[]
    createMany?: WSJobApplicationCreateManyWsUserInputEnvelope
    set?: WSJobApplicationWhereUniqueInput | WSJobApplicationWhereUniqueInput[]
    disconnect?: WSJobApplicationWhereUniqueInput | WSJobApplicationWhereUniqueInput[]
    delete?: WSJobApplicationWhereUniqueInput | WSJobApplicationWhereUniqueInput[]
    connect?: WSJobApplicationWhereUniqueInput | WSJobApplicationWhereUniqueInput[]
    update?: WSJobApplicationUpdateWithWhereUniqueWithoutWsUserInput | WSJobApplicationUpdateWithWhereUniqueWithoutWsUserInput[]
    updateMany?: WSJobApplicationUpdateManyWithWhereWithoutWsUserInput | WSJobApplicationUpdateManyWithWhereWithoutWsUserInput[]
    deleteMany?: WSJobApplicationScalarWhereInput | WSJobApplicationScalarWhereInput[]
  }

  export type WSJobApplicationUncheckedUpdateManyWithoutWsUserNestedInput = {
    create?: XOR<WSJobApplicationCreateWithoutWsUserInput, WSJobApplicationUncheckedCreateWithoutWsUserInput> | WSJobApplicationCreateWithoutWsUserInput[] | WSJobApplicationUncheckedCreateWithoutWsUserInput[]
    connectOrCreate?: WSJobApplicationCreateOrConnectWithoutWsUserInput | WSJobApplicationCreateOrConnectWithoutWsUserInput[]
    upsert?: WSJobApplicationUpsertWithWhereUniqueWithoutWsUserInput | WSJobApplicationUpsertWithWhereUniqueWithoutWsUserInput[]
    createMany?: WSJobApplicationCreateManyWsUserInputEnvelope
    set?: WSJobApplicationWhereUniqueInput | WSJobApplicationWhereUniqueInput[]
    disconnect?: WSJobApplicationWhereUniqueInput | WSJobApplicationWhereUniqueInput[]
    delete?: WSJobApplicationWhereUniqueInput | WSJobApplicationWhereUniqueInput[]
    connect?: WSJobApplicationWhereUniqueInput | WSJobApplicationWhereUniqueInput[]
    update?: WSJobApplicationUpdateWithWhereUniqueWithoutWsUserInput | WSJobApplicationUpdateWithWhereUniqueWithoutWsUserInput[]
    updateMany?: WSJobApplicationUpdateManyWithWhereWithoutWsUserInput | WSJobApplicationUpdateManyWithWhereWithoutWsUserInput[]
    deleteMany?: WSJobApplicationScalarWhereInput | WSJobApplicationScalarWhereInput[]
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type WsProductsCreateWithoutWsDepartmentsInput = {
    vendor_id: number
    item_number: string
    description?: string | null
    ai_description?: string | null
    ai_name?: string | null
    bucket: string
    original_img_url: string
    final_img_url?: string | null
    top_sold?: number | null
    is_home?: boolean | null
    is_new_arrival?: boolean | null
    status?: string | null
    created_on?: Date | string | null
    created_by?: string | null
  }

  export type WsProductsUncheckedCreateWithoutWsDepartmentsInput = {
    vendor_id: number
    item_number: string
    description?: string | null
    ai_description?: string | null
    ai_name?: string | null
    bucket: string
    original_img_url: string
    final_img_url?: string | null
    top_sold?: number | null
    is_home?: boolean | null
    is_new_arrival?: boolean | null
    status?: string | null
    created_on?: Date | string | null
    created_by?: string | null
  }

  export type WsProductsCreateOrConnectWithoutWsDepartmentsInput = {
    where: WsProductsWhereUniqueInput
    create: XOR<WsProductsCreateWithoutWsDepartmentsInput, WsProductsUncheckedCreateWithoutWsDepartmentsInput>
  }

  export type WsProductsCreateManyWsDepartmentsInputEnvelope = {
    data: WsProductsCreateManyWsDepartmentsInput | WsProductsCreateManyWsDepartmentsInput[]
  }

  export type WsProductsUpsertWithWhereUniqueWithoutWsDepartmentsInput = {
    where: WsProductsWhereUniqueInput
    update: XOR<WsProductsUpdateWithoutWsDepartmentsInput, WsProductsUncheckedUpdateWithoutWsDepartmentsInput>
    create: XOR<WsProductsCreateWithoutWsDepartmentsInput, WsProductsUncheckedCreateWithoutWsDepartmentsInput>
  }

  export type WsProductsUpdateWithWhereUniqueWithoutWsDepartmentsInput = {
    where: WsProductsWhereUniqueInput
    data: XOR<WsProductsUpdateWithoutWsDepartmentsInput, WsProductsUncheckedUpdateWithoutWsDepartmentsInput>
  }

  export type WsProductsUpdateManyWithWhereWithoutWsDepartmentsInput = {
    where: WsProductsScalarWhereInput
    data: XOR<WsProductsUpdateManyMutationInput, WsProductsUncheckedUpdateManyWithoutWsDepartmentsInput>
  }

  export type WsProductsScalarWhereInput = {
    AND?: WsProductsScalarWhereInput | WsProductsScalarWhereInput[]
    OR?: WsProductsScalarWhereInput[]
    NOT?: WsProductsScalarWhereInput | WsProductsScalarWhereInput[]
    vendor_id?: IntFilter<"WsProducts"> | number
    item_number?: StringFilter<"WsProducts"> | string
    description?: StringNullableFilter<"WsProducts"> | string | null
    ai_description?: StringNullableFilter<"WsProducts"> | string | null
    ai_name?: StringNullableFilter<"WsProducts"> | string | null
    dep?: StringFilter<"WsProducts"> | string
    bucket?: StringFilter<"WsProducts"> | string
    original_img_url?: StringFilter<"WsProducts"> | string
    final_img_url?: StringNullableFilter<"WsProducts"> | string | null
    top_sold?: IntNullableFilter<"WsProducts"> | number | null
    is_home?: BoolNullableFilter<"WsProducts"> | boolean | null
    is_new_arrival?: BoolNullableFilter<"WsProducts"> | boolean | null
    status?: StringNullableFilter<"WsProducts"> | string | null
    created_on?: DateTimeNullableFilter<"WsProducts"> | Date | string | null
    created_by?: StringNullableFilter<"WsProducts"> | string | null
  }

  export type WsStoreCreateWithoutWSJobInput = {
    Name: string
    Address?: string | null
    Email?: string | null
    BookingUrl?: string | null
    Latitude?: number
    Longitude?: number
    PlaceID?: string
  }

  export type WsStoreUncheckedCreateWithoutWSJobInput = {
    ID?: number
    Name: string
    Address?: string | null
    Email?: string | null
    BookingUrl?: string | null
    Latitude?: number
    Longitude?: number
    PlaceID?: string
  }

  export type WsStoreCreateOrConnectWithoutWSJobInput = {
    where: WsStoreWhereUniqueInput
    create: XOR<WsStoreCreateWithoutWSJobInput, WsStoreUncheckedCreateWithoutWSJobInput>
  }

  export type WSJobApplicationCreateWithoutWSJobInput = {
    IsValid?: string | null
    Status?: string | null
    Active: boolean
    CreatedBy?: string | null
    CreatedOn?: Date | string | null
    IsDenied?: boolean
    WsUser: WsUserCreateNestedOneWithoutWSJobApplicationInput
    WSJobApplicationEducation?: WSJobApplicationEducationCreateNestedManyWithoutWSJobApplicationInput
    WSJobApplicationFeedback?: WSJobApplicationFeedbackCreateNestedManyWithoutWSJobApplicationInput
    WSJobApplicationPreviousEmployment?: WSJobApplicationPreviousEmploymentCreateNestedManyWithoutWSJobApplicationInput
    WSJobApplicationReference?: WSJobApplicationReferenceCreateNestedManyWithoutWSJobApplicationInput
  }

  export type WSJobApplicationUncheckedCreateWithoutWSJobInput = {
    ID?: number
    UserId: number
    IsValid?: string | null
    Status?: string | null
    Active: boolean
    CreatedBy?: string | null
    CreatedOn?: Date | string | null
    IsDenied?: boolean
    WSJobApplicationEducation?: WSJobApplicationEducationUncheckedCreateNestedManyWithoutWSJobApplicationInput
    WSJobApplicationFeedback?: WSJobApplicationFeedbackUncheckedCreateNestedManyWithoutWSJobApplicationInput
    WSJobApplicationPreviousEmployment?: WSJobApplicationPreviousEmploymentUncheckedCreateNestedManyWithoutWSJobApplicationInput
    WSJobApplicationReference?: WSJobApplicationReferenceUncheckedCreateNestedManyWithoutWSJobApplicationInput
  }

  export type WSJobApplicationCreateOrConnectWithoutWSJobInput = {
    where: WSJobApplicationWhereUniqueInput
    create: XOR<WSJobApplicationCreateWithoutWSJobInput, WSJobApplicationUncheckedCreateWithoutWSJobInput>
  }

  export type WSJobApplicationCreateManyWSJobInputEnvelope = {
    data: WSJobApplicationCreateManyWSJobInput | WSJobApplicationCreateManyWSJobInput[]
  }

  export type WsStoreUpsertWithoutWSJobInput = {
    update: XOR<WsStoreUpdateWithoutWSJobInput, WsStoreUncheckedUpdateWithoutWSJobInput>
    create: XOR<WsStoreCreateWithoutWSJobInput, WsStoreUncheckedCreateWithoutWSJobInput>
    where?: WsStoreWhereInput
  }

  export type WsStoreUpdateToOneWithWhereWithoutWSJobInput = {
    where?: WsStoreWhereInput
    data: XOR<WsStoreUpdateWithoutWSJobInput, WsStoreUncheckedUpdateWithoutWSJobInput>
  }

  export type WsStoreUpdateWithoutWSJobInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    BookingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Latitude?: FloatFieldUpdateOperationsInput | number
    Longitude?: FloatFieldUpdateOperationsInput | number
    PlaceID?: StringFieldUpdateOperationsInput | string
  }

  export type WsStoreUncheckedUpdateWithoutWSJobInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    BookingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Latitude?: FloatFieldUpdateOperationsInput | number
    Longitude?: FloatFieldUpdateOperationsInput | number
    PlaceID?: StringFieldUpdateOperationsInput | string
  }

  export type WSJobApplicationUpsertWithWhereUniqueWithoutWSJobInput = {
    where: WSJobApplicationWhereUniqueInput
    update: XOR<WSJobApplicationUpdateWithoutWSJobInput, WSJobApplicationUncheckedUpdateWithoutWSJobInput>
    create: XOR<WSJobApplicationCreateWithoutWSJobInput, WSJobApplicationUncheckedCreateWithoutWSJobInput>
  }

  export type WSJobApplicationUpdateWithWhereUniqueWithoutWSJobInput = {
    where: WSJobApplicationWhereUniqueInput
    data: XOR<WSJobApplicationUpdateWithoutWSJobInput, WSJobApplicationUncheckedUpdateWithoutWSJobInput>
  }

  export type WSJobApplicationUpdateManyWithWhereWithoutWSJobInput = {
    where: WSJobApplicationScalarWhereInput
    data: XOR<WSJobApplicationUpdateManyMutationInput, WSJobApplicationUncheckedUpdateManyWithoutWSJobInput>
  }

  export type WSJobApplicationScalarWhereInput = {
    AND?: WSJobApplicationScalarWhereInput | WSJobApplicationScalarWhereInput[]
    OR?: WSJobApplicationScalarWhereInput[]
    NOT?: WSJobApplicationScalarWhereInput | WSJobApplicationScalarWhereInput[]
    ID?: IntFilter<"WSJobApplication"> | number
    JobId?: IntFilter<"WSJobApplication"> | number
    UserId?: IntFilter<"WSJobApplication"> | number
    IsValid?: StringNullableFilter<"WSJobApplication"> | string | null
    Status?: StringNullableFilter<"WSJobApplication"> | string | null
    Active?: BoolFilter<"WSJobApplication"> | boolean
    CreatedBy?: StringNullableFilter<"WSJobApplication"> | string | null
    CreatedOn?: DateTimeNullableFilter<"WSJobApplication"> | Date | string | null
    IsDenied?: BoolFilter<"WSJobApplication"> | boolean
  }

  export type WSJobCreateWithoutWSJobApplicationInput = {
    Name: string
    Description?: string | null
    Type?: string | null
    Category?: string | null
    CreatedOn?: Date | string | null
    Active?: boolean
    Status?: string | null
    CreatedBy: string
    MaxSalary?: number
    MinSalary?: number
    SalaryType?: string
    WsStore: WsStoreCreateNestedOneWithoutWSJobInput
  }

  export type WSJobUncheckedCreateWithoutWSJobApplicationInput = {
    ID?: number
    Name: string
    Description?: string | null
    Type?: string | null
    Category?: string | null
    CreatedOn?: Date | string | null
    Active?: boolean
    StoreId: number
    Status?: string | null
    CreatedBy: string
    MaxSalary?: number
    MinSalary?: number
    SalaryType?: string
  }

  export type WSJobCreateOrConnectWithoutWSJobApplicationInput = {
    where: WSJobWhereUniqueInput
    create: XOR<WSJobCreateWithoutWSJobApplicationInput, WSJobUncheckedCreateWithoutWSJobApplicationInput>
  }

  export type WsUserCreateWithoutWSJobApplicationInput = {
    Name: string
    MiddleName?: string | null
    LastName: string
    Street: string
    Apartment?: string | null
    City: string
    State: string
    Zip: string
    Phone: string
    SocialSecurity: string
    CanWorkInUs: string
    IsLegalAge: string
    ServedInMilitary?: string | null
    MilitaryBranch?: string | null
    MilitaryRank?: string | null
    MilitaryTypeOfDischarge?: string | null
    ResumeUrl?: string | null
    Email: string
    Auth0Id: string
  }

  export type WsUserUncheckedCreateWithoutWSJobApplicationInput = {
    ID?: number
    Name: string
    MiddleName?: string | null
    LastName: string
    Street: string
    Apartment?: string | null
    City: string
    State: string
    Zip: string
    Phone: string
    SocialSecurity: string
    CanWorkInUs: string
    IsLegalAge: string
    ServedInMilitary?: string | null
    MilitaryBranch?: string | null
    MilitaryRank?: string | null
    MilitaryTypeOfDischarge?: string | null
    ResumeUrl?: string | null
    Email: string
    Auth0Id: string
  }

  export type WsUserCreateOrConnectWithoutWSJobApplicationInput = {
    where: WsUserWhereUniqueInput
    create: XOR<WsUserCreateWithoutWSJobApplicationInput, WsUserUncheckedCreateWithoutWSJobApplicationInput>
  }

  export type WSJobApplicationEducationCreateWithoutWSJobApplicationInput = {
    EducationLevel: string
    Name: string
    Address: string
    FromDate: string
    ToDate?: string | null
    IsGraduated: string
    IsValid?: string | null
  }

  export type WSJobApplicationEducationUncheckedCreateWithoutWSJobApplicationInput = {
    ID?: number
    EducationLevel: string
    Name: string
    Address: string
    FromDate: string
    ToDate?: string | null
    IsGraduated: string
    IsValid?: string | null
  }

  export type WSJobApplicationEducationCreateOrConnectWithoutWSJobApplicationInput = {
    where: WSJobApplicationEducationWhereUniqueInput
    create: XOR<WSJobApplicationEducationCreateWithoutWSJobApplicationInput, WSJobApplicationEducationUncheckedCreateWithoutWSJobApplicationInput>
  }

  export type WSJobApplicationEducationCreateManyWSJobApplicationInputEnvelope = {
    data: WSJobApplicationEducationCreateManyWSJobApplicationInput | WSJobApplicationEducationCreateManyWSJobApplicationInput[]
  }

  export type WSJobApplicationFeedbackCreateWithoutWSJobApplicationInput = {
    Feedback: string
    CreatedBy: string
    CreatedOn: Date | string
    WsJobApplicationReply?: WsJobApplicationReplyCreateNestedManyWithoutWSJobApplicationFeedbackInput
  }

  export type WSJobApplicationFeedbackUncheckedCreateWithoutWSJobApplicationInput = {
    ID?: number
    Feedback: string
    CreatedBy: string
    CreatedOn: Date | string
    WsJobApplicationReply?: WsJobApplicationReplyUncheckedCreateNestedManyWithoutWSJobApplicationFeedbackInput
  }

  export type WSJobApplicationFeedbackCreateOrConnectWithoutWSJobApplicationInput = {
    where: WSJobApplicationFeedbackWhereUniqueInput
    create: XOR<WSJobApplicationFeedbackCreateWithoutWSJobApplicationInput, WSJobApplicationFeedbackUncheckedCreateWithoutWSJobApplicationInput>
  }

  export type WSJobApplicationFeedbackCreateManyWSJobApplicationInputEnvelope = {
    data: WSJobApplicationFeedbackCreateManyWSJobApplicationInput | WSJobApplicationFeedbackCreateManyWSJobApplicationInput[]
  }

  export type WSJobApplicationPreviousEmploymentCreateWithoutWSJobApplicationInput = {
    Company: string
    Supervisor: string
    Address: string
    FromDate: Date | string
    ToDate?: Date | string | null
    JobTitle: string
    EndingSalary?: number | null
    IsHourlyRate?: string | null
    LeavingReason?: string | null
    IsValid?: string | null
  }

  export type WSJobApplicationPreviousEmploymentUncheckedCreateWithoutWSJobApplicationInput = {
    ID?: number
    Company: string
    Supervisor: string
    Address: string
    FromDate: Date | string
    ToDate?: Date | string | null
    JobTitle: string
    EndingSalary?: number | null
    IsHourlyRate?: string | null
    LeavingReason?: string | null
    IsValid?: string | null
  }

  export type WSJobApplicationPreviousEmploymentCreateOrConnectWithoutWSJobApplicationInput = {
    where: WSJobApplicationPreviousEmploymentWhereUniqueInput
    create: XOR<WSJobApplicationPreviousEmploymentCreateWithoutWSJobApplicationInput, WSJobApplicationPreviousEmploymentUncheckedCreateWithoutWSJobApplicationInput>
  }

  export type WSJobApplicationPreviousEmploymentCreateManyWSJobApplicationInputEnvelope = {
    data: WSJobApplicationPreviousEmploymentCreateManyWSJobApplicationInput | WSJobApplicationPreviousEmploymentCreateManyWSJobApplicationInput[]
  }

  export type WSJobApplicationReferenceCreateWithoutWSJobApplicationInput = {
    FullName: string
    Relationship: string
    Company: string
    Phone: string
    Email: string
    IsValid?: string | null
  }

  export type WSJobApplicationReferenceUncheckedCreateWithoutWSJobApplicationInput = {
    ID?: number
    FullName: string
    Relationship: string
    Company: string
    Phone: string
    Email: string
    IsValid?: string | null
  }

  export type WSJobApplicationReferenceCreateOrConnectWithoutWSJobApplicationInput = {
    where: WSJobApplicationReferenceWhereUniqueInput
    create: XOR<WSJobApplicationReferenceCreateWithoutWSJobApplicationInput, WSJobApplicationReferenceUncheckedCreateWithoutWSJobApplicationInput>
  }

  export type WSJobApplicationReferenceCreateManyWSJobApplicationInputEnvelope = {
    data: WSJobApplicationReferenceCreateManyWSJobApplicationInput | WSJobApplicationReferenceCreateManyWSJobApplicationInput[]
  }

  export type WSJobUpsertWithoutWSJobApplicationInput = {
    update: XOR<WSJobUpdateWithoutWSJobApplicationInput, WSJobUncheckedUpdateWithoutWSJobApplicationInput>
    create: XOR<WSJobCreateWithoutWSJobApplicationInput, WSJobUncheckedCreateWithoutWSJobApplicationInput>
    where?: WSJobWhereInput
  }

  export type WSJobUpdateToOneWithWhereWithoutWSJobApplicationInput = {
    where?: WSJobWhereInput
    data: XOR<WSJobUpdateWithoutWSJobApplicationInput, WSJobUncheckedUpdateWithoutWSJobApplicationInput>
  }

  export type WSJobUpdateWithoutWSJobApplicationInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Active?: BoolFieldUpdateOperationsInput | boolean
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedBy?: StringFieldUpdateOperationsInput | string
    MaxSalary?: FloatFieldUpdateOperationsInput | number
    MinSalary?: FloatFieldUpdateOperationsInput | number
    SalaryType?: StringFieldUpdateOperationsInput | string
    WsStore?: WsStoreUpdateOneRequiredWithoutWSJobNestedInput
  }

  export type WSJobUncheckedUpdateWithoutWSJobApplicationInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Active?: BoolFieldUpdateOperationsInput | boolean
    StoreId?: IntFieldUpdateOperationsInput | number
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedBy?: StringFieldUpdateOperationsInput | string
    MaxSalary?: FloatFieldUpdateOperationsInput | number
    MinSalary?: FloatFieldUpdateOperationsInput | number
    SalaryType?: StringFieldUpdateOperationsInput | string
  }

  export type WsUserUpsertWithoutWSJobApplicationInput = {
    update: XOR<WsUserUpdateWithoutWSJobApplicationInput, WsUserUncheckedUpdateWithoutWSJobApplicationInput>
    create: XOR<WsUserCreateWithoutWSJobApplicationInput, WsUserUncheckedCreateWithoutWSJobApplicationInput>
    where?: WsUserWhereInput
  }

  export type WsUserUpdateToOneWithWhereWithoutWSJobApplicationInput = {
    where?: WsUserWhereInput
    data: XOR<WsUserUpdateWithoutWSJobApplicationInput, WsUserUncheckedUpdateWithoutWSJobApplicationInput>
  }

  export type WsUserUpdateWithoutWSJobApplicationInput = {
    Name?: StringFieldUpdateOperationsInput | string
    MiddleName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: StringFieldUpdateOperationsInput | string
    Street?: StringFieldUpdateOperationsInput | string
    Apartment?: NullableStringFieldUpdateOperationsInput | string | null
    City?: StringFieldUpdateOperationsInput | string
    State?: StringFieldUpdateOperationsInput | string
    Zip?: StringFieldUpdateOperationsInput | string
    Phone?: StringFieldUpdateOperationsInput | string
    SocialSecurity?: StringFieldUpdateOperationsInput | string
    CanWorkInUs?: StringFieldUpdateOperationsInput | string
    IsLegalAge?: StringFieldUpdateOperationsInput | string
    ServedInMilitary?: NullableStringFieldUpdateOperationsInput | string | null
    MilitaryBranch?: NullableStringFieldUpdateOperationsInput | string | null
    MilitaryRank?: NullableStringFieldUpdateOperationsInput | string | null
    MilitaryTypeOfDischarge?: NullableStringFieldUpdateOperationsInput | string | null
    ResumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: StringFieldUpdateOperationsInput | string
    Auth0Id?: StringFieldUpdateOperationsInput | string
  }

  export type WsUserUncheckedUpdateWithoutWSJobApplicationInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    MiddleName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: StringFieldUpdateOperationsInput | string
    Street?: StringFieldUpdateOperationsInput | string
    Apartment?: NullableStringFieldUpdateOperationsInput | string | null
    City?: StringFieldUpdateOperationsInput | string
    State?: StringFieldUpdateOperationsInput | string
    Zip?: StringFieldUpdateOperationsInput | string
    Phone?: StringFieldUpdateOperationsInput | string
    SocialSecurity?: StringFieldUpdateOperationsInput | string
    CanWorkInUs?: StringFieldUpdateOperationsInput | string
    IsLegalAge?: StringFieldUpdateOperationsInput | string
    ServedInMilitary?: NullableStringFieldUpdateOperationsInput | string | null
    MilitaryBranch?: NullableStringFieldUpdateOperationsInput | string | null
    MilitaryRank?: NullableStringFieldUpdateOperationsInput | string | null
    MilitaryTypeOfDischarge?: NullableStringFieldUpdateOperationsInput | string | null
    ResumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: StringFieldUpdateOperationsInput | string
    Auth0Id?: StringFieldUpdateOperationsInput | string
  }

  export type WSJobApplicationEducationUpsertWithWhereUniqueWithoutWSJobApplicationInput = {
    where: WSJobApplicationEducationWhereUniqueInput
    update: XOR<WSJobApplicationEducationUpdateWithoutWSJobApplicationInput, WSJobApplicationEducationUncheckedUpdateWithoutWSJobApplicationInput>
    create: XOR<WSJobApplicationEducationCreateWithoutWSJobApplicationInput, WSJobApplicationEducationUncheckedCreateWithoutWSJobApplicationInput>
  }

  export type WSJobApplicationEducationUpdateWithWhereUniqueWithoutWSJobApplicationInput = {
    where: WSJobApplicationEducationWhereUniqueInput
    data: XOR<WSJobApplicationEducationUpdateWithoutWSJobApplicationInput, WSJobApplicationEducationUncheckedUpdateWithoutWSJobApplicationInput>
  }

  export type WSJobApplicationEducationUpdateManyWithWhereWithoutWSJobApplicationInput = {
    where: WSJobApplicationEducationScalarWhereInput
    data: XOR<WSJobApplicationEducationUpdateManyMutationInput, WSJobApplicationEducationUncheckedUpdateManyWithoutWSJobApplicationInput>
  }

  export type WSJobApplicationEducationScalarWhereInput = {
    AND?: WSJobApplicationEducationScalarWhereInput | WSJobApplicationEducationScalarWhereInput[]
    OR?: WSJobApplicationEducationScalarWhereInput[]
    NOT?: WSJobApplicationEducationScalarWhereInput | WSJobApplicationEducationScalarWhereInput[]
    ID?: IntFilter<"WSJobApplicationEducation"> | number
    JobApplicationId?: IntNullableFilter<"WSJobApplicationEducation"> | number | null
    EducationLevel?: StringFilter<"WSJobApplicationEducation"> | string
    Name?: StringFilter<"WSJobApplicationEducation"> | string
    Address?: StringFilter<"WSJobApplicationEducation"> | string
    FromDate?: StringFilter<"WSJobApplicationEducation"> | string
    ToDate?: StringNullableFilter<"WSJobApplicationEducation"> | string | null
    IsGraduated?: StringFilter<"WSJobApplicationEducation"> | string
    IsValid?: StringNullableFilter<"WSJobApplicationEducation"> | string | null
  }

  export type WSJobApplicationFeedbackUpsertWithWhereUniqueWithoutWSJobApplicationInput = {
    where: WSJobApplicationFeedbackWhereUniqueInput
    update: XOR<WSJobApplicationFeedbackUpdateWithoutWSJobApplicationInput, WSJobApplicationFeedbackUncheckedUpdateWithoutWSJobApplicationInput>
    create: XOR<WSJobApplicationFeedbackCreateWithoutWSJobApplicationInput, WSJobApplicationFeedbackUncheckedCreateWithoutWSJobApplicationInput>
  }

  export type WSJobApplicationFeedbackUpdateWithWhereUniqueWithoutWSJobApplicationInput = {
    where: WSJobApplicationFeedbackWhereUniqueInput
    data: XOR<WSJobApplicationFeedbackUpdateWithoutWSJobApplicationInput, WSJobApplicationFeedbackUncheckedUpdateWithoutWSJobApplicationInput>
  }

  export type WSJobApplicationFeedbackUpdateManyWithWhereWithoutWSJobApplicationInput = {
    where: WSJobApplicationFeedbackScalarWhereInput
    data: XOR<WSJobApplicationFeedbackUpdateManyMutationInput, WSJobApplicationFeedbackUncheckedUpdateManyWithoutWSJobApplicationInput>
  }

  export type WSJobApplicationFeedbackScalarWhereInput = {
    AND?: WSJobApplicationFeedbackScalarWhereInput | WSJobApplicationFeedbackScalarWhereInput[]
    OR?: WSJobApplicationFeedbackScalarWhereInput[]
    NOT?: WSJobApplicationFeedbackScalarWhereInput | WSJobApplicationFeedbackScalarWhereInput[]
    ID?: IntFilter<"WSJobApplicationFeedback"> | number
    JobApplicationID?: IntFilter<"WSJobApplicationFeedback"> | number
    Feedback?: StringFilter<"WSJobApplicationFeedback"> | string
    CreatedBy?: StringFilter<"WSJobApplicationFeedback"> | string
    CreatedOn?: DateTimeFilter<"WSJobApplicationFeedback"> | Date | string
  }

  export type WSJobApplicationPreviousEmploymentUpsertWithWhereUniqueWithoutWSJobApplicationInput = {
    where: WSJobApplicationPreviousEmploymentWhereUniqueInput
    update: XOR<WSJobApplicationPreviousEmploymentUpdateWithoutWSJobApplicationInput, WSJobApplicationPreviousEmploymentUncheckedUpdateWithoutWSJobApplicationInput>
    create: XOR<WSJobApplicationPreviousEmploymentCreateWithoutWSJobApplicationInput, WSJobApplicationPreviousEmploymentUncheckedCreateWithoutWSJobApplicationInput>
  }

  export type WSJobApplicationPreviousEmploymentUpdateWithWhereUniqueWithoutWSJobApplicationInput = {
    where: WSJobApplicationPreviousEmploymentWhereUniqueInput
    data: XOR<WSJobApplicationPreviousEmploymentUpdateWithoutWSJobApplicationInput, WSJobApplicationPreviousEmploymentUncheckedUpdateWithoutWSJobApplicationInput>
  }

  export type WSJobApplicationPreviousEmploymentUpdateManyWithWhereWithoutWSJobApplicationInput = {
    where: WSJobApplicationPreviousEmploymentScalarWhereInput
    data: XOR<WSJobApplicationPreviousEmploymentUpdateManyMutationInput, WSJobApplicationPreviousEmploymentUncheckedUpdateManyWithoutWSJobApplicationInput>
  }

  export type WSJobApplicationPreviousEmploymentScalarWhereInput = {
    AND?: WSJobApplicationPreviousEmploymentScalarWhereInput | WSJobApplicationPreviousEmploymentScalarWhereInput[]
    OR?: WSJobApplicationPreviousEmploymentScalarWhereInput[]
    NOT?: WSJobApplicationPreviousEmploymentScalarWhereInput | WSJobApplicationPreviousEmploymentScalarWhereInput[]
    ID?: IntFilter<"WSJobApplicationPreviousEmployment"> | number
    JobApplicationId?: IntNullableFilter<"WSJobApplicationPreviousEmployment"> | number | null
    Company?: StringFilter<"WSJobApplicationPreviousEmployment"> | string
    Supervisor?: StringFilter<"WSJobApplicationPreviousEmployment"> | string
    Address?: StringFilter<"WSJobApplicationPreviousEmployment"> | string
    FromDate?: DateTimeFilter<"WSJobApplicationPreviousEmployment"> | Date | string
    ToDate?: DateTimeNullableFilter<"WSJobApplicationPreviousEmployment"> | Date | string | null
    JobTitle?: StringFilter<"WSJobApplicationPreviousEmployment"> | string
    EndingSalary?: FloatNullableFilter<"WSJobApplicationPreviousEmployment"> | number | null
    IsHourlyRate?: StringNullableFilter<"WSJobApplicationPreviousEmployment"> | string | null
    LeavingReason?: StringNullableFilter<"WSJobApplicationPreviousEmployment"> | string | null
    IsValid?: StringNullableFilter<"WSJobApplicationPreviousEmployment"> | string | null
  }

  export type WSJobApplicationReferenceUpsertWithWhereUniqueWithoutWSJobApplicationInput = {
    where: WSJobApplicationReferenceWhereUniqueInput
    update: XOR<WSJobApplicationReferenceUpdateWithoutWSJobApplicationInput, WSJobApplicationReferenceUncheckedUpdateWithoutWSJobApplicationInput>
    create: XOR<WSJobApplicationReferenceCreateWithoutWSJobApplicationInput, WSJobApplicationReferenceUncheckedCreateWithoutWSJobApplicationInput>
  }

  export type WSJobApplicationReferenceUpdateWithWhereUniqueWithoutWSJobApplicationInput = {
    where: WSJobApplicationReferenceWhereUniqueInput
    data: XOR<WSJobApplicationReferenceUpdateWithoutWSJobApplicationInput, WSJobApplicationReferenceUncheckedUpdateWithoutWSJobApplicationInput>
  }

  export type WSJobApplicationReferenceUpdateManyWithWhereWithoutWSJobApplicationInput = {
    where: WSJobApplicationReferenceScalarWhereInput
    data: XOR<WSJobApplicationReferenceUpdateManyMutationInput, WSJobApplicationReferenceUncheckedUpdateManyWithoutWSJobApplicationInput>
  }

  export type WSJobApplicationReferenceScalarWhereInput = {
    AND?: WSJobApplicationReferenceScalarWhereInput | WSJobApplicationReferenceScalarWhereInput[]
    OR?: WSJobApplicationReferenceScalarWhereInput[]
    NOT?: WSJobApplicationReferenceScalarWhereInput | WSJobApplicationReferenceScalarWhereInput[]
    ID?: IntFilter<"WSJobApplicationReference"> | number
    JobApplicationId?: IntNullableFilter<"WSJobApplicationReference"> | number | null
    FullName?: StringFilter<"WSJobApplicationReference"> | string
    Relationship?: StringFilter<"WSJobApplicationReference"> | string
    Company?: StringFilter<"WSJobApplicationReference"> | string
    Phone?: StringFilter<"WSJobApplicationReference"> | string
    Email?: StringFilter<"WSJobApplicationReference"> | string
    IsValid?: StringNullableFilter<"WSJobApplicationReference"> | string | null
  }

  export type WSJobApplicationCreateWithoutWSJobApplicationEducationInput = {
    IsValid?: string | null
    Status?: string | null
    Active: boolean
    CreatedBy?: string | null
    CreatedOn?: Date | string | null
    IsDenied?: boolean
    WSJob: WSJobCreateNestedOneWithoutWSJobApplicationInput
    WsUser: WsUserCreateNestedOneWithoutWSJobApplicationInput
    WSJobApplicationFeedback?: WSJobApplicationFeedbackCreateNestedManyWithoutWSJobApplicationInput
    WSJobApplicationPreviousEmployment?: WSJobApplicationPreviousEmploymentCreateNestedManyWithoutWSJobApplicationInput
    WSJobApplicationReference?: WSJobApplicationReferenceCreateNestedManyWithoutWSJobApplicationInput
  }

  export type WSJobApplicationUncheckedCreateWithoutWSJobApplicationEducationInput = {
    ID?: number
    JobId: number
    UserId: number
    IsValid?: string | null
    Status?: string | null
    Active: boolean
    CreatedBy?: string | null
    CreatedOn?: Date | string | null
    IsDenied?: boolean
    WSJobApplicationFeedback?: WSJobApplicationFeedbackUncheckedCreateNestedManyWithoutWSJobApplicationInput
    WSJobApplicationPreviousEmployment?: WSJobApplicationPreviousEmploymentUncheckedCreateNestedManyWithoutWSJobApplicationInput
    WSJobApplicationReference?: WSJobApplicationReferenceUncheckedCreateNestedManyWithoutWSJobApplicationInput
  }

  export type WSJobApplicationCreateOrConnectWithoutWSJobApplicationEducationInput = {
    where: WSJobApplicationWhereUniqueInput
    create: XOR<WSJobApplicationCreateWithoutWSJobApplicationEducationInput, WSJobApplicationUncheckedCreateWithoutWSJobApplicationEducationInput>
  }

  export type WSJobApplicationUpsertWithoutWSJobApplicationEducationInput = {
    update: XOR<WSJobApplicationUpdateWithoutWSJobApplicationEducationInput, WSJobApplicationUncheckedUpdateWithoutWSJobApplicationEducationInput>
    create: XOR<WSJobApplicationCreateWithoutWSJobApplicationEducationInput, WSJobApplicationUncheckedCreateWithoutWSJobApplicationEducationInput>
    where?: WSJobApplicationWhereInput
  }

  export type WSJobApplicationUpdateToOneWithWhereWithoutWSJobApplicationEducationInput = {
    where?: WSJobApplicationWhereInput
    data: XOR<WSJobApplicationUpdateWithoutWSJobApplicationEducationInput, WSJobApplicationUncheckedUpdateWithoutWSJobApplicationEducationInput>
  }

  export type WSJobApplicationUpdateWithoutWSJobApplicationEducationInput = {
    IsValid?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Active?: BoolFieldUpdateOperationsInput | boolean
    CreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsDenied?: BoolFieldUpdateOperationsInput | boolean
    WSJob?: WSJobUpdateOneRequiredWithoutWSJobApplicationNestedInput
    WsUser?: WsUserUpdateOneRequiredWithoutWSJobApplicationNestedInput
    WSJobApplicationFeedback?: WSJobApplicationFeedbackUpdateManyWithoutWSJobApplicationNestedInput
    WSJobApplicationPreviousEmployment?: WSJobApplicationPreviousEmploymentUpdateManyWithoutWSJobApplicationNestedInput
    WSJobApplicationReference?: WSJobApplicationReferenceUpdateManyWithoutWSJobApplicationNestedInput
  }

  export type WSJobApplicationUncheckedUpdateWithoutWSJobApplicationEducationInput = {
    ID?: IntFieldUpdateOperationsInput | number
    JobId?: IntFieldUpdateOperationsInput | number
    UserId?: IntFieldUpdateOperationsInput | number
    IsValid?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Active?: BoolFieldUpdateOperationsInput | boolean
    CreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsDenied?: BoolFieldUpdateOperationsInput | boolean
    WSJobApplicationFeedback?: WSJobApplicationFeedbackUncheckedUpdateManyWithoutWSJobApplicationNestedInput
    WSJobApplicationPreviousEmployment?: WSJobApplicationPreviousEmploymentUncheckedUpdateManyWithoutWSJobApplicationNestedInput
    WSJobApplicationReference?: WSJobApplicationReferenceUncheckedUpdateManyWithoutWSJobApplicationNestedInput
  }

  export type WSJobApplicationCreateWithoutWSJobApplicationFeedbackInput = {
    IsValid?: string | null
    Status?: string | null
    Active: boolean
    CreatedBy?: string | null
    CreatedOn?: Date | string | null
    IsDenied?: boolean
    WSJob: WSJobCreateNestedOneWithoutWSJobApplicationInput
    WsUser: WsUserCreateNestedOneWithoutWSJobApplicationInput
    WSJobApplicationEducation?: WSJobApplicationEducationCreateNestedManyWithoutWSJobApplicationInput
    WSJobApplicationPreviousEmployment?: WSJobApplicationPreviousEmploymentCreateNestedManyWithoutWSJobApplicationInput
    WSJobApplicationReference?: WSJobApplicationReferenceCreateNestedManyWithoutWSJobApplicationInput
  }

  export type WSJobApplicationUncheckedCreateWithoutWSJobApplicationFeedbackInput = {
    ID?: number
    JobId: number
    UserId: number
    IsValid?: string | null
    Status?: string | null
    Active: boolean
    CreatedBy?: string | null
    CreatedOn?: Date | string | null
    IsDenied?: boolean
    WSJobApplicationEducation?: WSJobApplicationEducationUncheckedCreateNestedManyWithoutWSJobApplicationInput
    WSJobApplicationPreviousEmployment?: WSJobApplicationPreviousEmploymentUncheckedCreateNestedManyWithoutWSJobApplicationInput
    WSJobApplicationReference?: WSJobApplicationReferenceUncheckedCreateNestedManyWithoutWSJobApplicationInput
  }

  export type WSJobApplicationCreateOrConnectWithoutWSJobApplicationFeedbackInput = {
    where: WSJobApplicationWhereUniqueInput
    create: XOR<WSJobApplicationCreateWithoutWSJobApplicationFeedbackInput, WSJobApplicationUncheckedCreateWithoutWSJobApplicationFeedbackInput>
  }

  export type WsJobApplicationReplyCreateWithoutWSJobApplicationFeedbackInput = {
    Message: string
    CreatedBy: string
    CreatedOn: Date | string
    ModifiedOn?: Date | string | null
  }

  export type WsJobApplicationReplyUncheckedCreateWithoutWSJobApplicationFeedbackInput = {
    ID?: number
    Message: string
    CreatedBy: string
    CreatedOn: Date | string
    ModifiedOn?: Date | string | null
  }

  export type WsJobApplicationReplyCreateOrConnectWithoutWSJobApplicationFeedbackInput = {
    where: WsJobApplicationReplyWhereUniqueInput
    create: XOR<WsJobApplicationReplyCreateWithoutWSJobApplicationFeedbackInput, WsJobApplicationReplyUncheckedCreateWithoutWSJobApplicationFeedbackInput>
  }

  export type WsJobApplicationReplyCreateManyWSJobApplicationFeedbackInputEnvelope = {
    data: WsJobApplicationReplyCreateManyWSJobApplicationFeedbackInput | WsJobApplicationReplyCreateManyWSJobApplicationFeedbackInput[]
  }

  export type WSJobApplicationUpsertWithoutWSJobApplicationFeedbackInput = {
    update: XOR<WSJobApplicationUpdateWithoutWSJobApplicationFeedbackInput, WSJobApplicationUncheckedUpdateWithoutWSJobApplicationFeedbackInput>
    create: XOR<WSJobApplicationCreateWithoutWSJobApplicationFeedbackInput, WSJobApplicationUncheckedCreateWithoutWSJobApplicationFeedbackInput>
    where?: WSJobApplicationWhereInput
  }

  export type WSJobApplicationUpdateToOneWithWhereWithoutWSJobApplicationFeedbackInput = {
    where?: WSJobApplicationWhereInput
    data: XOR<WSJobApplicationUpdateWithoutWSJobApplicationFeedbackInput, WSJobApplicationUncheckedUpdateWithoutWSJobApplicationFeedbackInput>
  }

  export type WSJobApplicationUpdateWithoutWSJobApplicationFeedbackInput = {
    IsValid?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Active?: BoolFieldUpdateOperationsInput | boolean
    CreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsDenied?: BoolFieldUpdateOperationsInput | boolean
    WSJob?: WSJobUpdateOneRequiredWithoutWSJobApplicationNestedInput
    WsUser?: WsUserUpdateOneRequiredWithoutWSJobApplicationNestedInput
    WSJobApplicationEducation?: WSJobApplicationEducationUpdateManyWithoutWSJobApplicationNestedInput
    WSJobApplicationPreviousEmployment?: WSJobApplicationPreviousEmploymentUpdateManyWithoutWSJobApplicationNestedInput
    WSJobApplicationReference?: WSJobApplicationReferenceUpdateManyWithoutWSJobApplicationNestedInput
  }

  export type WSJobApplicationUncheckedUpdateWithoutWSJobApplicationFeedbackInput = {
    ID?: IntFieldUpdateOperationsInput | number
    JobId?: IntFieldUpdateOperationsInput | number
    UserId?: IntFieldUpdateOperationsInput | number
    IsValid?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Active?: BoolFieldUpdateOperationsInput | boolean
    CreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsDenied?: BoolFieldUpdateOperationsInput | boolean
    WSJobApplicationEducation?: WSJobApplicationEducationUncheckedUpdateManyWithoutWSJobApplicationNestedInput
    WSJobApplicationPreviousEmployment?: WSJobApplicationPreviousEmploymentUncheckedUpdateManyWithoutWSJobApplicationNestedInput
    WSJobApplicationReference?: WSJobApplicationReferenceUncheckedUpdateManyWithoutWSJobApplicationNestedInput
  }

  export type WsJobApplicationReplyUpsertWithWhereUniqueWithoutWSJobApplicationFeedbackInput = {
    where: WsJobApplicationReplyWhereUniqueInput
    update: XOR<WsJobApplicationReplyUpdateWithoutWSJobApplicationFeedbackInput, WsJobApplicationReplyUncheckedUpdateWithoutWSJobApplicationFeedbackInput>
    create: XOR<WsJobApplicationReplyCreateWithoutWSJobApplicationFeedbackInput, WsJobApplicationReplyUncheckedCreateWithoutWSJobApplicationFeedbackInput>
  }

  export type WsJobApplicationReplyUpdateWithWhereUniqueWithoutWSJobApplicationFeedbackInput = {
    where: WsJobApplicationReplyWhereUniqueInput
    data: XOR<WsJobApplicationReplyUpdateWithoutWSJobApplicationFeedbackInput, WsJobApplicationReplyUncheckedUpdateWithoutWSJobApplicationFeedbackInput>
  }

  export type WsJobApplicationReplyUpdateManyWithWhereWithoutWSJobApplicationFeedbackInput = {
    where: WsJobApplicationReplyScalarWhereInput
    data: XOR<WsJobApplicationReplyUpdateManyMutationInput, WsJobApplicationReplyUncheckedUpdateManyWithoutWSJobApplicationFeedbackInput>
  }

  export type WsJobApplicationReplyScalarWhereInput = {
    AND?: WsJobApplicationReplyScalarWhereInput | WsJobApplicationReplyScalarWhereInput[]
    OR?: WsJobApplicationReplyScalarWhereInput[]
    NOT?: WsJobApplicationReplyScalarWhereInput | WsJobApplicationReplyScalarWhereInput[]
    ID?: IntFilter<"WsJobApplicationReply"> | number
    FeedbackID?: IntFilter<"WsJobApplicationReply"> | number
    Message?: StringFilter<"WsJobApplicationReply"> | string
    CreatedBy?: StringFilter<"WsJobApplicationReply"> | string
    CreatedOn?: DateTimeFilter<"WsJobApplicationReply"> | Date | string
    ModifiedOn?: DateTimeNullableFilter<"WsJobApplicationReply"> | Date | string | null
  }

  export type WSJobApplicationCreateWithoutWSJobApplicationPreviousEmploymentInput = {
    IsValid?: string | null
    Status?: string | null
    Active: boolean
    CreatedBy?: string | null
    CreatedOn?: Date | string | null
    IsDenied?: boolean
    WSJob: WSJobCreateNestedOneWithoutWSJobApplicationInput
    WsUser: WsUserCreateNestedOneWithoutWSJobApplicationInput
    WSJobApplicationEducation?: WSJobApplicationEducationCreateNestedManyWithoutWSJobApplicationInput
    WSJobApplicationFeedback?: WSJobApplicationFeedbackCreateNestedManyWithoutWSJobApplicationInput
    WSJobApplicationReference?: WSJobApplicationReferenceCreateNestedManyWithoutWSJobApplicationInput
  }

  export type WSJobApplicationUncheckedCreateWithoutWSJobApplicationPreviousEmploymentInput = {
    ID?: number
    JobId: number
    UserId: number
    IsValid?: string | null
    Status?: string | null
    Active: boolean
    CreatedBy?: string | null
    CreatedOn?: Date | string | null
    IsDenied?: boolean
    WSJobApplicationEducation?: WSJobApplicationEducationUncheckedCreateNestedManyWithoutWSJobApplicationInput
    WSJobApplicationFeedback?: WSJobApplicationFeedbackUncheckedCreateNestedManyWithoutWSJobApplicationInput
    WSJobApplicationReference?: WSJobApplicationReferenceUncheckedCreateNestedManyWithoutWSJobApplicationInput
  }

  export type WSJobApplicationCreateOrConnectWithoutWSJobApplicationPreviousEmploymentInput = {
    where: WSJobApplicationWhereUniqueInput
    create: XOR<WSJobApplicationCreateWithoutWSJobApplicationPreviousEmploymentInput, WSJobApplicationUncheckedCreateWithoutWSJobApplicationPreviousEmploymentInput>
  }

  export type WSJobApplicationUpsertWithoutWSJobApplicationPreviousEmploymentInput = {
    update: XOR<WSJobApplicationUpdateWithoutWSJobApplicationPreviousEmploymentInput, WSJobApplicationUncheckedUpdateWithoutWSJobApplicationPreviousEmploymentInput>
    create: XOR<WSJobApplicationCreateWithoutWSJobApplicationPreviousEmploymentInput, WSJobApplicationUncheckedCreateWithoutWSJobApplicationPreviousEmploymentInput>
    where?: WSJobApplicationWhereInput
  }

  export type WSJobApplicationUpdateToOneWithWhereWithoutWSJobApplicationPreviousEmploymentInput = {
    where?: WSJobApplicationWhereInput
    data: XOR<WSJobApplicationUpdateWithoutWSJobApplicationPreviousEmploymentInput, WSJobApplicationUncheckedUpdateWithoutWSJobApplicationPreviousEmploymentInput>
  }

  export type WSJobApplicationUpdateWithoutWSJobApplicationPreviousEmploymentInput = {
    IsValid?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Active?: BoolFieldUpdateOperationsInput | boolean
    CreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsDenied?: BoolFieldUpdateOperationsInput | boolean
    WSJob?: WSJobUpdateOneRequiredWithoutWSJobApplicationNestedInput
    WsUser?: WsUserUpdateOneRequiredWithoutWSJobApplicationNestedInput
    WSJobApplicationEducation?: WSJobApplicationEducationUpdateManyWithoutWSJobApplicationNestedInput
    WSJobApplicationFeedback?: WSJobApplicationFeedbackUpdateManyWithoutWSJobApplicationNestedInput
    WSJobApplicationReference?: WSJobApplicationReferenceUpdateManyWithoutWSJobApplicationNestedInput
  }

  export type WSJobApplicationUncheckedUpdateWithoutWSJobApplicationPreviousEmploymentInput = {
    ID?: IntFieldUpdateOperationsInput | number
    JobId?: IntFieldUpdateOperationsInput | number
    UserId?: IntFieldUpdateOperationsInput | number
    IsValid?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Active?: BoolFieldUpdateOperationsInput | boolean
    CreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsDenied?: BoolFieldUpdateOperationsInput | boolean
    WSJobApplicationEducation?: WSJobApplicationEducationUncheckedUpdateManyWithoutWSJobApplicationNestedInput
    WSJobApplicationFeedback?: WSJobApplicationFeedbackUncheckedUpdateManyWithoutWSJobApplicationNestedInput
    WSJobApplicationReference?: WSJobApplicationReferenceUncheckedUpdateManyWithoutWSJobApplicationNestedInput
  }

  export type WSJobApplicationCreateWithoutWSJobApplicationReferenceInput = {
    IsValid?: string | null
    Status?: string | null
    Active: boolean
    CreatedBy?: string | null
    CreatedOn?: Date | string | null
    IsDenied?: boolean
    WSJob: WSJobCreateNestedOneWithoutWSJobApplicationInput
    WsUser: WsUserCreateNestedOneWithoutWSJobApplicationInput
    WSJobApplicationEducation?: WSJobApplicationEducationCreateNestedManyWithoutWSJobApplicationInput
    WSJobApplicationFeedback?: WSJobApplicationFeedbackCreateNestedManyWithoutWSJobApplicationInput
    WSJobApplicationPreviousEmployment?: WSJobApplicationPreviousEmploymentCreateNestedManyWithoutWSJobApplicationInput
  }

  export type WSJobApplicationUncheckedCreateWithoutWSJobApplicationReferenceInput = {
    ID?: number
    JobId: number
    UserId: number
    IsValid?: string | null
    Status?: string | null
    Active: boolean
    CreatedBy?: string | null
    CreatedOn?: Date | string | null
    IsDenied?: boolean
    WSJobApplicationEducation?: WSJobApplicationEducationUncheckedCreateNestedManyWithoutWSJobApplicationInput
    WSJobApplicationFeedback?: WSJobApplicationFeedbackUncheckedCreateNestedManyWithoutWSJobApplicationInput
    WSJobApplicationPreviousEmployment?: WSJobApplicationPreviousEmploymentUncheckedCreateNestedManyWithoutWSJobApplicationInput
  }

  export type WSJobApplicationCreateOrConnectWithoutWSJobApplicationReferenceInput = {
    where: WSJobApplicationWhereUniqueInput
    create: XOR<WSJobApplicationCreateWithoutWSJobApplicationReferenceInput, WSJobApplicationUncheckedCreateWithoutWSJobApplicationReferenceInput>
  }

  export type WSJobApplicationUpsertWithoutWSJobApplicationReferenceInput = {
    update: XOR<WSJobApplicationUpdateWithoutWSJobApplicationReferenceInput, WSJobApplicationUncheckedUpdateWithoutWSJobApplicationReferenceInput>
    create: XOR<WSJobApplicationCreateWithoutWSJobApplicationReferenceInput, WSJobApplicationUncheckedCreateWithoutWSJobApplicationReferenceInput>
    where?: WSJobApplicationWhereInput
  }

  export type WSJobApplicationUpdateToOneWithWhereWithoutWSJobApplicationReferenceInput = {
    where?: WSJobApplicationWhereInput
    data: XOR<WSJobApplicationUpdateWithoutWSJobApplicationReferenceInput, WSJobApplicationUncheckedUpdateWithoutWSJobApplicationReferenceInput>
  }

  export type WSJobApplicationUpdateWithoutWSJobApplicationReferenceInput = {
    IsValid?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Active?: BoolFieldUpdateOperationsInput | boolean
    CreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsDenied?: BoolFieldUpdateOperationsInput | boolean
    WSJob?: WSJobUpdateOneRequiredWithoutWSJobApplicationNestedInput
    WsUser?: WsUserUpdateOneRequiredWithoutWSJobApplicationNestedInput
    WSJobApplicationEducation?: WSJobApplicationEducationUpdateManyWithoutWSJobApplicationNestedInput
    WSJobApplicationFeedback?: WSJobApplicationFeedbackUpdateManyWithoutWSJobApplicationNestedInput
    WSJobApplicationPreviousEmployment?: WSJobApplicationPreviousEmploymentUpdateManyWithoutWSJobApplicationNestedInput
  }

  export type WSJobApplicationUncheckedUpdateWithoutWSJobApplicationReferenceInput = {
    ID?: IntFieldUpdateOperationsInput | number
    JobId?: IntFieldUpdateOperationsInput | number
    UserId?: IntFieldUpdateOperationsInput | number
    IsValid?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Active?: BoolFieldUpdateOperationsInput | boolean
    CreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsDenied?: BoolFieldUpdateOperationsInput | boolean
    WSJobApplicationEducation?: WSJobApplicationEducationUncheckedUpdateManyWithoutWSJobApplicationNestedInput
    WSJobApplicationFeedback?: WSJobApplicationFeedbackUncheckedUpdateManyWithoutWSJobApplicationNestedInput
    WSJobApplicationPreviousEmployment?: WSJobApplicationPreviousEmploymentUncheckedUpdateManyWithoutWSJobApplicationNestedInput
  }

  export type WSJobApplicationFeedbackCreateWithoutWsJobApplicationReplyInput = {
    Feedback: string
    CreatedBy: string
    CreatedOn: Date | string
    WSJobApplication: WSJobApplicationCreateNestedOneWithoutWSJobApplicationFeedbackInput
  }

  export type WSJobApplicationFeedbackUncheckedCreateWithoutWsJobApplicationReplyInput = {
    ID?: number
    JobApplicationID: number
    Feedback: string
    CreatedBy: string
    CreatedOn: Date | string
  }

  export type WSJobApplicationFeedbackCreateOrConnectWithoutWsJobApplicationReplyInput = {
    where: WSJobApplicationFeedbackWhereUniqueInput
    create: XOR<WSJobApplicationFeedbackCreateWithoutWsJobApplicationReplyInput, WSJobApplicationFeedbackUncheckedCreateWithoutWsJobApplicationReplyInput>
  }

  export type WSJobApplicationFeedbackUpsertWithoutWsJobApplicationReplyInput = {
    update: XOR<WSJobApplicationFeedbackUpdateWithoutWsJobApplicationReplyInput, WSJobApplicationFeedbackUncheckedUpdateWithoutWsJobApplicationReplyInput>
    create: XOR<WSJobApplicationFeedbackCreateWithoutWsJobApplicationReplyInput, WSJobApplicationFeedbackUncheckedCreateWithoutWsJobApplicationReplyInput>
    where?: WSJobApplicationFeedbackWhereInput
  }

  export type WSJobApplicationFeedbackUpdateToOneWithWhereWithoutWsJobApplicationReplyInput = {
    where?: WSJobApplicationFeedbackWhereInput
    data: XOR<WSJobApplicationFeedbackUpdateWithoutWsJobApplicationReplyInput, WSJobApplicationFeedbackUncheckedUpdateWithoutWsJobApplicationReplyInput>
  }

  export type WSJobApplicationFeedbackUpdateWithoutWsJobApplicationReplyInput = {
    Feedback?: StringFieldUpdateOperationsInput | string
    CreatedBy?: StringFieldUpdateOperationsInput | string
    CreatedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    WSJobApplication?: WSJobApplicationUpdateOneRequiredWithoutWSJobApplicationFeedbackNestedInput
  }

  export type WSJobApplicationFeedbackUncheckedUpdateWithoutWsJobApplicationReplyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    JobApplicationID?: IntFieldUpdateOperationsInput | number
    Feedback?: StringFieldUpdateOperationsInput | string
    CreatedBy?: StringFieldUpdateOperationsInput | string
    CreatedOn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WsDepartmentsCreateWithoutWsProductsInput = {
    dep: string
    alias?: string | null
    order?: number | null
    app_bar?: boolean | null
    banner_url?: string | null
    created_on?: Date | string | null
    created_by?: string | null
  }

  export type WsDepartmentsUncheckedCreateWithoutWsProductsInput = {
    dep: string
    alias?: string | null
    order?: number | null
    app_bar?: boolean | null
    banner_url?: string | null
    created_on?: Date | string | null
    created_by?: string | null
  }

  export type WsDepartmentsCreateOrConnectWithoutWsProductsInput = {
    where: WsDepartmentsWhereUniqueInput
    create: XOR<WsDepartmentsCreateWithoutWsProductsInput, WsDepartmentsUncheckedCreateWithoutWsProductsInput>
  }

  export type WsDepartmentsUpsertWithoutWsProductsInput = {
    update: XOR<WsDepartmentsUpdateWithoutWsProductsInput, WsDepartmentsUncheckedUpdateWithoutWsProductsInput>
    create: XOR<WsDepartmentsCreateWithoutWsProductsInput, WsDepartmentsUncheckedCreateWithoutWsProductsInput>
    where?: WsDepartmentsWhereInput
  }

  export type WsDepartmentsUpdateToOneWithWhereWithoutWsProductsInput = {
    where?: WsDepartmentsWhereInput
    data: XOR<WsDepartmentsUpdateWithoutWsProductsInput, WsDepartmentsUncheckedUpdateWithoutWsProductsInput>
  }

  export type WsDepartmentsUpdateWithoutWsProductsInput = {
    dep?: StringFieldUpdateOperationsInput | string
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    app_bar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banner_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WsDepartmentsUncheckedUpdateWithoutWsProductsInput = {
    dep?: StringFieldUpdateOperationsInput | string
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    app_bar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banner_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WSTaxExemptCreateWithoutWSStateInput = {
    organization?: string | null
    organizationDescription?: string | null
    number?: string | null
    country?: string | null
    streetAddress?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    mobileNumber?: string | null
    apartment?: string | null
    purpose?: string | null
    organizationType?: string | null
    name?: string | null
    email?: string | null
    status?: string | null
    states?: string | null
    signerName?: string | null
    signerTitle?: string | null
    signature?: string | null
    certificateType?: string | null
  }

  export type WSTaxExemptUncheckedCreateWithoutWSStateInput = {
    ID?: number
    organization?: string | null
    organizationDescription?: string | null
    number?: string | null
    country?: string | null
    streetAddress?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    mobileNumber?: string | null
    apartment?: string | null
    purpose?: string | null
    organizationType?: string | null
    name?: string | null
    email?: string | null
    status?: string | null
    states?: string | null
    signerName?: string | null
    signerTitle?: string | null
    signature?: string | null
    certificateType?: string | null
  }

  export type WSTaxExemptCreateOrConnectWithoutWSStateInput = {
    where: WSTaxExemptWhereUniqueInput
    create: XOR<WSTaxExemptCreateWithoutWSStateInput, WSTaxExemptUncheckedCreateWithoutWSStateInput>
  }

  export type WSTaxExemptUpsertWithoutWSStateInput = {
    update: XOR<WSTaxExemptUpdateWithoutWSStateInput, WSTaxExemptUncheckedUpdateWithoutWSStateInput>
    create: XOR<WSTaxExemptCreateWithoutWSStateInput, WSTaxExemptUncheckedCreateWithoutWSStateInput>
    where?: WSTaxExemptWhereInput
  }

  export type WSTaxExemptUpdateToOneWithWhereWithoutWSStateInput = {
    where?: WSTaxExemptWhereInput
    data: XOR<WSTaxExemptUpdateWithoutWSStateInput, WSTaxExemptUncheckedUpdateWithoutWSStateInput>
  }

  export type WSTaxExemptUpdateWithoutWSStateInput = {
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    organizationDescription?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    streetAddress?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    apartment?: NullableStringFieldUpdateOperationsInput | string | null
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    organizationType?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    states?: NullableStringFieldUpdateOperationsInput | string | null
    signerName?: NullableStringFieldUpdateOperationsInput | string | null
    signerTitle?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    certificateType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WSTaxExemptUncheckedUpdateWithoutWSStateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    organizationDescription?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    streetAddress?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    apartment?: NullableStringFieldUpdateOperationsInput | string | null
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    organizationType?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    states?: NullableStringFieldUpdateOperationsInput | string | null
    signerName?: NullableStringFieldUpdateOperationsInput | string | null
    signerTitle?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    certificateType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WSJobCreateWithoutWsStoreInput = {
    Name: string
    Description?: string | null
    Type?: string | null
    Category?: string | null
    CreatedOn?: Date | string | null
    Active?: boolean
    Status?: string | null
    CreatedBy: string
    MaxSalary?: number
    MinSalary?: number
    SalaryType?: string
    WSJobApplication?: WSJobApplicationCreateNestedManyWithoutWSJobInput
  }

  export type WSJobUncheckedCreateWithoutWsStoreInput = {
    ID?: number
    Name: string
    Description?: string | null
    Type?: string | null
    Category?: string | null
    CreatedOn?: Date | string | null
    Active?: boolean
    Status?: string | null
    CreatedBy: string
    MaxSalary?: number
    MinSalary?: number
    SalaryType?: string
    WSJobApplication?: WSJobApplicationUncheckedCreateNestedManyWithoutWSJobInput
  }

  export type WSJobCreateOrConnectWithoutWsStoreInput = {
    where: WSJobWhereUniqueInput
    create: XOR<WSJobCreateWithoutWsStoreInput, WSJobUncheckedCreateWithoutWsStoreInput>
  }

  export type WSJobCreateManyWsStoreInputEnvelope = {
    data: WSJobCreateManyWsStoreInput | WSJobCreateManyWsStoreInput[]
  }

  export type WSJobUpsertWithWhereUniqueWithoutWsStoreInput = {
    where: WSJobWhereUniqueInput
    update: XOR<WSJobUpdateWithoutWsStoreInput, WSJobUncheckedUpdateWithoutWsStoreInput>
    create: XOR<WSJobCreateWithoutWsStoreInput, WSJobUncheckedCreateWithoutWsStoreInput>
  }

  export type WSJobUpdateWithWhereUniqueWithoutWsStoreInput = {
    where: WSJobWhereUniqueInput
    data: XOR<WSJobUpdateWithoutWsStoreInput, WSJobUncheckedUpdateWithoutWsStoreInput>
  }

  export type WSJobUpdateManyWithWhereWithoutWsStoreInput = {
    where: WSJobScalarWhereInput
    data: XOR<WSJobUpdateManyMutationInput, WSJobUncheckedUpdateManyWithoutWsStoreInput>
  }

  export type WSJobScalarWhereInput = {
    AND?: WSJobScalarWhereInput | WSJobScalarWhereInput[]
    OR?: WSJobScalarWhereInput[]
    NOT?: WSJobScalarWhereInput | WSJobScalarWhereInput[]
    ID?: IntFilter<"WSJob"> | number
    Name?: StringFilter<"WSJob"> | string
    Description?: StringNullableFilter<"WSJob"> | string | null
    Type?: StringNullableFilter<"WSJob"> | string | null
    Category?: StringNullableFilter<"WSJob"> | string | null
    CreatedOn?: DateTimeNullableFilter<"WSJob"> | Date | string | null
    Active?: BoolFilter<"WSJob"> | boolean
    StoreId?: IntFilter<"WSJob"> | number
    Status?: StringNullableFilter<"WSJob"> | string | null
    CreatedBy?: StringFilter<"WSJob"> | string
    MaxSalary?: FloatFilter<"WSJob"> | number
    MinSalary?: FloatFilter<"WSJob"> | number
    SalaryType?: StringFilter<"WSJob"> | string
  }

  export type WSStateCreateWithoutWSTaxExemptInput = {
    state?: string | null
    st_licenseNumber?: string | null
    st_expiryDate?: Date | string | null
    st_fileUrl?: string | null
    ll_licenseNumber?: string | null
    ll_expiryDate?: Date | string | null
    ll_fileUrl?: string | null
  }

  export type WSStateUncheckedCreateWithoutWSTaxExemptInput = {
    ID?: number
    state?: string | null
    st_licenseNumber?: string | null
    st_expiryDate?: Date | string | null
    st_fileUrl?: string | null
    ll_licenseNumber?: string | null
    ll_expiryDate?: Date | string | null
    ll_fileUrl?: string | null
  }

  export type WSStateCreateOrConnectWithoutWSTaxExemptInput = {
    where: WSStateWhereUniqueInput
    create: XOR<WSStateCreateWithoutWSTaxExemptInput, WSStateUncheckedCreateWithoutWSTaxExemptInput>
  }

  export type WSStateCreateManyWSTaxExemptInputEnvelope = {
    data: WSStateCreateManyWSTaxExemptInput | WSStateCreateManyWSTaxExemptInput[]
  }

  export type WSStateUpsertWithWhereUniqueWithoutWSTaxExemptInput = {
    where: WSStateWhereUniqueInput
    update: XOR<WSStateUpdateWithoutWSTaxExemptInput, WSStateUncheckedUpdateWithoutWSTaxExemptInput>
    create: XOR<WSStateCreateWithoutWSTaxExemptInput, WSStateUncheckedCreateWithoutWSTaxExemptInput>
  }

  export type WSStateUpdateWithWhereUniqueWithoutWSTaxExemptInput = {
    where: WSStateWhereUniqueInput
    data: XOR<WSStateUpdateWithoutWSTaxExemptInput, WSStateUncheckedUpdateWithoutWSTaxExemptInput>
  }

  export type WSStateUpdateManyWithWhereWithoutWSTaxExemptInput = {
    where: WSStateScalarWhereInput
    data: XOR<WSStateUpdateManyMutationInput, WSStateUncheckedUpdateManyWithoutWSTaxExemptInput>
  }

  export type WSStateScalarWhereInput = {
    AND?: WSStateScalarWhereInput | WSStateScalarWhereInput[]
    OR?: WSStateScalarWhereInput[]
    NOT?: WSStateScalarWhereInput | WSStateScalarWhereInput[]
    ID?: IntFilter<"WSState"> | number
    state?: StringNullableFilter<"WSState"> | string | null
    st_licenseNumber?: StringNullableFilter<"WSState"> | string | null
    st_expiryDate?: DateTimeNullableFilter<"WSState"> | Date | string | null
    st_fileUrl?: StringNullableFilter<"WSState"> | string | null
    ll_licenseNumber?: StringNullableFilter<"WSState"> | string | null
    ll_expiryDate?: DateTimeNullableFilter<"WSState"> | Date | string | null
    ll_fileUrl?: StringNullableFilter<"WSState"> | string | null
    taxExemptId?: IntNullableFilter<"WSState"> | number | null
  }

  export type WSJobApplicationCreateWithoutWsUserInput = {
    IsValid?: string | null
    Status?: string | null
    Active: boolean
    CreatedBy?: string | null
    CreatedOn?: Date | string | null
    IsDenied?: boolean
    WSJob: WSJobCreateNestedOneWithoutWSJobApplicationInput
    WSJobApplicationEducation?: WSJobApplicationEducationCreateNestedManyWithoutWSJobApplicationInput
    WSJobApplicationFeedback?: WSJobApplicationFeedbackCreateNestedManyWithoutWSJobApplicationInput
    WSJobApplicationPreviousEmployment?: WSJobApplicationPreviousEmploymentCreateNestedManyWithoutWSJobApplicationInput
    WSJobApplicationReference?: WSJobApplicationReferenceCreateNestedManyWithoutWSJobApplicationInput
  }

  export type WSJobApplicationUncheckedCreateWithoutWsUserInput = {
    ID?: number
    JobId: number
    IsValid?: string | null
    Status?: string | null
    Active: boolean
    CreatedBy?: string | null
    CreatedOn?: Date | string | null
    IsDenied?: boolean
    WSJobApplicationEducation?: WSJobApplicationEducationUncheckedCreateNestedManyWithoutWSJobApplicationInput
    WSJobApplicationFeedback?: WSJobApplicationFeedbackUncheckedCreateNestedManyWithoutWSJobApplicationInput
    WSJobApplicationPreviousEmployment?: WSJobApplicationPreviousEmploymentUncheckedCreateNestedManyWithoutWSJobApplicationInput
    WSJobApplicationReference?: WSJobApplicationReferenceUncheckedCreateNestedManyWithoutWSJobApplicationInput
  }

  export type WSJobApplicationCreateOrConnectWithoutWsUserInput = {
    where: WSJobApplicationWhereUniqueInput
    create: XOR<WSJobApplicationCreateWithoutWsUserInput, WSJobApplicationUncheckedCreateWithoutWsUserInput>
  }

  export type WSJobApplicationCreateManyWsUserInputEnvelope = {
    data: WSJobApplicationCreateManyWsUserInput | WSJobApplicationCreateManyWsUserInput[]
  }

  export type WSJobApplicationUpsertWithWhereUniqueWithoutWsUserInput = {
    where: WSJobApplicationWhereUniqueInput
    update: XOR<WSJobApplicationUpdateWithoutWsUserInput, WSJobApplicationUncheckedUpdateWithoutWsUserInput>
    create: XOR<WSJobApplicationCreateWithoutWsUserInput, WSJobApplicationUncheckedCreateWithoutWsUserInput>
  }

  export type WSJobApplicationUpdateWithWhereUniqueWithoutWsUserInput = {
    where: WSJobApplicationWhereUniqueInput
    data: XOR<WSJobApplicationUpdateWithoutWsUserInput, WSJobApplicationUncheckedUpdateWithoutWsUserInput>
  }

  export type WSJobApplicationUpdateManyWithWhereWithoutWsUserInput = {
    where: WSJobApplicationScalarWhereInput
    data: XOR<WSJobApplicationUpdateManyMutationInput, WSJobApplicationUncheckedUpdateManyWithoutWsUserInput>
  }

  export type WsProductsCreateManyWsDepartmentsInput = {
    vendor_id: number
    item_number: string
    description?: string | null
    ai_description?: string | null
    ai_name?: string | null
    bucket: string
    original_img_url: string
    final_img_url?: string | null
    top_sold?: number | null
    is_home?: boolean | null
    is_new_arrival?: boolean | null
    status?: string | null
    created_on?: Date | string | null
    created_by?: string | null
  }

  export type WsProductsUpdateWithoutWsDepartmentsInput = {
    vendor_id?: IntFieldUpdateOperationsInput | number
    item_number?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ai_description?: NullableStringFieldUpdateOperationsInput | string | null
    ai_name?: NullableStringFieldUpdateOperationsInput | string | null
    bucket?: StringFieldUpdateOperationsInput | string
    original_img_url?: StringFieldUpdateOperationsInput | string
    final_img_url?: NullableStringFieldUpdateOperationsInput | string | null
    top_sold?: NullableIntFieldUpdateOperationsInput | number | null
    is_home?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_new_arrival?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WsProductsUncheckedUpdateWithoutWsDepartmentsInput = {
    vendor_id?: IntFieldUpdateOperationsInput | number
    item_number?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ai_description?: NullableStringFieldUpdateOperationsInput | string | null
    ai_name?: NullableStringFieldUpdateOperationsInput | string | null
    bucket?: StringFieldUpdateOperationsInput | string
    original_img_url?: StringFieldUpdateOperationsInput | string
    final_img_url?: NullableStringFieldUpdateOperationsInput | string | null
    top_sold?: NullableIntFieldUpdateOperationsInput | number | null
    is_home?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_new_arrival?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WsProductsUncheckedUpdateManyWithoutWsDepartmentsInput = {
    vendor_id?: IntFieldUpdateOperationsInput | number
    item_number?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ai_description?: NullableStringFieldUpdateOperationsInput | string | null
    ai_name?: NullableStringFieldUpdateOperationsInput | string | null
    bucket?: StringFieldUpdateOperationsInput | string
    original_img_url?: StringFieldUpdateOperationsInput | string
    final_img_url?: NullableStringFieldUpdateOperationsInput | string | null
    top_sold?: NullableIntFieldUpdateOperationsInput | number | null
    is_home?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_new_arrival?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WSJobApplicationCreateManyWSJobInput = {
    UserId: number
    IsValid?: string | null
    Status?: string | null
    Active: boolean
    CreatedBy?: string | null
    CreatedOn?: Date | string | null
    IsDenied?: boolean
  }

  export type WSJobApplicationUpdateWithoutWSJobInput = {
    IsValid?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Active?: BoolFieldUpdateOperationsInput | boolean
    CreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsDenied?: BoolFieldUpdateOperationsInput | boolean
    WsUser?: WsUserUpdateOneRequiredWithoutWSJobApplicationNestedInput
    WSJobApplicationEducation?: WSJobApplicationEducationUpdateManyWithoutWSJobApplicationNestedInput
    WSJobApplicationFeedback?: WSJobApplicationFeedbackUpdateManyWithoutWSJobApplicationNestedInput
    WSJobApplicationPreviousEmployment?: WSJobApplicationPreviousEmploymentUpdateManyWithoutWSJobApplicationNestedInput
    WSJobApplicationReference?: WSJobApplicationReferenceUpdateManyWithoutWSJobApplicationNestedInput
  }

  export type WSJobApplicationUncheckedUpdateWithoutWSJobInput = {
    ID?: IntFieldUpdateOperationsInput | number
    UserId?: IntFieldUpdateOperationsInput | number
    IsValid?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Active?: BoolFieldUpdateOperationsInput | boolean
    CreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsDenied?: BoolFieldUpdateOperationsInput | boolean
    WSJobApplicationEducation?: WSJobApplicationEducationUncheckedUpdateManyWithoutWSJobApplicationNestedInput
    WSJobApplicationFeedback?: WSJobApplicationFeedbackUncheckedUpdateManyWithoutWSJobApplicationNestedInput
    WSJobApplicationPreviousEmployment?: WSJobApplicationPreviousEmploymentUncheckedUpdateManyWithoutWSJobApplicationNestedInput
    WSJobApplicationReference?: WSJobApplicationReferenceUncheckedUpdateManyWithoutWSJobApplicationNestedInput
  }

  export type WSJobApplicationUncheckedUpdateManyWithoutWSJobInput = {
    ID?: IntFieldUpdateOperationsInput | number
    UserId?: IntFieldUpdateOperationsInput | number
    IsValid?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Active?: BoolFieldUpdateOperationsInput | boolean
    CreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsDenied?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WSJobApplicationEducationCreateManyWSJobApplicationInput = {
    EducationLevel: string
    Name: string
    Address: string
    FromDate: string
    ToDate?: string | null
    IsGraduated: string
    IsValid?: string | null
  }

  export type WSJobApplicationFeedbackCreateManyWSJobApplicationInput = {
    Feedback: string
    CreatedBy: string
    CreatedOn: Date | string
  }

  export type WSJobApplicationPreviousEmploymentCreateManyWSJobApplicationInput = {
    Company: string
    Supervisor: string
    Address: string
    FromDate: Date | string
    ToDate?: Date | string | null
    JobTitle: string
    EndingSalary?: number | null
    IsHourlyRate?: string | null
    LeavingReason?: string | null
    IsValid?: string | null
  }

  export type WSJobApplicationReferenceCreateManyWSJobApplicationInput = {
    FullName: string
    Relationship: string
    Company: string
    Phone: string
    Email: string
    IsValid?: string | null
  }

  export type WSJobApplicationEducationUpdateWithoutWSJobApplicationInput = {
    EducationLevel?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    FromDate?: StringFieldUpdateOperationsInput | string
    ToDate?: NullableStringFieldUpdateOperationsInput | string | null
    IsGraduated?: StringFieldUpdateOperationsInput | string
    IsValid?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WSJobApplicationEducationUncheckedUpdateWithoutWSJobApplicationInput = {
    ID?: IntFieldUpdateOperationsInput | number
    EducationLevel?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    FromDate?: StringFieldUpdateOperationsInput | string
    ToDate?: NullableStringFieldUpdateOperationsInput | string | null
    IsGraduated?: StringFieldUpdateOperationsInput | string
    IsValid?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WSJobApplicationEducationUncheckedUpdateManyWithoutWSJobApplicationInput = {
    ID?: IntFieldUpdateOperationsInput | number
    EducationLevel?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    FromDate?: StringFieldUpdateOperationsInput | string
    ToDate?: NullableStringFieldUpdateOperationsInput | string | null
    IsGraduated?: StringFieldUpdateOperationsInput | string
    IsValid?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WSJobApplicationFeedbackUpdateWithoutWSJobApplicationInput = {
    Feedback?: StringFieldUpdateOperationsInput | string
    CreatedBy?: StringFieldUpdateOperationsInput | string
    CreatedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    WsJobApplicationReply?: WsJobApplicationReplyUpdateManyWithoutWSJobApplicationFeedbackNestedInput
  }

  export type WSJobApplicationFeedbackUncheckedUpdateWithoutWSJobApplicationInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Feedback?: StringFieldUpdateOperationsInput | string
    CreatedBy?: StringFieldUpdateOperationsInput | string
    CreatedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    WsJobApplicationReply?: WsJobApplicationReplyUncheckedUpdateManyWithoutWSJobApplicationFeedbackNestedInput
  }

  export type WSJobApplicationFeedbackUncheckedUpdateManyWithoutWSJobApplicationInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Feedback?: StringFieldUpdateOperationsInput | string
    CreatedBy?: StringFieldUpdateOperationsInput | string
    CreatedOn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WSJobApplicationPreviousEmploymentUpdateWithoutWSJobApplicationInput = {
    Company?: StringFieldUpdateOperationsInput | string
    Supervisor?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    FromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ToDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    JobTitle?: StringFieldUpdateOperationsInput | string
    EndingSalary?: NullableFloatFieldUpdateOperationsInput | number | null
    IsHourlyRate?: NullableStringFieldUpdateOperationsInput | string | null
    LeavingReason?: NullableStringFieldUpdateOperationsInput | string | null
    IsValid?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WSJobApplicationPreviousEmploymentUncheckedUpdateWithoutWSJobApplicationInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Company?: StringFieldUpdateOperationsInput | string
    Supervisor?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    FromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ToDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    JobTitle?: StringFieldUpdateOperationsInput | string
    EndingSalary?: NullableFloatFieldUpdateOperationsInput | number | null
    IsHourlyRate?: NullableStringFieldUpdateOperationsInput | string | null
    LeavingReason?: NullableStringFieldUpdateOperationsInput | string | null
    IsValid?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WSJobApplicationPreviousEmploymentUncheckedUpdateManyWithoutWSJobApplicationInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Company?: StringFieldUpdateOperationsInput | string
    Supervisor?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    FromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ToDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    JobTitle?: StringFieldUpdateOperationsInput | string
    EndingSalary?: NullableFloatFieldUpdateOperationsInput | number | null
    IsHourlyRate?: NullableStringFieldUpdateOperationsInput | string | null
    LeavingReason?: NullableStringFieldUpdateOperationsInput | string | null
    IsValid?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WSJobApplicationReferenceUpdateWithoutWSJobApplicationInput = {
    FullName?: StringFieldUpdateOperationsInput | string
    Relationship?: StringFieldUpdateOperationsInput | string
    Company?: StringFieldUpdateOperationsInput | string
    Phone?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    IsValid?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WSJobApplicationReferenceUncheckedUpdateWithoutWSJobApplicationInput = {
    ID?: IntFieldUpdateOperationsInput | number
    FullName?: StringFieldUpdateOperationsInput | string
    Relationship?: StringFieldUpdateOperationsInput | string
    Company?: StringFieldUpdateOperationsInput | string
    Phone?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    IsValid?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WSJobApplicationReferenceUncheckedUpdateManyWithoutWSJobApplicationInput = {
    ID?: IntFieldUpdateOperationsInput | number
    FullName?: StringFieldUpdateOperationsInput | string
    Relationship?: StringFieldUpdateOperationsInput | string
    Company?: StringFieldUpdateOperationsInput | string
    Phone?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    IsValid?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WsJobApplicationReplyCreateManyWSJobApplicationFeedbackInput = {
    Message: string
    CreatedBy: string
    CreatedOn: Date | string
    ModifiedOn?: Date | string | null
  }

  export type WsJobApplicationReplyUpdateWithoutWSJobApplicationFeedbackInput = {
    Message?: StringFieldUpdateOperationsInput | string
    CreatedBy?: StringFieldUpdateOperationsInput | string
    CreatedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    ModifiedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WsJobApplicationReplyUncheckedUpdateWithoutWSJobApplicationFeedbackInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Message?: StringFieldUpdateOperationsInput | string
    CreatedBy?: StringFieldUpdateOperationsInput | string
    CreatedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    ModifiedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WsJobApplicationReplyUncheckedUpdateManyWithoutWSJobApplicationFeedbackInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Message?: StringFieldUpdateOperationsInput | string
    CreatedBy?: StringFieldUpdateOperationsInput | string
    CreatedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    ModifiedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WSJobCreateManyWsStoreInput = {
    Name: string
    Description?: string | null
    Type?: string | null
    Category?: string | null
    CreatedOn?: Date | string | null
    Active?: boolean
    Status?: string | null
    CreatedBy: string
    MaxSalary?: number
    MinSalary?: number
    SalaryType?: string
  }

  export type WSJobUpdateWithoutWsStoreInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Active?: BoolFieldUpdateOperationsInput | boolean
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedBy?: StringFieldUpdateOperationsInput | string
    MaxSalary?: FloatFieldUpdateOperationsInput | number
    MinSalary?: FloatFieldUpdateOperationsInput | number
    SalaryType?: StringFieldUpdateOperationsInput | string
    WSJobApplication?: WSJobApplicationUpdateManyWithoutWSJobNestedInput
  }

  export type WSJobUncheckedUpdateWithoutWsStoreInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Active?: BoolFieldUpdateOperationsInput | boolean
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedBy?: StringFieldUpdateOperationsInput | string
    MaxSalary?: FloatFieldUpdateOperationsInput | number
    MinSalary?: FloatFieldUpdateOperationsInput | number
    SalaryType?: StringFieldUpdateOperationsInput | string
    WSJobApplication?: WSJobApplicationUncheckedUpdateManyWithoutWSJobNestedInput
  }

  export type WSJobUncheckedUpdateManyWithoutWsStoreInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    Category?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Active?: BoolFieldUpdateOperationsInput | boolean
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedBy?: StringFieldUpdateOperationsInput | string
    MaxSalary?: FloatFieldUpdateOperationsInput | number
    MinSalary?: FloatFieldUpdateOperationsInput | number
    SalaryType?: StringFieldUpdateOperationsInput | string
  }

  export type WSStateCreateManyWSTaxExemptInput = {
    state?: string | null
    st_licenseNumber?: string | null
    st_expiryDate?: Date | string | null
    st_fileUrl?: string | null
    ll_licenseNumber?: string | null
    ll_expiryDate?: Date | string | null
    ll_fileUrl?: string | null
  }

  export type WSStateUpdateWithoutWSTaxExemptInput = {
    state?: NullableStringFieldUpdateOperationsInput | string | null
    st_licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    st_expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    st_fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ll_licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ll_expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ll_fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WSStateUncheckedUpdateWithoutWSTaxExemptInput = {
    ID?: IntFieldUpdateOperationsInput | number
    state?: NullableStringFieldUpdateOperationsInput | string | null
    st_licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    st_expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    st_fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ll_licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ll_expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ll_fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WSStateUncheckedUpdateManyWithoutWSTaxExemptInput = {
    ID?: IntFieldUpdateOperationsInput | number
    state?: NullableStringFieldUpdateOperationsInput | string | null
    st_licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    st_expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    st_fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ll_licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ll_expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ll_fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WSJobApplicationCreateManyWsUserInput = {
    JobId: number
    IsValid?: string | null
    Status?: string | null
    Active: boolean
    CreatedBy?: string | null
    CreatedOn?: Date | string | null
    IsDenied?: boolean
  }

  export type WSJobApplicationUpdateWithoutWsUserInput = {
    IsValid?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Active?: BoolFieldUpdateOperationsInput | boolean
    CreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsDenied?: BoolFieldUpdateOperationsInput | boolean
    WSJob?: WSJobUpdateOneRequiredWithoutWSJobApplicationNestedInput
    WSJobApplicationEducation?: WSJobApplicationEducationUpdateManyWithoutWSJobApplicationNestedInput
    WSJobApplicationFeedback?: WSJobApplicationFeedbackUpdateManyWithoutWSJobApplicationNestedInput
    WSJobApplicationPreviousEmployment?: WSJobApplicationPreviousEmploymentUpdateManyWithoutWSJobApplicationNestedInput
    WSJobApplicationReference?: WSJobApplicationReferenceUpdateManyWithoutWSJobApplicationNestedInput
  }

  export type WSJobApplicationUncheckedUpdateWithoutWsUserInput = {
    ID?: IntFieldUpdateOperationsInput | number
    JobId?: IntFieldUpdateOperationsInput | number
    IsValid?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Active?: BoolFieldUpdateOperationsInput | boolean
    CreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsDenied?: BoolFieldUpdateOperationsInput | boolean
    WSJobApplicationEducation?: WSJobApplicationEducationUncheckedUpdateManyWithoutWSJobApplicationNestedInput
    WSJobApplicationFeedback?: WSJobApplicationFeedbackUncheckedUpdateManyWithoutWSJobApplicationNestedInput
    WSJobApplicationPreviousEmployment?: WSJobApplicationPreviousEmploymentUncheckedUpdateManyWithoutWSJobApplicationNestedInput
    WSJobApplicationReference?: WSJobApplicationReferenceUncheckedUpdateManyWithoutWSJobApplicationNestedInput
  }

  export type WSJobApplicationUncheckedUpdateManyWithoutWsUserInput = {
    ID?: IntFieldUpdateOperationsInput | number
    JobId?: IntFieldUpdateOperationsInput | number
    IsValid?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Active?: BoolFieldUpdateOperationsInput | boolean
    CreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IsDenied?: BoolFieldUpdateOperationsInput | boolean
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use WsDepartmentsCountOutputTypeDefaultArgs instead
     */
    export type WsDepartmentsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WsDepartmentsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WSJobCountOutputTypeDefaultArgs instead
     */
    export type WSJobCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WSJobCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WSJobApplicationCountOutputTypeDefaultArgs instead
     */
    export type WSJobApplicationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WSJobApplicationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WSJobApplicationFeedbackCountOutputTypeDefaultArgs instead
     */
    export type WSJobApplicationFeedbackCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WSJobApplicationFeedbackCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WsStoreCountOutputTypeDefaultArgs instead
     */
    export type WsStoreCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WsStoreCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WSTaxExemptCountOutputTypeDefaultArgs instead
     */
    export type WSTaxExemptCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WSTaxExemptCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WsUserCountOutputTypeDefaultArgs instead
     */
    export type WsUserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WsUserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WsBillboardsDefaultArgs instead
     */
    export type WsBillboardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WsBillboardsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WsCategoriesDefaultArgs instead
     */
    export type WsCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WsCategoriesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WsDepartmentsDefaultArgs instead
     */
    export type WsDepartmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WsDepartmentsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WsHomeBannersDefaultArgs instead
     */
    export type WsHomeBannersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WsHomeBannersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WsImagesDefaultArgs instead
     */
    export type WsImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WsImagesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WSJobDefaultArgs instead
     */
    export type WSJobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WSJobDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WSJobApplicationDefaultArgs instead
     */
    export type WSJobApplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WSJobApplicationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WSJobApplicationEducationDefaultArgs instead
     */
    export type WSJobApplicationEducationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WSJobApplicationEducationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WSJobApplicationFeedbackDefaultArgs instead
     */
    export type WSJobApplicationFeedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WSJobApplicationFeedbackDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WSJobApplicationPreviousEmploymentDefaultArgs instead
     */
    export type WSJobApplicationPreviousEmploymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WSJobApplicationPreviousEmploymentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WSJobApplicationReferenceDefaultArgs instead
     */
    export type WSJobApplicationReferenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WSJobApplicationReferenceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WsJobApplicationReplyDefaultArgs instead
     */
    export type WsJobApplicationReplyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WsJobApplicationReplyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WsProductsDefaultArgs instead
     */
    export type WsProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WsProductsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WsProfileDefaultArgs instead
     */
    export type WsProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WsProfileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WSStateDefaultArgs instead
     */
    export type WSStateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WSStateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WsStoreDefaultArgs instead
     */
    export type WsStoreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WsStoreDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WSTaxExemptDefaultArgs instead
     */
    export type WSTaxExemptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WSTaxExemptDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WsUserDefaultArgs instead
     */
    export type WsUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WsUserDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}